{
    "projects": [
        {
            "name": "Codec",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.MetaphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:<init>()V",
                                    "method_body": "public Metaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:metaphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String metaphone(String txt) {\nboolean hard = false ;\nif ((txt == null) || (txt.length() == 0)) {\nif (txt.length() == 1) {\nreturn txt.toUpperCase() ;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn metaphone(pString);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:<init>()V",
                                    "method_body": "public Metaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:metaphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String metaphone(String txt) {\nboolean hard = false ;\nif ((txt == null) || (txt.length() == 0)) {\nif (txt.length() == 1) {\nreturn txt.toUpperCase() ;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn metaphone(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "protected int maxCodeLen = 4;\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String[] L_R_N_M_B_H_F_V_W_SPACE =\n{ \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.SoundexTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>()V",
                                    "method_body": "public Soundex() {\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>([C)V",
                                    "method_body": "private int maxLength = 4;\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<clinit>()V",
                                    "method_body": "public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\npublic static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\npublic static final Soundex US_ENGLISH = new Soundex();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn soundex(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getMappingCode(Ljava/lang/String;I)C",
                                    "method_body": "private char getMappingCode(String str, int index) {\nchar mappedChar = this.map(str.charAt(index));\nif (index > 1 && mappedChar != '0') {\nreturn mappedChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getSoundexMapping()[C",
                                    "method_body": "private char[] getSoundexMapping() {\nreturn this.soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:map(C)C",
                                    "method_body": "private char map(char ch) {\nint index = ch - 'A';\nif (index < 0 || index >= this.getSoundexMapping().length) {\nthrow new IllegalArgumentException(\"The character is not mapped: \" + ch);\nreturn this.getSoundexMapping()[index];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:setSoundexMapping([C)V",
                                    "method_body": "private void setSoundexMapping(char[] soundexMapping) {\nthis.soundexMapping = soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nchar out[] = {'0', '0', '0', '0'};\nint incount = 1, count = 1;\nout[0] = str.charAt(0);\nlast = getMappingCode(str, 0);\nwhile ((incount < str.length()) && (count < out.length)) {\nreturn new String(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(String str) {\nif (str == null || str.length() == 0) {\nint len = str.length();\nchar[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\nif (count == len) {\nreturn str.toUpperCase();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.RefinedSoundexTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(String str) {\nif (str == null || str.length() == 0) {\nint len = str.length();\nchar[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\nif (count == len) {\nreturn str.toUpperCase();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<init>()V",
                                    "method_body": "public RefinedSoundex() {\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<init>([C)V",
                                    "method_body": "public RefinedSoundex(char[] mapping) {\nthis.soundexMapping = mapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<clinit>()V",
                                    "method_body": "public static final char[] US_ENGLISH_MAPPING = \"01360240043788015936020505\".toCharArray();\npublic static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn soundex(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:getMappingCode(C)C",
                                    "method_body": "char getMappingCode(char c) {\nif (!Character.isLetter(c)) {\nreturn this.soundexMapping[Character.toUpperCase(c) - 'A'];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nStringBuffer sBuf = new StringBuffer();\nsBuf.append(str.charAt(0));\nlast = '*';\nfor (int i = 0; i < str.length(); i++) {\ncurrent = getMappingCode(str.charAt(i));\nif (current == last) {\n} else if (current != 0) {\nsBuf.append(current);\nlast = current;\nreturn sBuf.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.CaverphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:<init>()V",
                                    "method_body": "public Caverphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:caverphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String caverphone(String txt) {\nif( txt == null || txt.length() == 0 ) {\ntxt = txt.toLowerCase();\ntxt = txt.replaceAll(\"[^a-z]\", \"\");\ntxt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\ntxt = txt.replaceAll(\"^cough\", \"cou2f\");\ntxt = txt.replaceAll(\"^rough\", \"rou2f\");\ntxt = txt.replaceAll(\"^tough\", \"tou2f\");\ntxt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\ntxt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\ntxt = txt.replaceAll(\"^gn\", \"2n\");\ntxt = txt.replaceAll(\"^mb\", \"m2\");\ntxt = txt.replaceAll(\"cq\", \"2q\");\ntxt = txt.replaceAll(\"ci\", \"si\");\ntxt = txt.replaceAll(\"ce\", \"se\");\ntxt = txt.replaceAll(\"cy\", \"sy\");\ntxt = txt.replaceAll(\"tch\", \"2ch\");\ntxt = txt.replaceAll(\"c\", \"k\");\ntxt = txt.replaceAll(\"q\", \"k\");\ntxt = txt.replaceAll(\"x\", \"k\");\ntxt = txt.replaceAll(\"v\", \"f\");\ntxt = txt.replaceAll(\"dg\", \"2g\");\ntxt = txt.replaceAll(\"tio\", \"sio\");\ntxt = txt.replaceAll(\"tia\", \"sia\");\ntxt = txt.replaceAll(\"d\", \"t\");\ntxt = txt.replaceAll(\"ph\", \"fh\");\ntxt = txt.replaceAll(\"b\", \"p\");\ntxt = txt.replaceAll(\"sh\", \"s2\");\ntxt = txt.replaceAll(\"z\", \"s\");\ntxt = txt.replaceAll(\"^[aeiou]\", \"A\");\ntxt = txt.replaceAll(\"[aeiou]\", \"3\");\ntxt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\ntxt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\ntxt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\ntxt = txt.replaceAll(\"3gh3\", \"3kh3\");\ntxt = txt.replaceAll(\"gh\", \"22\");\ntxt = txt.replaceAll(\"g\", \"k\");\ntxt = txt.replaceAll(\"s+\", \"S\");\ntxt = txt.replaceAll(\"t+\", \"T\");\ntxt = txt.replaceAll(\"p+\", \"P\");\ntxt = txt.replaceAll(\"k+\", \"K\");\ntxt = txt.replaceAll(\"f+\", \"F\");\ntxt = txt.replaceAll(\"m+\", \"M\");\ntxt = txt.replaceAll(\"n+\", \"N\");\ntxt = txt.replaceAll(\"w3\", \"W3\");\ntxt = txt.replaceAll(\"wh3\", \"Wh3\");\ntxt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"w\", \"2\");\ntxt = txt.replaceAll(\"^h\", \"A\");\ntxt = txt.replaceAll(\"h\", \"2\");\ntxt = txt.replaceAll(\"r3\", \"R3\");\ntxt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"r\", \"2\");\ntxt = txt.replaceAll(\"l3\", \"L3\");\ntxt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"l\", \"2\");\ntxt = txt.replaceAll(\"2\", \"\");\ntxt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"3\", \"\");\ntxt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\nreturn txt.substring(0, 10);          // 1.0 truncates to 6\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn caverphone(pString);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream",
                            "test_body": "50: public void testBase64EmptyInputStream() throws Exception {\n51: byte[] emptyEncoded = new byte[0];\n52: byte[] emptyDecoded = new byte[0];\n53: testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n54: testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n55: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint r = read(singleByte, 0, 1);\nwhile (r == 0) {\nif (r > 0) {\nreturn singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\n} else if (offset < 0 || len < 0 || offset + len < 0) {\n} else if (offset > b.length || offset + len > b.length) {\n} else if (len == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nif (doEncode) {\nbase64.encode(buf, 0, c);\nreturn base64.readResults(b, offset, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nthis.lineLength = lineLength;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buf != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buf != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuf()V",
                                    "method_body": "private void resizeBuf() {\nif (buf == null) {\nbuf = new byte[8192];\npos = 0;\nreadPos = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buf != null) {\nint len = Math.min(avail(), bAvail);\nif (buf != b) {\nSystem.arraycopy(buf, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuf = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\nswitch (modulus) {\nif (lineLength > 0) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStream",
                            "test_body": "50: public void testBase64EmptyOutputStream() throws Exception {\n51: byte[] emptyEncoded = new byte[0];\n52: byte[] emptyDecoded = new byte[0];\n53: testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n54: testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n55: }    \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nthis.lineLength = lineLength;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buf != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuf()V",
                                    "method_body": "private void resizeBuf() {\nif (buf == null) {\nbuf = new byte[8192];\npos = 0;\nreadPos = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buf != null) {\nint len = Math.min(avail(), bAvail);\nif (buf != b) {\nSystem.arraycopy(buf, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuf = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\nswitch (modulus) {\nif (lineLength > 0) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:<init>(Ljava/io/OutputStream;ZI[B)V",
                                    "method_body": "public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(out);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush(Z)V",
                                    "method_body": "private void flush(boolean propogate) throws IOException {\nint avail = base64.avail();\nif (avail > 0) {\nbyte[] buf = new byte[avail];\nint c = base64.readResults(buf, 0, avail);\nif (c > 0) {\nout.write(buf, 0, c);\nif (propogate) {\nout.flush();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush()V",
                                    "method_body": "public void flush() throws IOException {\nflush(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (doEncode) {\nbase64.encode(singleByte, 0, -1);\nflush();\nout.close();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphone2Test.testDoubleMetaphoneAlternate",
                            "test_body": "80: public void testDoubleMetaphoneAlternate() {\n81: String value = null;\n82: for (int i = 0; i < TEST_DATA.length; i++) {\n83: value = TEST_DATA[i][0];\n84: assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));\n85: }\n86: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "public DoubleMetaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String VOWELS = \"AEIOUY\";\nprivate static final String[] SILENT_START =\n{ \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nboolean slavoGermanic = isSlavoGermanic(value);\nint index = isSilentStart(value) ? 1 : 0;\nDoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\nwhile (!result.isComplete() && index <= value.length() - 1) {\nswitch (value.charAt(index)) {\nindex = handleAEIOUY(value, result, index);\nbreak;\nresult.append('P');\nindex = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\nbreak;\nindex = handleC(value, result, index);\nbreak;\nindex = handleD(value, result, index);\nbreak;\nindex = handleG(value, result, index, slavoGermanic);\nbreak;\nindex = handleH(value, result, index);\nbreak;\nresult.append('K');\nindex = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\nbreak;\nindex = handleL(value, result, index);\nbreak;\nresult.append('M');\nindex = conditionM0(value, index) ? index + 2 : index + 1;\nbreak;\nresult.append('N');\nindex = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\nbreak;\nindex = handleP(value, result, index);\nbreak;\nindex = handleR(value, result, index, slavoGermanic);\nbreak;\nindex = handleS(value, result, index, slavoGermanic);\nbreak;\nindex = handleT(value, result, index);\nbreak;\nresult.append('F');\nindex = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\nbreak;\nindex = handleW(value, result, index);\nbreak;\nreturn alternate ? result.getAlternate() : result.getPrimary();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:getMaxCodeLen()I",
                                    "method_body": "public int getMaxCodeLen() {\nreturn this.maxCodeLen;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleAEIOUY(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleAEIOUY(String value, DoubleMetaphoneResult result, int\nif (index == 0) {\nresult.append('A');\nreturn index + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleC(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleC(String value,\nif (conditionC0(value, index)) {  // very confusing, moved out\n} else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n} else if (contains(value, index, 2, \"CH\")) {\n} else if (contains(value, index, 2, \"CZ\") &&\n} else if (contains(value, index + 1, 3, \"CIA\")) {\n} else if (contains(value, index, 2, \"CC\") &&\n} else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\nresult.append('K');\nindex += 2;\n} else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\nresult.append('K');\nif (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\n} else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") &&\nindex++;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleD(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleD(String value,\nif (contains(value, index, 2, \"DG\")) {\n} else if (contains(value, index, 2, \"DT\", \"DD\")) {\nresult.append('T');\nindex++;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleG(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleG(String value,\nif (charAt(value, index + 1) == 'H') {\n} else if (charAt(value, index + 1) == 'N') {\n} else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n} else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n} else if ((contains(value, index + 1, 2, \"ER\") ||\n} else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\nif ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n} else if (contains(value, index + 1, 4, \"IER\")) {\nresult.append('J', 'K');\nindex += 2;\n} else if (charAt(value, index + 1) == 'G') {\nindex += 2;\nresult.append('K');\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleH(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleH(String value,\nif ((index == 0 || isVowel(charAt(value, index - 1))) &&\nindex++;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleL(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleL(String value,\nif (charAt(value, index + 1) == 'L') {\nif (conditionL0(value, index)) {\nresult.append('L');\nindex += 2;\nindex++;\nresult.append('L');\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleP(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleP(String value,\nif (charAt(value, index + 1) == 'H') {\nresult.append('P');\nindex = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleR(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleR(String value,\nif (index == value.length() - 1 && !slavoGermanic &&\nresult.appendAlternate('R');\nresult.append('R');\nreturn charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleS(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleS(String value,\nif (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n} else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n} else if (contains(value, index, 2, \"SH\")) {\n} else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n} else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n} else if (contains(value, index, 2, \"SC\")) {\nif (index == value.length() - 1 && contains(value, index - 2,\nresult.append('S');\nindex = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleT(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleT(String value,\nif (contains(value, index, 4, \"TION\")) {\n} else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n} else if (contains(value, index, 2, \"TH\") || contains(value, index,\nresult.append('T');\nindex = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleW(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleW(String value,\nif (contains(value, index, 2, \"WR\")) {\nif (index == 0 && (isVowel(charAt(value, index + 1)) ||\n} else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n} else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\nindex++;\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionC0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionC0(String value, int index) {\nif (contains(value, index, 4, \"CHIA\")) {\n} else if (index <= 1) {\nreturn false;\n} else if (isVowel(charAt(value, index - 2))) {\nreturn false;\n} else if (!contains(value, index - 1, 3, \"ACH\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionL0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionL0(String value, int index) {\nif (index == value.length() - 3 &&\n} else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") ||\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionM0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionM0(String value, int index) {\nif (charAt(value, index + 1) == 'M') {\nreturn contains(value, index - 1, 3, \"UMB\") &&\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isSlavoGermanic(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isSlavoGermanic(String value) {\nreturn value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isVowel(C)Z",
                                    "method_body": "private boolean isVowel(char ch) {\nreturn VOWELS.indexOf(ch) != -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isSilentStart(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isSilentStart(String value) {\nboolean result = false;\nfor (int i = 0; i < SILENT_START.length; i++) {\nif (value.startsWith(SILENT_START[i])) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\ninput = input.trim();\nif (input.length() == 0) {\nreturn input.toUpperCase(java.util.Locale.ENGLISH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:charAt(Ljava/lang/String;I)C",
                                    "method_body": "protected char charAt(String value, int index) {\nif (index < 0 || index >= value.length()) {\nreturn Character.MIN_VALUE;\nreturn value.charAt(index);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nreturn contains(value, start, length,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nreturn contains(value, start, length,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nreturn contains(value, start, length,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nreturn contains(value, start, length,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;II[Ljava/lang/String;)Z",
                                    "method_body": "protected static boolean contains(String value, int start, int length,\nboolean result = false;\nif (start >= 0 && start + length <= value.length()) {\nString target = value.substring(start, start + length);\nfor (int i = 0; i < criteria.length; i++) {\nif (target.equals(criteria[i])) {\nresult = true;\nbreak;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:<init>(Lorg/apache/commons/codec/language/DoubleMetaphone;I)V",
                                    "method_body": "public DoubleMetaphoneResult(int maxLength) {\nthis.maxLength = maxLength;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:append(C)V",
                                    "method_body": "public void append(char value) {\nappendPrimary(value);\nappendAlternate(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:append(CC)V",
                                    "method_body": "public void append(char primary, char alternate) {\nappendPrimary(primary);\nappendAlternate(alternate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:appendPrimary(C)V",
                                    "method_body": "public void appendPrimary(char value) {\nif (this.primary.length() < this.maxLength) {\nthis.primary.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:appendAlternate(C)V",
                                    "method_body": "public void appendAlternate(char value) {\nif (this.alternate.length() < this.maxLength) {\nthis.alternate.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:getAlternate()Ljava/lang/String;",
                                    "method_body": "public String getAlternate() {\nreturn this.alternate.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:isComplete()Z",
                                    "method_body": "public boolean isComplete() {\nreturn this.primary.length() >= this.maxLength &&\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Codec13Test.testEncoder",
                            "test_body": "371: public void testEncoder() throws EncoderException {\n372: Encoder enc = new Base64();\n373: for (int i = 0; i < STRINGS.length; i++) {\n374: if (STRINGS[i] != null) {\n375: byte[] base64 = utf8(STRINGS[i]);\n376: byte[] binary = BYTES[i];\n377: boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n378: assertTrue(\"Encoder test-\" + i, b);\n379: }\n380: }\n381: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>()V",
                                    "method_body": "public Base64() {\nthis(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nswitch (modulus) {\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\nx = (x << 8) + b;\nif (0 == modulus) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public Object encode(Object pObject) throws EncoderException {\nif (!(pObject instanceof byte[])) {\nreturn encode((byte[]) pObject);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nif (buffer != buf) {\nif (isUrlSafe() && pos < buf.length) {\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\nchunkSize = (chunkSize / 4) * 4;\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Codec13Test.testBinaryEncoder",
                            "test_body": "407: public void testBinaryEncoder() throws EncoderException {\n408: BinaryEncoder enc = new Base64();\n409: for (int i = 0; i < STRINGS.length; i++) {\n410: if (STRINGS[i] != null) {\n411: byte[] base64 = utf8(STRINGS[i]);\n412: byte[] binary = BYTES[i];\n413: boolean b = Arrays.equals(base64, enc.encode(binary));\n414: assertTrue(\"BinaryEncoder test-\" + i, b);\n415: }\n416: }\n417: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>()V",
                                    "method_body": "public Base64() {\nthis(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nswitch (modulus) {\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\nx = (x << 8) + b;\nif (0 == modulus) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nif (buffer != buf) {\nif (isUrlSafe() && pos < buf.length) {\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\nchunkSize = (chunkSize / 4) * 4;\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec98NPE",
                            "test_body": "55: public void testCodec98NPE() throws Exception {\n56: byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n57: ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n58: Base64InputStream stream = new Base64InputStream(data);\n59: 60: // This line causes an NPE in commons-codec-1.4.jar:\n61: byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n62: 63: String decoded = StringUtils.newStringUtf8(decodedBytes);\n64: assertEquals(\n65: \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n66: );\n67: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Base64InputStream(InputStream in) {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "private final boolean doEncode;\nprivate final byte[] singleByte = new byte[1];\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\n} else if (offset < 0 || len < 0) {\n} else if (offset > b.length || offset + len > b.length) {\n} else if (len == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\nif (doEncode) {\nbase64.decode(buf, 0, c);\nreturn base64.readResults(b, offset, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "private static final byte[] STANDARD_ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nif (buffer != b) {\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\nbuffer = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\nbyte b = in[inPos++];\nif (b == PAD) {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\nif (eof && modulus != 0) {\nx = x << 6;\nswitch (modulus) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64OutputStreamTest.testCodec98NPE",
                            "test_body": "55: public void testCodec98NPE() throws Exception {\n56: byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n57: byte[] codec98_1024 = new byte[1024];\n58: System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n59: ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n60: Base64OutputStream stream = new Base64OutputStream(data, false);\n61: stream.write(codec98_1024, 0, 1024);\n62: stream.close();\n63: 64: byte[] decodedBytes = data.toByteArray();\n65: String decoded = StringUtils.newStringUtf8(decodedBytes);\n66: assertEquals(\n67: \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n68: );\n69: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "private static final byte[] STANDARD_ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\nbyte b = in[inPos++];\nif (b == PAD) {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\nif (eof && modulus != 0) {\nx = x << 6;\nswitch (modulus) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:<init>(Ljava/io/OutputStream;Z)V",
                                    "method_body": "public Base64OutputStream(OutputStream out, boolean doEncode) {\nsuper(out);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:<init>(Ljava/io/OutputStream;ZI[B)V",
                                    "method_body": "private final boolean doEncode;\nprivate final byte[] singleByte = new byte[1];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:write([BII)V",
                                    "method_body": "public void write(byte b[], int offset, int len) throws IOException {\nif (b == null) {\n} else if (offset < 0 || len < 0) {\n} else if (offset > b.length || offset + len > b.length) {\n} else if (len > 0) {\nif (doEncode) {\nbase64.decode(b, offset, len);\nflush(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush(Z)V",
                                    "method_body": "private void flush(boolean propogate) throws IOException {\nint avail = base64.avail();\nif (avail > 0) {\nbyte[] buf = new byte[avail];\nint c = base64.readResults(buf, 0, avail);\nif (c > 0) {\nout.write(buf, 0, c);\nif (propogate) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (doEncode) {\nbase64.decode(singleByte, 0, -1);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec101",
                            "test_body": "55: public void testCodec101() throws Exception {\n56: byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n57: ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n58: Base64InputStream in = new Base64InputStream(bais);\n59: byte[] result = new byte[8192];\n60: int c = in.read(result);\n61: assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n62: 63: c = in.read(result);\n64: assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n65: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Base64InputStream(InputStream in) {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "private final boolean doEncode;\nprivate final byte[] singleByte = new byte[1];\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\n} else if (offset < 0 || len < 0) {\n} else if (offset > b.length || offset + len > b.length) {\n} else if (len == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\nif (doEncode) {\nbase64.decode(buf, 0, c);\nreturn base64.readResults(b, offset, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "private static final byte[] STANDARD_ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nif (buffer != b) {\nbuffer = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nbyte b = in[inPos++];\nif (b == PAD) {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nif (eof && modulus != 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testByteToStringVariations",
                            "test_body": "1121: public void testByteToStringVariations() throws DecoderException {\n1122: Base64 base64 = new Base64(0);\n1123: byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n1124: byte[] b2 = new byte[0];\n1125: byte[] b3 = null;\n1126: byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n1127: 1128: assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n1129: assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n1130: assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n1131: assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n1132: assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n1133: assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n1134: assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n1135: assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", Base64.encodeBase64String(b4));\n1136: assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n1137: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn new String(bytes, charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:<clinit>()V",
                                    "method_body": "public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\nprivate static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:decodeHex([C)[B",
                                    "method_body": "public static byte[] decodeHex(char[] data) throws DecoderException {\nint len = data.length;\nif ((len & 0x01) != 0) {\nbyte[] out = new byte[len >> 1];\nfor (int i = 0, j = 0; j < len; i++) {\nint f = toDigit(data[j], j) << 4;\nj++;\nf = f | toDigit(data[j], j);\nj++;\nout[i] = (byte) (f & 0xFF);\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:toDigit(CI)I",
                                    "method_body": "protected static int toDigit(char ch, int index) throws DecoderException {\nint digit = Character.digit(ch, 16);\nif (digit == -1) {\nreturn digit;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I)V",
                                    "method_body": "public Base64(int lineLength) {\nthis(lineLength, CHUNK_SEPARATOR);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\nthis.encodeSize = 4;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64String([B)Ljava/lang/String;",
                                    "method_body": "public static String encodeBase64String(byte[] binaryData) {\nreturn StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nreturn binaryData;\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeToString([B)Ljava/lang/String;",
                                    "method_body": "public String encodeToString(byte[] pArray) {\nreturn StringUtils.newStringUtf8(encode(pArray));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nif (buffer != buf) {\nif (isUrlSafe() && pos < buf.length) {\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\nchunkSize = (chunkSize / 4) * 4;\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testRfc4648Section10Encode",
                            "test_body": "584: public void testRfc4648Section10Encode() {\n585: assertEquals(\"\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\")));\n586: assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));\n587: assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));\n588: assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));\n589: assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));\n590: assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));\n591: assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));\n592: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn new String(bytes, charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nswitch (modulus) {\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64String([B)Ljava/lang/String;",
                                    "method_body": "public static String encodeBase64String(byte[] binaryData) {\nreturn StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nreturn binaryData;\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nif (buffer != buf) {\nif (isUrlSafe() && pos < buf.length) {\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\nchunkSize = (chunkSize / 4) * 4;\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105",
                            "test_body": "55: public void testCodec105() throws IOException {\n56: Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n57: for (int i = 0; i < 5; i++) {\n58: in.read();\n59: }\n60: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint r = read(singleByte, 0, 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\n} else if (offset < 0 || len < 0) {\n} else if (offset > b.length || offset + len > b.length) {\n} else if (len == 0) {\nint readLen = 0;\nwhile (readLen == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\nif (doEncode) {\nbase64.encode(buf, 0, c);\nreadLen = base64.readResults(b, offset, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "private static final byte[] URL_SAFE_ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbyte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\nSystem.arraycopy(buffer, 0, b, 0, buffer.length);\nbuffer = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testCodec112",
                            "test_body": "340: public void testCodec112() { // size calculation assumes always chunked\n341: byte[] in = new byte[] {0};\n342: byte[] out=Base64.encodeBase64(in);\n343: Base64.encodeBase64(in, false, false, out.length);\n344: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4;\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "private static final byte[] STANDARD_ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nswitch (modulus) {\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\nbyte b = lineSeparator[lineSeparator.length - 1];\nif (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nx = (x << 8) + b;\nif (0 == modulus) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([B)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData) {\nreturn encodeBase64(binaryData, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nthrow new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nbyte[] buf = new byte[pos - readPos];\nreadResults(buf, 0, buf.length);\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\nchunkSize = (chunkSize / 4) * 4;\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.CaverphoneTest.testEndMb",
                            "test_body": "333: public void testEndMb() throws EncoderException {\n334: String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n335: this.checkEncodings(data);\n336: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:<init>()V",
                                    "method_body": "public Caverphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:caverphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String caverphone(String txt) {\nif( txt == null || txt.length() == 0 ) {\ntxt = txt.toLowerCase(java.util.Locale.ENGLISH);\ntxt = txt.replaceAll(\"[^a-z]\", \"\");\ntxt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\ntxt = txt.replaceAll(\"^cough\", \"cou2f\");\ntxt = txt.replaceAll(\"^rough\", \"rou2f\");\ntxt = txt.replaceAll(\"^tough\", \"tou2f\");\ntxt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\ntxt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\ntxt = txt.replaceAll(\"^gn\", \"2n\");\ntxt = txt.replaceAll(\"^mb\", \"m2\");\ntxt = txt.replaceAll(\"cq\", \"2q\");\ntxt = txt.replaceAll(\"ci\", \"si\");\ntxt = txt.replaceAll(\"ce\", \"se\");\ntxt = txt.replaceAll(\"cy\", \"sy\");\ntxt = txt.replaceAll(\"tch\", \"2ch\");\ntxt = txt.replaceAll(\"c\", \"k\");\ntxt = txt.replaceAll(\"q\", \"k\");\ntxt = txt.replaceAll(\"x\", \"k\");\ntxt = txt.replaceAll(\"v\", \"f\");\ntxt = txt.replaceAll(\"dg\", \"2g\");\ntxt = txt.replaceAll(\"tio\", \"sio\");\ntxt = txt.replaceAll(\"tia\", \"sia\");\ntxt = txt.replaceAll(\"d\", \"t\");\ntxt = txt.replaceAll(\"ph\", \"fh\");\ntxt = txt.replaceAll(\"b\", \"p\");\ntxt = txt.replaceAll(\"sh\", \"s2\");\ntxt = txt.replaceAll(\"z\", \"s\");\ntxt = txt.replaceAll(\"^[aeiou]\", \"A\");\ntxt = txt.replaceAll(\"[aeiou]\", \"3\");\ntxt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\ntxt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\ntxt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\ntxt = txt.replaceAll(\"3gh3\", \"3kh3\");\ntxt = txt.replaceAll(\"gh\", \"22\");\ntxt = txt.replaceAll(\"g\", \"k\");\ntxt = txt.replaceAll(\"s+\", \"S\");\ntxt = txt.replaceAll(\"t+\", \"T\");\ntxt = txt.replaceAll(\"p+\", \"P\");\ntxt = txt.replaceAll(\"k+\", \"K\");\ntxt = txt.replaceAll(\"f+\", \"F\");\ntxt = txt.replaceAll(\"m+\", \"M\");\ntxt = txt.replaceAll(\"n+\", \"N\");\ntxt = txt.replaceAll(\"w3\", \"W3\");\ntxt = txt.replaceAll(\"wh3\", \"Wh3\");\ntxt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"w\", \"2\");\ntxt = txt.replaceAll(\"^h\", \"A\");\ntxt = txt.replaceAll(\"h\", \"2\");\ntxt = txt.replaceAll(\"r3\", \"R3\");\ntxt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"r\", \"2\");\ntxt = txt.replaceAll(\"l3\", \"L3\");\ntxt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\ntxt = txt.replaceAll(\"l\", \"2\");\ntxt = txt.replaceAll(\"2\", \"\");\ntxt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"3\", \"\");\ntxt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\nreturn txt.substring(0, 10);          // 1.0 truncates to 6\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn caverphone(pString);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSkipNotEncodedCRLF",
                            "test_body": "295: public void testSkipNotEncodedCRLF() throws Exception {\n296: String qpdata = \"CRLF in an\\n encoded text should be=20=\\r\\n\\rskipped in the\\r decoding.\";\n297: String expected = \"CRLF in an encoded text should be skipped in the decoding.\";\n298: 299: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n300: assertEquals(expected, qpcodec.decode(qpdata));\n301: 302: String encoded = qpcodec.encode(expected);\n303: assertEquals(expected, qpcodec.decode(encoded));\n304: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUsAscii(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.DecoderException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public DecoderException(String message) {\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.Utils:digit16(B)I",
                                    "method_body": "static int digit16(byte b) throws DecoderException {\nint i = Character.digit((char) b, 16);\nif (i == -1) {\nthrow new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decodeQuotedPrintable([B)[B",
                                    "method_body": "public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\nif (bytes == null) {\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (int i = 0; i < bytes.length; i++) {\nfinal int b = bytes[i];\nif (b == ESCAPE_CHAR) {\nint u = Utils.digit16(bytes[++i]);\nint l = Utils.digit16(bytes[++i]);\nbuffer.write((char) ((u << 4) + l));\n}\nbuffer.write(b);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode([B)[B",
                                    "method_body": "public byte[] decode(byte[] bytes) throws DecoderException {\nreturn decodeQuotedPrintable(bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\nif (pString == null) {\nreturn new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString) throws DecoderException {\nif (pString == null) {\nreturn decode(pString, getDefaultCharset());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSoftLineBreakDecode",
                            "test_body": "267: public void testSoftLineBreakDecode() throws Exception {\n268: String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics \" +\n269: \"is the most beautiful branch of philosophy.\";\n270: String expected = \"If you believe that truth=beauty, then surely mathematics \" +\n271: \"is the most beautiful branch of philosophy.\";\n272: 273: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n274: assertEquals(expected, qpcodec.decode(qpdata));\n275: 276: String encoded = qpcodec.encode(expected);\n277: assertEquals(expected, qpcodec.decode(encoded));\n278: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUsAscii(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn string.getBytes(charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.DecoderException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public DecoderException(String message) {\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.Utils:digit16(B)I",
                                    "method_body": "static int digit16(byte b) throws DecoderException {\nint i = Character.digit((char) b, 16);\nif (i == -1) {\nthrow new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decodeQuotedPrintable([B)[B",
                                    "method_body": "public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\nif (bytes == null) {\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (int i = 0; i < bytes.length; i++) {\nfinal int b = bytes[i];\nif (b == ESCAPE_CHAR) {\nint u = Utils.digit16(bytes[++i]);\nint l = Utils.digit16(bytes[++i]);\nbuffer.write((char) ((u << 4) + l));\n}\nbuffer.write(b);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode([B)[B",
                                    "method_body": "public byte[] decode(byte[] bytes) throws DecoderException {\nreturn decodeQuotedPrintable(bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\nif (pString == null) {\nreturn new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString) throws DecoderException {\nif (pString == null) {\nreturn decode(pString, getDefaultCharset());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testUltimateSoftBreak",
                            "test_body": "320: public void testUltimateSoftBreak() throws Exception {\n321: final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n322: 323: String plain =\"This is a example of a quoted-printable text file. There is no end to it\\t\";\n324: String expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=09\";\n325: 326: assertEquals(expected, qpcodec.encode(plain));\n327: 328: plain =\"This is a example of a quoted-printable text file. There is no end to it \";\n329: expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=20\";\n330: 331: assertEquals(expected, qpcodec.encode(plain));\n332: 333: // whitespace before soft break\n334: plain =\"This is a example of a quoted-printable text file. There is no end to   \";\n335: expected = \"This is a example of a quoted-printable text file. There is no end to=20=\\r\\n =20\";\n336: 337: assertEquals(expected, qpcodec.encode(plain));\n338: 339: // non-printable character before soft break\n340: plain =\"This is a example of a quoted-printable text file. There is no end to=  \";\n341: expected = \"This is a example of a quoted-printable text file. There is no end to=3D=\\r\\n =20\";\n342: 343: assertEquals(expected, qpcodec.encode(plain));\n344: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn new String(bytes, charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nif (printable == null) {\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nif (printable.get(b)) {\nbuffer.write(b);\nencodeQuotedPrintable(b, buffer);\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn encode(pString, getDefaultCharset());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSoftLineBreakEncode",
                            "test_body": "281: public void testSoftLineBreakEncode() throws Exception {\n282: String qpdata = \"If you believe that truth=3Dbeauty, then surely mathematics is the most \" +\n283: \"b=\\r\\neautiful branch of philosophy.\";\n284: String expected = \"If you believe that truth=beauty, then surely mathematics is the most \" +\n285: \"beautiful branch of philosophy.\";\n286: 287: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n288: assertEquals(qpdata, qpcodec.encode(expected));\n289: 290: String decoded = qpcodec.decode(qpdata);\n291: assertEquals(qpdata, qpcodec.encode(decoded));\n292: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn new String(bytes, charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(ILjava/io/ByteArrayOutputStream;)V",
                                    "method_body": "private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\nbuffer.write(ESCAPE_CHAR);\nchar hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\nchar hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\nbuffer.write(hex1);\nbuffer.write(hex2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nif (printable == null) {\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nif (printable.get(b)) {\nbuffer.write(b);\nencodeQuotedPrintable(b, buffer);\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn encode(pString, getDefaultCharset());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testTrailingSpecial",
                            "test_body": "307: public void testTrailingSpecial() throws Exception {\n308: final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n309: 310: String plain =\"This is a example of a quoted-printable text file. This might contain sp=cial chars.\";\n311: String expected = \"This is a example of a quoted-printable text file. This might contain sp=3D=\\r\\ncial chars.\";\n312: assertEquals(expected, qpcodec.encode(plain));\n313: 314: plain =\"This is a example of a quoted-printable text file. This might contain ta\\tbs as well.\";\n315: expected = \"This is a example of a quoted-printable text file. This might contain ta=09=\\r\\nbs as well.\";\n316: assertEquals(expected, qpcodec.encode(plain));\n317: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn new String(bytes, charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(ILjava/io/ByteArrayOutputStream;)V",
                                    "method_body": "private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\nbuffer.write(ESCAPE_CHAR);\nchar hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\nchar hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\nbuffer.write(hex1);\nbuffer.write(hex2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nif (printable == null) {\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nif (printable.get(b)) {\nbuffer.write(b);\nencodeQuotedPrintable(b, buffer);\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn encode(pString, getDefaultCharset());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testIsDoubleMetaphoneEqualBasic",
                            "test_body": "1123: public void testIsDoubleMetaphoneEqualBasic() {\n1124: final String[][] testFixture = new String[][] { { \n1125: \"\", \"\" }, {\n1126: \"Case\", \"case\" }, {\n1127: \"CASE\", \"Case\" }, {\n1128: \"caSe\", \"cAsE\" }, {\n1129: \"cookie\", \"quick\" }, {\n1130: \"quick\", \"cookie\" }, {\n1131: \"Brian\", \"Bryan\" }, {\n1132: \"Auto\", \"Otto\" }, {\n1133: \"Steven\", \"Stefan\" }, {\n1134: \"Philipowitz\", \"Filipowicz\" }\n1135: };\n1136: doubleMetaphoneEqualTest(testFixture, false);\n1137: doubleMetaphoneEqualTest(testFixture, true);\n1138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "private int maxCodeLen = 4;\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\n{ \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, final boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isDoubleMetaphoneEqual(Ljava/lang/String;Ljava/lang/String;Z)Z",
                                    "method_body": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\nreturn doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\ninput = input.trim();\nif (input.length() == 0) {\nreturn null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testCodec184",
                            "test_body": "1064: public void testCodec184() throws Throwable {\n1065: assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", false));\n1066: assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", true));\n1067: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", false));\n1068: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", true));\n1069: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", false));\n1070: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", true));\n1071: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "private int maxCodeLen = 4;\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\n{ \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, final boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isDoubleMetaphoneEqual(Ljava/lang/String;Ljava/lang/String;Z)Z",
                                    "method_body": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\nreturn doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\ninput = input.trim();\nif (input.length() == 0) {\nreturn null;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.testCompatibilityWithOriginalVersion",
                            "test_body": "181: public void testCompatibilityWithOriginalVersion() {\n182: // see CODEC-187\n183: // comparison: http://stevemorse.org/census/soundex.html\n184: 185: Map<String, String> args = new TreeMap<String, String>();\n186: args.put(\"nameType\", \"GENERIC\");\n187: args.put(\"ruleType\", \"APPROX\");\n188: 189: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\");\n190: assertEquals(encode(args, true, \"Bendzin\"), \"bndzn|bntsn|bnzn|vndzn|vntsn\");\n191: 192: args.put(\"nameType\", \"ASHKENAZI\");\n193: args.put(\"ruleType\", \"APPROX\");\n194: 195: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom\");\n196: assertEquals(encode(args, true, \"Halpern\"), \"YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn\");\n197: 198: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.NameType:<init>(Ljava/lang/String;ILjava/lang/String;)V",
                                    "method_body": "NameType(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.NameType:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.RuleType:<init>(Ljava/lang/String;ILjava/lang/String;)V",
                                    "method_body": "RuleType(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.RuleType:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<init>(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Z)V",
                                    "method_body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\nthis(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<init>(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;ZI)V",
                                    "method_body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\nfinal int maxPhonemes) {\nif (ruleType == RuleType.RULES) {\nthis.nameType = nameType;\nthis.ruleType = ruleType;\nthis.concat = concat;\nthis.lang = Lang.instance(nameType);\nthis.maxPhonemes = maxPhonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<clinit>()V",
                                    "method_body": "private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\nNAME_PREFIXES.put(NameType.ASHKENAZI,\nNAME_PREFIXES.put(NameType.SEPHARDIC,\nNAME_PREFIXES.put(NameType.GENERIC,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:join(Ljava/lang/Iterable;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String join(final Iterable<String> strings, final String sep) {\nfinal StringBuilder sb = new StringBuilder();\nfinal Iterator<String> si = strings.iterator();\nif (si.hasNext()) {\nsb.append(si.next());\nwhile (si.hasNext()) {\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:applyFinalRules(Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;Ljava/util/Map;)Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\nif (finalRules == null) {\nif (finalRules.isEmpty()) {\nfinal Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\nfor (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\nPhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\nfinal String phonemeText = phoneme.getPhonemeText().toString();\nfor (int i = 0; i < phonemeText.length();) {\nfinal RulesApplication rulesApplication =\nfinal boolean found = rulesApplication.isFound();\nsubBuilder = rulesApplication.getPhonemeBuilder();\nif (!found) {\nsubBuilder.append(phonemeText.subSequence(i, i + 1));\ni = rulesApplication.getI();\n}\nphonemes.addAll(subBuilder.getPhonemes());\n}\nreturn new PhonemeBuilder(phonemes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(final String input) {\nfinal Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\nreturn encode(input, languageSet);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:encode(Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Ljava/lang/String;",
                                    "method_body": "public String encode(String input, final Languages.LanguageSet languageSet) {\nfinal Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\nfinal Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\nfinal Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\ninput = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\nif (this.nameType == NameType.GENERIC) {\nif (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\nfor (final String l : NAME_PREFIXES.get(this.nameType)) {\nif (input.startsWith(l + \" \")) {\n}\nfinal List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\nfinal List<String> words2 = new ArrayList<String>();\nswitch (this.nameType) {\nwords2.addAll(words);\nbreak;\nif (this.concat) {\ninput = join(words2, \" \");\nPhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\nfor (int i = 0; i < input.length();) {\nfinal RulesApplication rulesApplication =\ni = rulesApplication.getI();\nphonemeBuilder = rulesApplication.getPhonemeBuilder();\n}\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\nreturn phonemeBuilder.makeString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:<init>(Ljava/util/List;Lorg/apache/commons/codec/language/bm/Languages;)V",
                                    "method_body": "private Lang(final List<LangRule> rules, final Languages languages) {\nthis.rules = Collections.unmodifiableList(rules);\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:<clinit>()V",
                                    "method_body": "private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\nfor (final NameType s : NameType.values()) {\nLangs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:instance(Lorg/apache/commons/codec/language/bm/NameType;)Lorg/apache/commons/codec/language/bm/Lang;",
                                    "method_body": "public static Lang instance(final NameType nameType) {\nreturn Langs.get(nameType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:loadFromResource(Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Languages;)Lorg/apache/commons/codec/language/bm/Lang;",
                                    "method_body": "public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\nfinal List<LangRule> rules = new ArrayList<LangRule>();\nfinal InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\nif (lRulesIS == null) {\nfinal Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\nboolean inExtendedComment = false;\nwhile (scanner.hasNextLine()) {\nscanner.close();\n}\nreturn new Lang(rules, languages);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:guessLanguages(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public Languages.LanguageSet guessLanguages(final String input) {\nfinal String text = input.toLowerCase(Locale.ENGLISH);\nfinal Set<String> langs = new HashSet<String>(this.languages.getLanguages());\nfor (final LangRule rule : this.rules) {\nfinal Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\nreturn ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:<init>(Ljava/util/Set;)V",
                                    "method_body": "private Languages(final Set<String> languages) {\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:<clinit>()V",
                                    "method_body": "public static final String ANY = \"any\";\nprivate static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\nfor (final NameType s : NameType.values()) {\nLANGUAGES.put(s, getInstance(langResourceName(s)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getInstance(Lorg/apache/commons/codec/language/bm/NameType;)Lorg/apache/commons/codec/language/bm/Languages;",
                                    "method_body": "public static Languages getInstance(final NameType nameType) {\nreturn LANGUAGES.get(nameType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getInstance(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Languages;",
                                    "method_body": "public static Languages getInstance(final String languagesResourceName) {\nfinal Set<String> ls = new HashSet<String>();\nfinal InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\nif (langIS == null) {\nfinal Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\nboolean inExtendedComment = false;\nwhile (lsScanner.hasNextLine()) {\nfinal String line = lsScanner.nextLine().trim();\nif (inExtendedComment) {\nif (line.endsWith(ResourceConstants.EXT_CMT_END)) {\ninExtendedComment = false;\nif (line.startsWith(ResourceConstants.EXT_CMT_START)) {\ninExtendedComment = true;\n} else if (line.length() > 0) {\nls.add(line);\n}\nlsScanner.close();\n}\nreturn new Languages(Collections.unmodifiableSet(ls));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:langResourceName(Lorg/apache/commons/codec/language/bm/NameType;)Ljava/lang/String;",
                                    "method_body": "private static String langResourceName(final NameType nameType) {\nreturn String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getLanguages()Ljava/util/Set;",
                                    "method_body": "public Set<String> getLanguages() {\nreturn this.languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$LanguageSet:from(Ljava/util/Set;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public static LanguageSet from(final Set<String> langs) {\nreturn langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$1:isEmpty()Z",
                                    "method_body": "public boolean isEmpty() {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:<init>(Ljava/util/Set;)V",
                                    "method_body": "public abstract boolean contains(String language);\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\nreturn this.languages.isEmpty();\nreturn this.languages.size() == 1;\nif (other == NO_LANGUAGES) {\n} else if (other == ANY_LANGUAGE) {\nreturn this;\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\nreturn from(ls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:isEmpty()Z",
                                    "method_body": "public abstract boolean contains(String language);\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\nreturn this.languages.isEmpty();\nreturn this.languages.size() == 1;\nif (other == NO_LANGUAGES) {\n} else if (other == ANY_LANGUAGE) {\nreturn this;\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\nreturn from(ls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:isSingleton()Z",
                                    "method_body": "public abstract boolean contains(String language);\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\nreturn this.languages.isEmpty();\nreturn this.languages.size() == 1;\nif (other == NO_LANGUAGES) {\n} else if (other == ANY_LANGUAGE) {\nreturn this;\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\nreturn from(ls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:restrictTo(Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public abstract boolean contains(String language);\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\nreturn this.languages.isEmpty();\nreturn this.languages.size() == 1;\nif (other == NO_LANGUAGES) {\n} else if (other == ANY_LANGUAGE) {\nreturn this;\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\nreturn from(ls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;)V",
                                    "method_body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\nthis.pattern = pattern;\nthis.lContext = pattern(lContext + \"$\");\nthis.rContext = pattern(\"^\" + rContext);\nthis.phoneme = phoneme;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:<clinit>()V",
                                    "method_body": "public static final String ALL = \"ALL\";\nprivate static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\nfor (final NameType s : NameType.values()) {\nfinal Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\nfor (final RuleType rt : RuleType.values()) {\nfinal Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\nfinal Languages ls = Languages.getInstance(s);\nfor (final String l : ls.getLanguages()) {\nrs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));\n}\n}\nif (!rt.equals(RuleType.RULES)) {\nrs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\")));\nrts.put(rt, Collections.unmodifiableMap(rs));\nRULES.put(s, Collections.unmodifiableMap(rts));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:contains(Ljava/lang/CharSequence;C)Z",
                                    "method_body": "private static boolean contains(final CharSequence chars, final char input) {\nfor (int i = 0; i < chars.length(); i++) {\nif (chars.charAt(i) == input) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createResourceName(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\nreturn String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createScanner(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/util/Scanner;",
                                    "method_body": "private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\nfinal String resName = createResourceName(nameType, rt, lang);\nfinal InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\nif (rulesIS == null) {\nreturn new Scanner(rulesIS, ResourceConstants.ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createScanner(Ljava/lang/String;)Ljava/util/Scanner;",
                                    "method_body": "private static Scanner createScanner(final String lang) {\nfinal String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\nfinal InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\nif (rulesIS == null) {\nreturn new Scanner(rulesIS, ResourceConstants.ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getInstanceMap(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Ljava/util/Map;",
                                    "method_body": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\nreturn langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getInstanceMap(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/util/Map;",
                                    "method_body": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\nfinal Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\nif (rules == null) {\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parsePhoneme(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$Phoneme;",
                                    "method_body": "private static Phoneme parsePhoneme(final String ph) {\nfinal int open = ph.indexOf(\"[\");\nif (open >= 0) {\nif (!ph.endsWith(\"]\")) {\nfinal String before = ph.substring(0, open);\nfinal String in = ph.substring(open + 1, ph.length() - 1);\nfinal Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\nreturn new Phoneme(before, Languages.LanguageSet.from(langs));\nreturn new Phoneme(ph, Languages.ANY_LANGUAGE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parsePhonemeExpr(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;",
                                    "method_body": "private static PhonemeExpr parsePhonemeExpr(final String ph) {\nif (ph.startsWith(\"(\")) { // we have a bracketed list of options\nif (!ph.endsWith(\")\")) {\nfinal List<Phoneme> phs = new ArrayList<Phoneme>();\nfinal String body = ph.substring(1, ph.length() - 1);\nfor (final String part : body.split(\"[|]\")) {\nphs.add(parsePhoneme(part));\nif (body.startsWith(\"|\") || body.endsWith(\"|\")) {\nphs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\nreturn new PhonemeList(phs);\nreturn parsePhoneme(ph);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parseRules(Ljava/util/Scanner;Ljava/lang/String;)Ljava/util/Map;",
                                    "method_body": "private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\nfinal Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\nint currentLine = 0;\nboolean inMultilineComment = false;\nwhile (scanner.hasNextLine()) {\ncurrentLine++;\nfinal String rawLine = scanner.nextLine();\nString line = rawLine;\nif (inMultilineComment) {\nif (line.endsWith(ResourceConstants.EXT_CMT_END)) {\ninMultilineComment = false;\nif (line.startsWith(ResourceConstants.EXT_CMT_START)) {\ninMultilineComment = true;\nfinal int cmtI = line.indexOf(ResourceConstants.CMT);\nif (cmtI >= 0) {\nline = line.substring(0, cmtI);\nline = line.trim();\nif (line.length() == 0) {\ncontinue; // empty lines can be safely skipped\nif (line.startsWith(HASH_INCLUDE)) {\nfinal String incl = line.substring(HASH_INCLUDE.length()).trim();\nif (incl.contains(\" \")) {\nlines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n} else {\nfinal String[] parts = line.split(\"\\\\s+\");\nif (parts.length != 4) {\nfinal String pat = stripQuotes(parts[0]);\nfinal String lCon = stripQuotes(parts[1]);\nfinal String rCon = stripQuotes(parts[2]);\nfinal PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\nfinal int cLine = currentLine;\nfinal Rule r = new Rule(pat, lCon, rCon, ph) {\nfinal String patternKey = r.pattern.substring(0,1);\nList<Rule> rules = lines.get(patternKey);\nif (rules == null) {\nrules = new ArrayList<Rule>();\nlines.put(patternKey, rules);\nrules.add(r);\n}\n}\nreturn lines;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:pattern(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$RPattern;",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:startsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\nif (prefix.length() > input.length()) {\nreturn false;\nfor (int i = 0; i < prefix.length(); i++) {\nif (input.charAt(i) != prefix.charAt(i)) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:stripQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String stripQuotes(String str) {\nif (str.startsWith(DOUBLE_QUOTE)) {\nstr = str.substring(1);\nif (str.endsWith(DOUBLE_QUOTE)) {\nstr = str.substring(0, str.length() - 1);\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getPattern()Ljava/lang/String;",
                                    "method_body": "public String getPattern() {\nreturn this.pattern;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getPhoneme()Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;",
                                    "method_body": "public PhonemeExpr getPhoneme() {\nreturn this.phoneme;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:patternAndContextMatches(Ljava/lang/CharSequence;I)Z",
                                    "method_body": "public boolean patternAndContextMatches(final CharSequence input, final int i) {\nif (i < 0) {\nfinal int patternLength = this.pattern.length();\nfinal int ipl = i + patternLength;\nif (ipl > input.length()) {\nreturn false;\nif (!input.subSequence(i, ipl).equals(this.pattern)) {\nreturn false;\n} else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\nreturn false;\nreturn this.lContext.isMatch(input.subSequence(0, i));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$1:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "boolean isMatch(CharSequence input);\npublic static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\nreturn true;\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<init>(Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)V",
                                    "method_body": "public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\nthis.phonemeText = new StringBuilder(phonemeText);\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<init>(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)V",
                                    "method_body": "public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\nthis(phonemeLeft.phonemeText, languages);\nthis.phonemeText.append(phonemeRight.phonemeText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<clinit>()V",
                                    "method_body": "public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\nfor (int i = 0; i < o1.phonemeText.length(); i++) {\nif (i >= o2.phonemeText.length()) {\nfinal int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\nif (c != 0) {\nreturn c;\nif (o1.phonemeText.length() < o2.phonemeText.length()) {\nreturn 0;\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:append(Ljava/lang/CharSequence;)Lorg/apache/commons/codec/language/bm/Rule$Phoneme;",
                                    "method_body": "public Phoneme append(final CharSequence str) {\nthis.phonemeText.append(str);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getLanguages()Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public Languages.LanguageSet getLanguages() {\nreturn this.languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getPhonemes()Ljava/lang/Iterable;",
                                    "method_body": "public Iterable<Phoneme> getPhonemes() {\nreturn Collections.singleton(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getPhonemeText()Ljava/lang/CharSequence;",
                                    "method_body": "public CharSequence getPhonemeText() {\nreturn this.phonemeText;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme$1:compare(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Rule$Phoneme;)I",
                                    "method_body": "public int compare(final Phoneme o1, final Phoneme o2) {\nfor (int i = 0; i < o1.phonemeText.length(); i++) {\nif (i >= o2.phonemeText.length()) {\nfinal int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\nif (c != 0) {\nreturn c;\nif (o1.phonemeText.length() < o2.phonemeText.length()) {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$3:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$9:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$7:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$PhonemeList:<init>(Ljava/util/List;)V",
                                    "method_body": "Iterable<Phoneme> getPhonemes();\npublic PhonemeList(final List<Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}\nreturn this.phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$PhonemeList:getPhonemes()Ljava/util/List;",
                                    "method_body": "Iterable<Phoneme> getPhonemes();\npublic PhonemeList(final List<Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}\nreturn this.phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$4:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$8:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$10:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$5:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$1:<clinit>()V",
                                    "method_body": "public String encode(String input, final Languages.LanguageSet languageSet) {\nfinal Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\nfinal Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\nfinal Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\ninput = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\nif (this.nameType == NameType.GENERIC) {\nif (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\nfor (final String l : NAME_PREFIXES.get(this.nameType)) {\nif (input.startsWith(l + \" \")) {\n}\nfinal List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\nfinal List<String> words2 = new ArrayList<String>();\nswitch (this.nameType) {\nwords2.addAll(words);\nbreak;\nif (this.concat) {\ninput = join(words2, \" \");\nPhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\nfor (int i = 0; i < input.length();) {\nfinal RulesApplication rulesApplication =\ni = rulesApplication.getI();\nphonemeBuilder = rulesApplication.getPhonemeBuilder();\n}\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\nreturn phonemeBuilder.makeString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:<init>(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;)V",
                                    "method_body": "private PhonemeBuilder(final Rule.Phoneme phoneme) {\nthis.phonemes = new LinkedHashSet<Rule.Phoneme>();\nthis.phonemes.add(phoneme);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:<init>(Ljava/util/Set;)V",
                                    "method_body": "private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:empty(Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\nreturn new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:append(Ljava/lang/CharSequence;)V",
                                    "method_body": "public void append(final CharSequence str) {\nfor (final Rule.Phoneme ph : this.phonemes) {\nph.append(str);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:apply(Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;I)V",
                                    "method_body": "public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\nfinal Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\nEXPR: for (final Rule.Phoneme left : this.phonemes) {\nfor (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\nfinal LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\nif (!languages.isEmpty()) {\nfinal Rule.Phoneme join = new Phoneme(left, right, languages);\nif (newPhonemes.size() < maxPhonemes) {\nnewPhonemes.add(join);\nif (newPhonemes.size() >= maxPhonemes) {\n}\n}\nthis.phonemes.clear();\nthis.phonemes.addAll(newPhonemes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:getPhonemes()Ljava/util/Set;",
                                    "method_body": "public Set<Rule.Phoneme> getPhonemes() {\nreturn this.phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:makeString()Ljava/lang/String;",
                                    "method_body": "public String makeString() {\nfinal StringBuilder sb = new StringBuilder();\nfor (final Rule.Phoneme ph : this.phonemes) {\nif (sb.length() > 0) {\nsb.append(\"|\");\nsb.append(ph.getPhonemeText());\n}\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:<init>(Ljava/util/Map;Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;II)V",
                                    "method_body": "public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\nfinal PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\nif (finalRules == null) {\nthis.finalRules = finalRules;\nthis.phonemeBuilder = phonemeBuilder;\nthis.input = input;\nthis.i = i;\nthis.maxPhonemes = maxPhonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:getI()I",
                                    "method_body": "public int getI() {\nreturn this.i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:getPhonemeBuilder()Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "public PhonemeBuilder getPhonemeBuilder() {\nreturn this.phonemeBuilder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:invoke()Lorg/apache/commons/codec/language/bm/PhoneticEngine$RulesApplication;",
                                    "method_body": "public RulesApplication invoke() {\nthis.found = false;\nint patternLength = 1;\nfinal List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\nif (rules != null) {\nfor (final Rule rule : rules) {\nfinal String pattern = rule.getPattern();\npatternLength = pattern.length();\nif (rule.patternAndContextMatches(this.input, this.i)) {\nthis.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\nthis.found = true;\nbreak;\n}\nif (!this.found) {\npatternLength = 1;\nthis.i += patternLength;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:isFound()Z",
                                    "method_body": "public boolean isFound() {\nreturn this.found;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.SoundexTest.testHWRuleEx1",
                            "test_body": "224: public void testHWRuleEx1() {\n225: // From\n226: // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n227: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n228: // for the F). It is not coded A-226.\n229: Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcraft\"));\n230: Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcroft\"));\n231: Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yehudit\"));\n232: Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\"));\n233: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>()V",
                                    "method_body": "public Soundex() {\nthis.soundexMapping = US_ENGLISH_MAPPING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>(Ljava/lang/String;)V",
                                    "method_body": "public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\nprivate static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\npublic static final Soundex US_ENGLISH = new Soundex();\n@Deprecated\npublic Soundex() {\nthis.soundexMapping = US_ENGLISH_MAPPING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<clinit>()V",
                                    "method_body": "public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\nprivate static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\npublic static final Soundex US_ENGLISH = new Soundex();\n@Deprecated\npublic Soundex() {\nthis.soundexMapping = US_ENGLISH_MAPPING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(final String str) {\nreturn soundex(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getMappingCode(Ljava/lang/String;I)C",
                                    "method_body": "private char getMappingCode(final String str, final int index) {\nfinal char mappedChar = this.map(str.charAt(index));\nif (index > 1 && mappedChar != '0') {\nfinal char hwChar = str.charAt(index - 1);\nif ('H' == hwChar || 'W' == hwChar) {\nfinal char preHWChar = str.charAt(index - 2);\nfinal char firstCode = this.map(preHWChar);\nif (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\nreturn 0;\nreturn mappedChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getSoundexMapping()[C",
                                    "method_body": "private char[] getSoundexMapping() {\nreturn this.soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:map(C)C",
                                    "method_body": "private char map(final char ch) {\nfinal int index = ch - 'A';\nif (index < 0 || index >= this.getSoundexMapping().length) {\nreturn this.getSoundexMapping()[index];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nfinal char out[] = {'0', '0', '0', '0'};\nint incount = 1, count = 1;\nout[0] = str.charAt(0);\nlast = getMappingCode(str, 0);\nwhile (incount < str.length() && count < out.length) {\nmapped = getMappingCode(str, incount++);\nif (mapped != 0) {\nif (mapped != '0' && mapped != last) {\nout[count++] = mapped;\nlast = mapped;\nreturn new String(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(final String str) {\nif (str == null || str.length() == 0) {\nfinal int len = str.length();\nfinal char[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\nif (count == len) {\nreturn str.toUpperCase(java.util.Locale.ENGLISH);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base32Test.testCodec200",
                            "test_body": "157: public void testCodec200() {\n158: final Base32 codec = new Base32(true, (byte)'W'); // should be allowed\n159: assertNotNull(codec);\n160: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.BaseNCodec:<init>(IIIIB)V",
                                    "method_body": "protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\nfinal int lineLength, final int chunkSeparatorLength, final byte pad) {\nthis.unencodedBlockSize = unencodedBlockSize;\nthis.encodedBlockSize = encodedBlockSize;\nfinal boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\nthis.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\nthis.chunkSeparatorLength = chunkSeparatorLength;\nthis.pad = pad;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<init>(ZB)V",
                                    "method_body": "public Base32(final boolean useHex, final byte pad) {\nthis(0, null, useHex, pad);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<init>(I[BZB)V",
                                    "method_body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\nsuper(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\nif (useHex) {\nthis.encodeTable = HEX_ENCODE_TABLE;\nthis.decodeTable = HEX_DECODE_TABLE;\nif (lineLength > 0) {\nthis.encodeSize = BYTES_PER_ENCODED_BLOCK;\nthis.lineSeparator = null;\nthis.decodeSize = this.encodeSize - 1;\nif (isInAlphabet(pad) || isWhiteSpace(pad)) {\nthrow new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<clinit>()V",
                                    "method_body": "private static final byte[] ENCODE_TABLE = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:isInAlphabet(B)Z",
                                    "method_body": "public boolean isInAlphabet(final byte octet) {\nreturn octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testNewStringNullInput_CODEC229",
                            "test_body": "149: public void testNewStringNullInput_CODEC229() {\n150: Assert.assertNull(StringUtils.newStringUtf8(null));\n151: Assert.assertNull(StringUtils.newStringIso8859_1(null));\n152: Assert.assertNull(StringUtils.newStringUsAscii(null));\n153: Assert.assertNull(StringUtils.newStringUtf16(null));\n154: Assert.assertNull(StringUtils.newStringUtf16Be(null));\n155: Assert.assertNull(StringUtils.newStringUtf16Le(null));\n156: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset US_ASCII = Charset.forName(CharEncoding.US_ASCII);\n* On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead."
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/nio/charset/Charset;)Ljava/lang/String;",
                                    "method_body": "private static String newString(final byte[] bytes, final Charset charset) {\nreturn bytes == null ? null : new String(bytes, charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringIso8859_1([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringIso8859_1(final byte[] bytes) {\nreturn new String(bytes, Charsets.ISO_8859_1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(final byte[] bytes) {\nreturn newString(bytes, Charsets.UTF_8);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testEqualsCS1",
                            "test_body": "224: public void testEqualsCS1() {\n225: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), null));\n226: Assert.assertFalse(StringUtils.equals(null, new StringBuilder(\"abc\")));\n227: Assert.assertTrue(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\")));\n228: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\")));\n229: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abcd\"), new StringBuilder(\"abc\")));\n230: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"ABC\")));\n231: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:equals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\nif (cs1 == cs2) {\nif (cs1 == null || cs2 == null) {\nreturn false;\nif (cs1 instanceof String && cs2 instanceof String) {\nreturn CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.CharSequenceUtils:regionMatches(Ljava/lang/CharSequence;ZILjava/lang/CharSequence;II)Z",
                                    "method_body": "static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\nif (cs instanceof String && substring instanceof String) {\nint index1 = thisStart;\nint index2 = start;\nint tmpLen = length;\nwhile (tmpLen-- > 0) {\nfinal char c1 = cs.charAt(index1++);\nfinal char c2 = substring.charAt(index2++);\nif (c1 == c2) {\ncontinue;\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testEqualsCS2",
                            "test_body": "234: public void testEqualsCS2() {\n235: Assert.assertTrue(StringUtils.equals(\"abc\", new StringBuilder(\"abc\")));\n236: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"abcd\"));\n237: Assert.assertFalse(StringUtils.equals(\"abcd\", new StringBuilder(\"abc\")));\n238: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"ABC\"));\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:equals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\nif (cs1 == cs2) {\nif (cs1 == null || cs2 == null) {\nreturn false;\nif (cs1 instanceof String && cs2 instanceof String) {\nreturn CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.CharSequenceUtils:regionMatches(Ljava/lang/CharSequence;ZILjava/lang/CharSequence;II)Z",
                                    "method_body": "static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\nif (cs instanceof String && substring instanceof String) {\nint index1 = thisStart;\nint index2 = start;\nint tmpLen = length;\nwhile (tmpLen-- > 0) {\nfinal char c1 = cs.charAt(index1++);\nfinal char c2 = substring.charAt(index2++);\nif (c1 == c2) {\ncontinue;\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}