{
    "bug_id": 56,
    "test_id": 0,
    "test_name": "org.apache.commons.math.util.MultidimensionalCounterTest.testIterationConsistency",
    "test_body": "123: public void testIterationConsistency() {\n124: final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);\n125: final int[][] expected = new int[][] {\n126: { 0, 0, 0 },\n127: { 0, 0, 1 },\n128: { 0, 0, 2 },\n129: { 0, 0, 3 },\n130: { 0, 1, 0 },\n131: { 0, 1, 1 },\n132: { 0, 1, 2 },\n133: { 0, 1, 3 },\n134: { 0, 2, 0 },\n135: { 0, 2, 1 },\n136: { 0, 2, 2 },\n137: { 0, 2, 3 },\n138: { 1, 0, 0 },\n139: { 1, 0, 1 },\n140: { 1, 0, 2 },\n141: { 1, 0, 3 },\n142: { 1, 1, 0 },\n143: { 1, 1, 1 },\n144: { 1, 1, 2 },\n145: { 1, 1, 3 },\n146: { 1, 2, 0 },\n147: { 1, 2, 1 },\n148: { 1, 2, 2 },\n149: { 1, 2, 3 }\n150: };\n151: 152: final int totalSize = c.getSize();\n153: final int nDim = c.getDimension();\n154: final MultidimensionalCounter.Iterator iter = c.iterator();\n155: for (int i = 0; i < totalSize; i++) {\n156: if (!iter.hasNext()) {\n157: Assert.fail(\"Too short\");\n158: }\n159: final int uniDimIndex = iter.next();\n160: Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n161: 162: for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n163: Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n164: expected[i][dimIndex], iter.getCount(dimIndex));\n165: }\n166: 167: Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n168: c.getCount(expected[i]), uniDimIndex);\n169: 170: final int[] indices = c.getCounts(uniDimIndex);\n171: for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n172: Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n173: expected[i][dimIndex], indices[dimIndex]);",
    "stack_trace": "junit.framework.AssertionFailedError: Wrong multidimensional index for [3][2] expected:<3> but was:<2>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:555)\nat org.apache.commons.math.util.MultidimensionalCounterTest.testIterationConsistency(MultidimensionalCounterTest.java:172)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter:getCounts(I)[I",
            "method_body": "public int[] getCounts(int index) {\nif (index < 0 ||\nfinal int[] indices = new int[dimension];\nint count = 0;\nfor (int i = 0; i < last; i++) {\nint idx = 0;\nfinal int offset = uniCounterOffset[i];\nwhile (count <= index) {\ncount += offset;\n++idx;\n--idx;\ncount -= offset;\nindices[i] = idx;\nint idx = 1;\nwhile (count < index) {\ncount += idx;\n++idx;\n--idx;\nindices[last] = idx;\nreturn indices;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter:getCount([I)I",
            "method_body": "public int getCount(int ... c) throws OutOfRangeException {\nif (c.length != dimension) {\nint count = 0;\nfor (int i = 0; i < dimension; i++) {\nfinal int index = c[i];\nif (index < 0 ||\ncount += uniCounterOffset[i] * c[i];\nreturn count + c[last];\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter$Iterator:next()Ljava/lang/Integer;",
            "method_body": "public Integer next() {\nfor (int i = last; i >= 0; i--) {\nif (counter[i] == size[i] - 1) {\n++counter[i];\nbreak;\nreturn ++count;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter$Iterator:hasNext()Z",
            "method_body": "public boolean hasNext() {\nfor (int i = 0; i < dimension; i++) {\nif (counter[i] != size[i] - 1) {\nreturn true;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter:<init>([I)V",
            "method_body": "public MultidimensionalCounter(int ... size) {\ndimension = size.length;\nthis.size = MathUtils.copyOf(size);\nuniCounterOffset = new int[dimension];\nlast = dimension - 1;\nint tS = size[last];\nfor (int i = 0; i < last; i++) {\nint count = 1;\nfor (int j = i + 1; j < dimension; j++) {\ncount *= size[j];\nuniCounterOffset[i] = count;\ntS *= size[i];\nuniCounterOffset[last] = 0;\nif (tS <= 0) {\ntotalSize = tS;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter:iterator()Lorg/apache/commons/math/util/MultidimensionalCounter$Iterator;",
            "method_body": "public Iterator iterator() {\nreturn new Iterator();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.util.MultidimensionalCounter$Iterator:<init>(Lorg/apache/commons/math/util/MultidimensionalCounter;)V",
            "method_body": "Iterator() {\ncounter[last] = -1;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:copyOf([I)[I",
            "method_body": "public static int[] copyOf(int[] source) {\nreturn copyOf(source, source.length);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:copyOf([II)[I",
            "method_body": "public static int[] copyOf(int[] source, int len) {\nfinal int[] output = new int[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 9
        }
    ]
}