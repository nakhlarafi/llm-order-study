{
    "bug_id": 1,
    "test_id": 0,
    "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.TestLang747",
    "test_body": "250: public void TestLang747() {\n251: assertEquals(Integer.valueOf(0x8000),      NumberUtils.createNumber(\"0x8000\"));\n252: assertEquals(Integer.valueOf(0x80000),     NumberUtils.createNumber(\"0x80000\"));\n253: assertEquals(Integer.valueOf(0x800000),    NumberUtils.createNumber(\"0x800000\"));\n254: assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x8000000\"));\n255: assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x7FFFFFFF\"));\n256: assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x80000000\"));\n257: assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0xFFFFFFFF\"));\n258: 259: // Leading zero tests\n260: assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x08000000\"));\n261: assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x007FFFFFFF\"));\n262: assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x080000000\"));\n263: assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0x00FFFFFFFF\"));\n264: 265: assertEquals(Long.valueOf(0x800000000L),        NumberUtils.createNumber(\"0x800000000\"));\n266: assertEquals(Long.valueOf(0x8000000000L),       NumberUtils.createNumber(\"0x8000000000\"));\n267: assertEquals(Long.valueOf(0x80000000000L),      NumberUtils.createNumber(\"0x80000000000\"));\n268: assertEquals(Long.valueOf(0x800000000000L),     NumberUtils.createNumber(\"0x800000000000\"));\n269: assertEquals(Long.valueOf(0x8000000000000L),    NumberUtils.createNumber(\"0x8000000000000\"));\n270: assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x80000000000000\"));\n271: assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x800000000000000\"));\n272: assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x7FFFFFFFFFFFFFFF\"));\n273: // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n274: assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x8000000000000000\"));\n275: assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0xFFFFFFFFFFFFFFFF\"));\n276: 277: // Leading zero tests\n278: assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x00080000000000000\"));\n279: assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x0800000000000000\"));\n280: assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x07FFFFFFFFFFFFFFF\"));\n281: // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n282: assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x00008000000000000000\"));\n283: assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0x0FFFFFFFFFFFFFFFF\"));\n284: }\n",
    "stack_trace": "java.lang.NumberFormatException: For input string: \"80000000\"\nat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\nat java.lang.Integer.parseInt(Integer.java:583)\nat java.lang.Integer.valueOf(Integer.java:740)\nat java.lang.Integer.decode(Integer.java:1197)\nat org.apache.commons.lang3.math.NumberUtils.createInteger(NumberUtils.java:684)\nat org.apache.commons.lang3.math.NumberUtils.createNumber(NumberUtils.java:474)\nat org.apache.commons.lang3.math.NumberUtilsTest.TestLang747(NumberUtilsTest.java:256)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
            "method_body": "public static Number createNumber(final String str) throws NumberFormatException {\nif (str == null) {\nif (StringUtils.isBlank(str)) {\nfinal String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\nint pfxLen = 0;\nfor(final String pfx : hex_prefixes) {\nif (str.startsWith(pfx)) {\npfxLen += pfx.length();\nbreak;\nif (pfxLen > 0) { // we have a hex number\nfinal int hexDigits = str.length() - pfxLen;\nif (hexDigits > 16) { // too many for Long\nif (hexDigits > 8) { // too many for an int\nreturn createInteger(str);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
            "method_body": "public static Integer createInteger(final String str) {\nif (str == null) {\nreturn Integer.decode(str);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
            "method_body": "public static boolean isBlank(final CharSequence cs) {\nif (cs == null || (strLen = cs.length()) == 0) {\nfor (int i = 0; i < strLen; i++) {\nif (Character.isWhitespace(cs.charAt(i)) == false) {\nreturn false;\n}",
            "method_id": 2
        }
    ]
}