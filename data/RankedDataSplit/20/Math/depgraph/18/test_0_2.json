{
    "bug_id": 18,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary",
    "test_body": "439: public void testFitAccuracyDependsOnBoundary() {\n440: final CMAESOptimizer optimizer = new CMAESOptimizer();\n441: final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n442: public double value(double[] parameters) {\n443: final double target = 11.1;\n444: final double error = target - parameters[0];\n445: return error * error;\n446: }\n447: };\n448: 449: final double[] start = { 1 };\n450: 451: // No bounds.\n452: PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n453: start);\n454: final double resNoBound = result.getPoint()[0];\n455: 456: // Optimum is near the lower bound.\n457: final double[] lower = { -20 };\n458: final double[] upper = { 5e16 };\n459: result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n460: start, lower, upper);\n461: final double resNearLo = result.getPoint()[0];\n462: 463: // Optimum is near the upper bound.\n464: lower[0] = -5e16;\n465: upper[0] = 20;\n466: result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n467: start, lower, upper);\n468: final double resNearHi = result.getPoint()[0];\n469: 470: // System.out.println(\"resNoBound=\" + resNoBound +\n471: //                    \" resNearLo=\" + resNearLo +\n472: //                    \" resNearHi=\" + resNearHi);\n473: 474: // The two values currently differ by a substantial amount, indicating that\n475: // the bounds definition can prevent reaching the optimum.\n476: Assert.assertEquals(resNoBound, resNearLo, 1e-3);\n477: Assert.assertEquals(resNoBound, resNearHi, 1e-3);\n478: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<11.100000000388787> but was:<8.0>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary(CMAESOptimizerTest.java:477)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:reverse([I)[I",
            "method_body": "private static int[] reverse(final int[] indices) {\nint[] reverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\nreverse[i] = indices[indices.length - i - 1];\nreturn reverse;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:randn1(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix randn1(int size, int popSize) {\ndouble[][] d = new double[size][popSize];\nfor (int r = 0; r < size; r++) {\nfor (int c = 0; c < popSize; c++) {\nd[r][c] = random.nextGaussian();\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$DoubleIndex:<init>(DI)V",
            "method_body": "DoubleIndex(double value, int index) {\nthis.value = value;\nthis.index = index;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$DoubleIndex:compareTo(Lorg/apache/commons/math3/optimization/direct/CMAESOptimizer$DoubleIndex;)I",
            "method_body": "public int compareTo(DoubleIndex o) {\nreturn Double.compare(value, o.value);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getFrobeniusNorm()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createColumnRealMatrix([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createColumnRealMatrix(double[] columnData)\nif (columnData == null) {\nfinal int nRows = columnData.length;\nfinal RealMatrix m = createRealMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nm.setEntry(i, 0, columnData[i]);\nreturn m;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:start(IIIIII)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarAdd(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarAdd(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) + d);\nreturn out;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:add(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix add(RealMatrix m)\nMatrixUtils.checkAdditionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumnMatrix(I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getColumnMatrix(final int column)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal RealMatrix out = createMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nout.setEntry(i, 0, getEntry(i, column));\nreturn out;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarMultiply(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarMultiply(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) * d);\nreturn out;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getD()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getD() {\nif (cachedD == null) {\ncachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\nfor (int i = 0; i < imagEigenvalues.length; i++) {\nif (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n} else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\nreturn cachedD;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:doOptimize()Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\nisMinimize = getGoalType().equals(GoalType.MINIMIZE);\nfinal FitnessFunction fitfun = new FitnessFunction();\nfinal double[] guess = fitfun.encode(getStartPoint());\ndimension = guess.length;\ninitializeCMA(guess);\niterations = 0;\ndouble bestValue = fitfun.value(guess);\npush(fitnessHistory, bestValue);\nPointValuePair optimum = new PointValuePair(getStartPoint(),\nPointValuePair lastResult = null;\nfor (iterations = 1; iterations <= maxIterations; iterations++) {\nRealMatrix arz = randn1(dimension, lambda);\nRealMatrix arx = zeros(dimension, lambda);\ndouble[] fitness = new double[lambda];\nfor (int k = 0; k < lambda; k++) {\nRealMatrix arxk = null;\nfor (int i = 0; i < checkFeasableCount+1; i++) {\nif (diagonalOnly <= 0) {\narxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\nif (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\ncopyColumn(arxk, 0, arx, k);\nfitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n}\nint[] arindex = sortedIndices(fitness);\nRealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\nRealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\nxmean = bestArx.multiply(weights);\nRealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\nRealMatrix zmean = bestArz.multiply(weights);\nboolean hsig = updateEvolutionPaths(zmean, xold);\nif (diagonalOnly <= 0) {\nupdateCovariance(hsig, bestArx, arz, arindex, xold);\nsigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\ndouble bestFitness = fitness[arindex[0]];\ndouble worstFitness = fitness[arindex[arindex.length-1]];\nif (bestValue > bestFitness) {\nbestValue = bestFitness;\nlastResult = optimum;\noptimum = new PointValuePair(\nif (getConvergenceChecker() != null && lastResult != null) {\nif (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\nif (stopFitness != 0) { // only if stopFitness is defined\ndouble[] sqrtDiagC = sqrt(diagC).getColumn(0);\ndouble[] pcCol = pc.getColumn(0);\nfor (int i = 0; i < dimension; i++) {\nif (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\nbreak;\nfor (int i = 0; i < dimension; i++) {\nif (sigma*sqrtDiagC[i] > stopTolUpX) {\ndouble historyBest = min(fitnessHistory);\ndouble historyWorst = max(fitnessHistory);\nif (iterations > 2 && Math.max(historyWorst, worstFitness) -\nbreak generationLoop;\nif (iterations > fitnessHistory.length &&\nif (max(diagD)/min(diagD) > 1e7) {\nif (getConvergenceChecker() != null) {\nPointValuePair current =\nif (lastResult != null &&\nbreak generationLoop;\nlastResult = current;\nif (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\nsigma = sigma * Math.exp(0.2+cs/damps);\nif (iterations > 2 && Math.max(historyWorst, bestFitness) -\npush(fitnessHistory,bestFitness);\nfitfun.setValueRange(worstFitness-bestFitness);\nif (generateStatistics) {\nreturn optimum;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nfinal double[] init = getStartPoint();\nfinal double[] lB = getLowerBound();\nfinal double[] uB = getUpperBound();\nboolean hasFiniteBounds = false;\nfor (int i = 0; i < lB.length; i++) {\nif (!Double.isInfinite(lB[i]) ||\nhasFiniteBounds = true;\nbreak;\nboolean hasInfiniteBounds = false;\nif (hasFiniteBounds) {\nfor (int i = 0; i < lB.length; i++) {\nif (Double.isInfinite(lB[i]) ||\nif (hasInfiniteBounds) {\nboundaries = new double[2][];\nboundaries[0] = lB;\nboundaries[1] = uB;\nfor (int i = 0; i < lB.length; i++) {\nif (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\nboundaries = null;\nif (inputSigma != null) {\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([II)[I",
            "method_body": "public static int[] copyOf(int[] source, int len) {\nfinal int[] output = new int[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealDiagonalMatrix([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\nfinal RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\nfor (int i = 0; i < diagonal.length; ++i) {\nm.setEntry(i, i, diagonal[i]);\nreturn m;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getV()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getV() {\nif (cachedV == null) {\nfinal int m = eigenvectors.length;\ncachedV = MatrixUtils.createRealMatrix(m, m);\nfor (int k = 0; k < m; ++k) {\ncachedV.setColumnVector(k, eigenvectors[k]);\nreturn cachedV;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumnVector(ILorg/apache/commons/math3/linear/RealVector;)V",
            "method_body": "public void setColumnVector(final int column, final RealVector vector)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (vector.getDimension() != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, vector.getEntry(i));\n}",
            "method_id": 59
        }
    ]
}