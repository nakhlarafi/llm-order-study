{
    "bug_id": 58,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519",
    "test_body": "298: public void testMath519() {\n299: // The optimizer will try negative sigma values but \"GaussianFitter\"\n300: // will catch the raised exceptions and return NaN values instead.\n301: 302: final double[] data = { \n303: 1.1143831578403364E-29,\n304: 4.95281403484594E-28,\n305: 1.1171347211930288E-26,\n306: 1.7044813962636277E-25,\n307: 1.9784716574832164E-24,\n308: 1.8630236407866774E-23,\n309: 1.4820532905097742E-22,\n310: 1.0241963854632831E-21,\n311: 6.275077366673128E-21,\n312: 3.461808994532493E-20,\n313: 1.7407124684715706E-19,\n314: 8.056687953553974E-19,\n315: 3.460193945992071E-18,\n316: 1.3883326374011525E-17,\n317: 5.233894983671116E-17,\n318: 1.8630791465263745E-16,\n319: 6.288759227922111E-16,\n320: 2.0204433920597856E-15,\n321: 6.198768938576155E-15,\n322: 1.821419346860626E-14,\n323: 5.139176445538471E-14,\n324: 1.3956427429045787E-13,\n325: 3.655705706448139E-13,\n326: 9.253753324779779E-13,\n327: 2.267636001476696E-12,\n328: 5.3880460095836855E-12,\n329: 1.2431632654852931E-11\n330: };\n331: 332: GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n333: for (int i = 0; i < data.length; i++) {\n334: fitter.addObservedPoint(i, data[i]);\n335: }\n336: final double[] p = fitter.fit();\n337: 338: Assert.assertEquals(53.1572792, p[1], 1e-7);\n339: Assert.assertEquals(5.75214622, p[2], 1e-8);\n340: }\n",
    "stack_trace": "org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than, or equal to, the minimum (0)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.validateParameters(Gaussian.java:183)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.value(Gaussian.java:128)\nat org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction.value(CurveFitter.java:203)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.computeObjectiveValue(BaseAbstractVectorialOptimizer.java:107)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateResidualsAndCost(AbstractLeastSquaresOptimizer.java:128)\nat org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize(LevenbergMarquardtOptimizer.java:350)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.optimize(BaseAbstractVectorialOptimizer.java:141)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:253)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:43)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:160)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:126)\nat org.apache.commons.math.optimization.fitting.GaussianFitter.fit(GaussianFitter.java:121)\nat org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519(GaussianFitterTest.java:336)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.exception.NumberIsTooSmallException:<init>(Lorg/apache/commons/math/exception/util/Localizable;Ljava/lang/Number;Ljava/lang/Number;Z)V",
            "method_body": "public NumberIsTooSmallException(Localizable specific,\nsuper(specific,\nthis.min = min;\nthis.boundIsAllowed = boundIsAllowed;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\nif (a < b) {\nreturn a;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math.exception.MathIllegalNumberException:<init>(Lorg/apache/commons/math/exception/util/Localizable;Lorg/apache/commons/math/exception/util/Localizable;Ljava/lang/Number;[Ljava/lang/Object;)V",
            "method_body": "protected MathIllegalNumberException(Localizable specific,\nsuper(specific, general, wrong, arguments);\nargument = wrong;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math.exception.MathIllegalArgumentException:<init>(Lorg/apache/commons/math/exception/util/Localizable;Lorg/apache/commons/math/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public MathIllegalArgumentException(Localizable specific,\nsuper(null, specific, general, args);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math.exception.MathRuntimeException:<init>(Ljava/lang/Throwable;Lorg/apache/commons/math/exception/util/Localizable;Lorg/apache/commons/math/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public MathRuntimeException(final Throwable cause,\nsuper(cause);\nthis.specific = specific;\nthis.general = general;\nthis.arguments = ArgUtils.flatten(arguments);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math.exception.util.ArgUtils:flatten([Ljava/lang/Object;)[Ljava/lang/Object;",
            "method_body": "public static Object[] flatten(Object[] array) {\nfinal List<Object> list = new ArrayList<Object>();\nif (array != null) {\nfor (Object o : array) {\nif (o instanceof Object[]) {\nfor (Object oR : flatten((Object[]) o)) {\nlist.add(oR);\nlist.add(o);\nreturn list.toArray();\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\nif (x < 0.0) {\nintVal = (int) -x;\nif (intVal > 746) {\nif (intVal > 709) {\nif (intVal == 709) {\nintVal++;\nintPartA = EXP_INT_TABLE_A[750-intVal];\nintPartB = EXP_INT_TABLE_B[750-intVal];\nintVal = -intVal;\nintVal = (int) x;\nif (intVal > 709) {\nintPartA = EXP_INT_TABLE_A[750+intVal];\nintPartB = EXP_INT_TABLE_B[750+intVal];\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = EXP_FRAC_TABLE_B[intFrac];\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\nfinal double tempC = tempB + tempA;\nif (extra != 0.0) {\nresult = tempC*z + tempB + tempA;\nif (hiPrec != null) {\nreturn result;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction$1:<init>(Lorg/apache/commons/math/optimization/fitting/CurveFitter$TheoreticalValuesFunction;)V",
            "method_body": "public MultivariateMatrixFunction jacobian() {\nreturn new MultivariateMatrixFunction() {\nfinal double[][] jacobian = new double[observations.size()][];\nint i = 0;\nfor (WeightedObservedPoint observed : observations) {\njacobian[i++] = f.gradient(observed.getX(), point);\nreturn jacobian;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser$1:compare(Ljava/lang/Object;Ljava/lang/Object;)I",
            "method_body": "private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\nreturn new Comparator<WeightedObservedPoint>() {\nif (p1 == null && p2 == null) {\nif (p1 == null) {\nif (p2 == null) {\nif (p1.getX() < p2.getX()) {\nreturn -1;\n}",
            "method_id": 72
        }
    ]
}