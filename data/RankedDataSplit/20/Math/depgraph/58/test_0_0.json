{
    "bug_id": 58,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519",
    "test_body": "298: public void testMath519() {\n299: // The optimizer will try negative sigma values but \"GaussianFitter\"\n300: // will catch the raised exceptions and return NaN values instead.\n301: 302: final double[] data = { \n303: 1.1143831578403364E-29,\n304: 4.95281403484594E-28,\n305: 1.1171347211930288E-26,\n306: 1.7044813962636277E-25,\n307: 1.9784716574832164E-24,\n308: 1.8630236407866774E-23,\n309: 1.4820532905097742E-22,\n310: 1.0241963854632831E-21,\n311: 6.275077366673128E-21,\n312: 3.461808994532493E-20,\n313: 1.7407124684715706E-19,\n314: 8.056687953553974E-19,\n315: 3.460193945992071E-18,\n316: 1.3883326374011525E-17,\n317: 5.233894983671116E-17,\n318: 1.8630791465263745E-16,\n319: 6.288759227922111E-16,\n320: 2.0204433920597856E-15,\n321: 6.198768938576155E-15,\n322: 1.821419346860626E-14,\n323: 5.139176445538471E-14,\n324: 1.3956427429045787E-13,\n325: 3.655705706448139E-13,\n326: 9.253753324779779E-13,\n327: 2.267636001476696E-12,\n328: 5.3880460095836855E-12,\n329: 1.2431632654852931E-11\n330: };\n331: 332: GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n333: for (int i = 0; i < data.length; i++) {\n334: fitter.addObservedPoint(i, data[i]);\n335: }\n336: final double[] p = fitter.fit();\n337: 338: Assert.assertEquals(53.1572792, p[1], 1e-7);\n339: Assert.assertEquals(5.75214622, p[2], 1e-8);\n340: }\n",
    "stack_trace": "org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than, or equal to, the minimum (0)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.validateParameters(Gaussian.java:183)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.value(Gaussian.java:128)\nat org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction.value(CurveFitter.java:203)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.computeObjectiveValue(BaseAbstractVectorialOptimizer.java:107)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateResidualsAndCost(AbstractLeastSquaresOptimizer.java:128)\nat org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize(LevenbergMarquardtOptimizer.java:350)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.optimize(BaseAbstractVectorialOptimizer.java:141)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:253)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:43)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:160)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:126)\nat org.apache.commons.math.optimization.fitting.GaussianFitter.fit(GaussianFitter.java:121)\nat org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519(GaussianFitterTest.java:336)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:getInterpolationPointsForY([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;IID)[Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;",
            "method_body": "private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\nif (idxStep == 0) {\nfor (int i = startIdx;\n(idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\ni += idxStep) {\nif (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\ndouble minY = Double.POSITIVE_INFINITY;\ndouble maxY = Double.NEGATIVE_INFINITY;\nfor (final WeightedObservedPoint point : points) {\nminY = Math.min(minY, point.getY());\nmaxY = Math.max(maxY, point.getY());\nthrow new OutOfRangeException(y, minY, maxY);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:findMaxY([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)I",
            "method_body": "private int findMaxY(WeightedObservedPoint[] points) {\nint maxYIdx = 0;\nfor (int i = 1; i < points.length; i++) {\nif (points[i].getY() > points[maxYIdx].getY()) {\nmaxYIdx = i;\nreturn maxYIdx;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:basicGuess([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)[D",
            "method_body": "private double[] basicGuess(WeightedObservedPoint[] points) {\nArrays.sort(points, createWeightedObservedPointComparator());\ndouble[] params = new double[3];\nint maxYIdx = findMaxY(points);\nparams[0] = points[maxYIdx].getY();\nparams[1] = points[maxYIdx].getX();\ndouble halfY = params[0] + ((params[1] - params[0]) / 2.0);\ndouble fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\ndouble fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\nfwhmApprox = fwhmX2 - fwhmX1;\n} catch (OutOfRangeException e) {\nfwhmApprox = points[points.length - 1].getX() - points[0].getX();\n}\nparams[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\nreturn params;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter:fit()[D",
            "method_body": "public double[] fit() {\nfinal double[] guess = (new ParameterGuesser(getObservations())).guess();\nreturn fit(new Gaussian.Parametric(), guess);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:interpolateXAtY([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;IID)D",
            "method_body": "private double interpolateXAtY(WeightedObservedPoint[] points,\nif (idxStep == 0) {\nWeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\nWeightedObservedPoint pointA = twoPoints[0];\nWeightedObservedPoint pointB = twoPoints[1];\nif (pointA.getY() == y) {\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:guess()[D",
            "method_body": "public double[] guess() {\nif (parameters == null) {\nparameters = basicGuess(observations);\nreturn parameters.clone();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:isBetween(DDD)Z",
            "method_body": "private boolean isBetween(double value, double boundary1, double boundary2) {\nreturn (value >= boundary1 && value <= boundary2) ||\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:createWeightedObservedPointComparator()Ljava/util/Comparator;",
            "method_body": "private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\nreturn new Comparator<WeightedObservedPoint>() {\nif (p1 == null && p2 == null) {\nif (p1 == null) {\nif (p2 == null) {\nif (p1.getX() < p2.getX()) {\nreturn -1;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.WeightedObservedPoint:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.WeightedObservedPoint:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:<init>([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)V",
            "method_body": "public ParameterGuesser(WeightedObservedPoint[] observations) {\nif (observations == null) {\nif (observations.length < 3) {\nthis.observations = observations.clone();\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:<init>(DDDDD)V",
            "method_body": "public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\ndouble threshold) {\nthis.initialStepBoundFactor = initialStepBoundFactor;\nthis.costRelativeTolerance = costRelativeTolerance;\nthis.parRelativeTolerance = parRelativeTolerance;\nthis.orthoTolerance = orthoTolerance;\nthis.qrRankingThreshold = threshold;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.exception.OutOfRangeException:<init>(Lorg/apache/commons/math/exception/util/Localizable;Ljava/lang/Number;Ljava/lang/Number;Ljava/lang/Number;)V",
            "method_body": "public OutOfRangeException(Localizable specific,\nsuper(specific, LocalizedFormats.OUT_OF_RANGE_SIMPLE,\nthis.lo = lo;\nthis.hi = hi;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter:<init>(Lorg/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer;)V",
            "method_body": "public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\nsuper(optimizer);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:<init>()V",
            "method_body": "public LevenbergMarquardtOptimizer() {\nthis(100, 1e-10, 1e-10, 1e-10, MathUtils.SAFE_MIN);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.exception.OutOfRangeException:<init>(Ljava/lang/Number;Ljava/lang/Number;Ljava/lang/Number;)V",
            "method_body": "public OutOfRangeException(Number wrong,\nthis(null, wrong, lo, hi);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser$1:compare(Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)I",
            "method_body": "private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\nreturn new Comparator<WeightedObservedPoint>() {\nif (p1 == null && p2 == null) {\nif (p1 == null) {\nif (p2 == null) {\nif (p1.getX() < p2.getX()) {\nreturn -1;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.analysis.function.Gaussian$Parametric:value(D[D)D",
            "method_body": "public double value(double x,\nvalidateParameters(param);\nfinal double diff = x - param[1];\nfinal double i2s2 = 1 / (2 * param[2] * param[2]);\nreturn Gaussian.value(diff, param[0], i2s2);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.analysis.function.Gaussian$Parametric:gradient(D[D)[D",
            "method_body": "public double[] gradient(double x, double[] param) {\nvalidateParameters(param);\nfinal double norm = param[0];\nfinal double diff = x - param[1];\nfinal double sigma = param[2];\nfinal double i2s2 = 1 / (2 * sigma * sigma);\nfinal double n = Gaussian.value(diff, 1, i2s2);\nfinal double m = norm * n * 2 * i2s2 * diff;\nfinal double s = m * diff / sigma;\nreturn new double[] { n, m, s };\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter:addObservedPoint(DD)V",
            "method_body": "public void addObservedPoint(double x, double y) {\naddObservedPoint(1.0, x, y);\n}",
            "method_id": 19
        }
    ]
}