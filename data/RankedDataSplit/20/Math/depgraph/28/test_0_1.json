{
    "bug_id": 28,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.linear.SimplexSolverTest.testMath828Cycle",
    "test_body": "55: public void testMath828Cycle() {\n56: LinearObjectiveFunction f = new LinearObjectiveFunction(\n57: new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);\n58: 59: ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>();\n60: 61: constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));\n62: constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));\n63: constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));\n64: constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));\n65: constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));\n66: constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));\n67: constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));\n68: 69: double epsilon = 1e-6;\n70: PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true);\n71: Assert.assertEquals(1.0d, solution.getValue(), epsilon);",
    "stack_trace": "org.apache.commons.math3.exception.MaxCountExceededException: illegal state: maximal count (100) exceeded\nat org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer.incrementIterationsCounter(AbstractLinearOptimizer.java:128)\nat org.apache.commons.math3.optimization.linear.SimplexSolver.doIteration(SimplexSolver.java:165)\nat org.apache.commons.math3.optimization.linear.SimplexSolver.doOptimize(SimplexSolver.java:227)\nat org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer.optimize(AbstractLinearOptimizer.java:147)\nat org.apache.commons.math3.optimization.linear.SimplexSolverTest.testMath828Cycle(SimplexSolverTest.java:70)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.exception.MaxCountExceededException:<init>(Ljava/lang/Number;)V",
            "method_body": "public MaxCountExceededException(Number max) {\nthis(LocalizedFormats.MAX_COUNT_EXCEEDED, max);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.exception.MaxCountExceededException:<init>(Lorg/apache/commons/math3/exception/util/Localizable;Ljava/lang/Number;[Ljava/lang/Object;)V",
            "method_body": "public MaxCountExceededException(Localizable specific,\nObject ... args) {\ngetContext().addMessage(specific, max, args);\nthis.max = max;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:incrementIterationsCounter()V",
            "method_body": "protected void incrementIterationsCounter()\nif (++iterations > maxIterations) {\nthrow new MaxCountExceededException(maxIterations);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getBasicRow(I)Ljava/lang/Integer;",
            "method_body": "protected Integer getBasicRow(final int col) {\nInteger row = null;\nfor (int i = 0; i < getHeight(); i++) {\nfinal double entry = getEntry(i, col);\nif (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\nrow = i;\n} else if (!Precision.equals(entry, 0d, maxUlps)) {\nreturn null;\nreturn row;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:dropPhase1Objective()V",
            "method_body": "protected void dropPhase1Objective() {\nif (getNumObjectiveFunctions() == 1) {\nSet<Integer> columnsToDrop = new TreeSet<Integer>();\ncolumnsToDrop.add(0);\nfor (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\nfinal double entry = tableau.getEntry(0, i);\nif (Precision.compareTo(entry, 0d, epsilon) > 0) {\nfor (int i = 0; i < getNumArtificialVariables(); i++) {\nint col = i + getArtificialVariableOffset();\nif (getBasicRow(col) == null) {\ncolumnsToDrop.add(col);\ndouble[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\nfor (int i = 1; i < getHeight(); i++) {\nint col = 0;\nfor (int j = 0; j < getWidth(); j++) {\nif (!columnsToDrop.contains(j)) {\nmatrix[i - 1][col++] = tableau.getEntry(i, j);\nInteger[] drop = columnsToDrop.toArray(new Integer[columnsToDrop.size()]);\nfor (int i = drop.length - 1; i >= 0; i--) {\ncolumnLabels.remove((int) drop[i]);\nthis.tableau = new Array2DRowRealMatrix(matrix);\nthis.numArtificialVariables = 0;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:divideRow(ID)V",
            "method_body": "protected void divideRow(final int dividendRow, final double divisor) {\nfor (int j = 0; j < getWidth(); j++) {\ntableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:subtractRow(IID)V",
            "method_body": "protected void subtractRow(final int minuendRow, final int subtrahendRow,\nfor (int i = 0; i < getWidth(); i++) {\ndouble result = tableau.getEntry(minuendRow, i) - tableau.getEntry(subtrahendRow, i) * multiple;\nif (FastMath.abs(result) < CUTOFF_THRESHOLD) {\nresult = 0.0;\ntableau.setEntry(minuendRow, i, result);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getArtificialVariableOffset()I",
            "method_body": "protected final int getArtificialVariableOffset() {\nreturn getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getRhsOffset()I",
            "method_body": "protected final int getRhsOffset() {\nreturn getWidth() - 1;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:<init>()V",
            "method_body": "protected AbstractLinearOptimizer() {\nsetMaxIterations(DEFAULT_MAX_ITERATIONS);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:restrictToNonNegative()Z",
            "method_body": "protected boolean restrictToNonNegative() {\nreturn nonNegative;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:getGoalType()Lorg/apache/commons/math3/optimization/GoalType;",
            "method_body": "protected GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:getFunction()Lorg/apache/commons/math3/optimization/linear/LinearObjectiveFunction;",
            "method_body": "protected LinearObjectiveFunction getFunction() {\nreturn function;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:getConstraints()Ljava/util/Collection;",
            "method_body": "protected Collection<LinearConstraint> getConstraints() {\nreturn Collections.unmodifiableCollection(linearConstraints);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:setMaxIterations(I)V",
            "method_body": "public void setMaxIterations(int maxIterations) {\nthis.maxIterations = maxIterations;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.AbstractLinearOptimizer:optimize(Lorg/apache/commons/math3/optimization/linear/LinearObjectiveFunction;Ljava/util/Collection;Lorg/apache/commons/math3/optimization/GoalType;Z)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "public PointValuePair optimize(final LinearObjectiveFunction f,\nthis.function          = f;\nthis.linearConstraints = constraints;\nthis.goal              = goalType;\nthis.nonNegative       = restrictToNonNegative;\niterations  = 0;\nreturn doOptimize();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:isOptimal()Z",
            "method_body": "boolean isOptimal() {\nfor (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\nfinal double entry = tableau.getEntry(0, i);\nif (Precision.compareTo(entry, 0d, epsilon) < 0) {\nreturn false;\nreturn true;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getHeight()I",
            "method_body": "protected final int getHeight() {\nreturn tableau.getRowDimension();\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getWidth()I",
            "method_body": "protected final int getWidth() {\nreturn tableau.getColumnDimension();\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.linear.SimplexTableau:getEntry(II)D",
            "method_body": "protected final double getEntry(final int row, final int column) {\nreturn tableau.getEntry(row, column);\n}",
            "method_id": 39
        }
    ]
}