{
    "bug_id": 6,
    "test_id": 15,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest.testMinimize1",
    "test_body": "54: public void testMinimize1() {\n55: SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n56: final FourExtrema fourExtrema = new FourExtrema();\n57: 58: final PointValuePair optimum\n59: = optimizer.optimize(new MaxEval(100),\n60: new ObjectiveFunction(fourExtrema),\n61: GoalType.MINIMIZE,\n62: new InitialGuess(new double[] { -3, 0 }),\n63: new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n64: Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\n65: Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\n66: Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\n67: Assert.assertTrue(optimizer.getEvaluations() > 60);\n68: Assert.assertTrue(optimizer.getEvaluations() < 90);\n69: 70: // Check that the number of iterations is updated (MATH-949).\n71: Assert.assertTrue(optimizer.getIterations() > 0);\n72: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest.testMinimize1(SimplexOptimizerNelderMeadTest.java:71)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getValue()Ljava/lang/Object;",
            "method_body": "public V getValue() {\nreturn value;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getSize()I",
            "method_body": "public int getSize() {\nreturn simplex.length;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:build([D)V",
            "method_body": "public abstract void iterate(final MultivariateFunction evaluationFunction,\nif (dimension != startPoint.length) {\nsimplex = new PointValuePair[dimension + 1];\nsimplex[0] = new PointValuePair(startPoint, Double.NaN);\nfor (int i = 0; i < dimension; i++) {\nfinal double[] confI = startConfiguration[i];\nfinal double[] vertexI = new double[dimension];\nfor (int k = 0; k < dimension; k++) {\nvertexI[k] = startPoint[k] + confI[k];\nsimplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:evaluate(Lorg/apache/commons/math3/analysis/MultivariateFunction;Ljava/util/Comparator;)V",
            "method_body": "public void evaluate(final MultivariateFunction evaluationFunction,\nfor (int i = 0; i < simplex.length; i++) {\nfinal PointValuePair vertex = simplex[i];\nfinal double[] point = vertex.getPointRef();\nif (Double.isNaN(vertex.getValue())) {\nsimplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\nArrays.sort(simplex, comparator);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getPoints()[Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair[] getPoints() {\nfinal PointValuePair[] copy = new PointValuePair[simplex.length];\nSystem.arraycopy(simplex, 0, copy, 0, simplex.length);\nreturn copy;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getPoint(I)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair getPoint(int index) {\nif (index < 0 ||\nreturn simplex[index];\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer$1:value([D)D",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\nreturn computeObjectiveValue(point);\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nif (converged) {\nreturn simplex.getPoint(0);\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n++iteration;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer$2:compare(Lorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)I",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\nreturn computeObjectiveValue(point);\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nif (converged) {\nreturn simplex.getPoint(0);\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n++iteration;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPointRef()[D",
            "method_body": "public double[] getPointRef() {\nreturn getKey();\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:converged(ILorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)Z",
            "method_body": "public boolean converged(final int iteration,\nif (maxIterationCount != ITERATION_CHECK_DISABLED) {\nfinal double p = previous.getValue();\nfinal double c = current.getValue();\nfinal double difference = FastMath.abs(p - c);\nfinal double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\nreturn difference <= size * getRelativeThreshold() ||\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(D)D",
            "method_body": "public static double atan(double x) {\nreturn atan(x, 0.0, false);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getAbsoluteThreshold()D",
            "method_body": "public double getAbsoluteThreshold() {\nreturn absoluteThreshold;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getRelativeThreshold()D",
            "method_body": "public double getRelativeThreshold() {\nreturn relativeThreshold;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:<init>(DD)V",
            "method_body": "public AbstractConvergenceChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nthis.relativeThreshold = relativeThreshold;\nthis.absoluteThreshold = absoluteThreshold;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nreturn Double.NaN;\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 59
        }
    ]
}