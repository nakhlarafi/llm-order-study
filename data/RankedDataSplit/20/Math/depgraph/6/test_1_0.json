{
    "bug_id": 6,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMParameter([DD[D[D[D[D)V",
            "method_body": "private void determineLMParameter(double[] qy, double delta, double[] diag,\nfinal int nC = weightedJacobian[0].length;\nfor (int j = 0; j < rank; ++j) {\nlmDir[permutation[j]] = qy[j];\nfor (int j = rank; j < nC; ++j) {\nfor (int k = rank - 1; k >= 0; --k) {\nint pk = permutation[k];\ndouble ypk = lmDir[pk] / diagR[pk];\nfor (int i = 0; i < k; ++i) {\nlmDir[pk] = ypk;\ndouble dxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork1[pj] = s;\ndxNorm += s * s;\ndxNorm = FastMath.sqrt(dxNorm);\ndouble fp = dxNorm - delta;\nif (fp <= 0.1 * delta) {\nlmPar = 0;\nreturn;\ndouble parl = 0;\nif (rank == solvedCols) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] *= diag[pj] / dxNorm;\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i < j; ++i) {\ndouble s = (work1[pj] - sum) / diagR[pj];\nwork1[pj] = s;\nsum2 += s * s;\nparl = fp / (delta * sum2);\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qy[i];\nsum /= diag[pj];\nsum2 += sum * sum;\ndouble gNorm = FastMath.sqrt(sum2);\ndouble paru = gNorm / delta;\nif (paru == 0) {\nlmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\nif (lmPar == 0) {\nfor (int countdown = 10; countdown >= 0; --countdown) {\nif (lmPar == 0) {\ndouble sPar = FastMath.sqrt(lmPar);\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = sPar * diag[pj];\ndetermineLMDirection(qy, work1, work2, work3);\ndxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork3[pj] = s;\ndxNorm += s * s;\ndxNorm = FastMath.sqrt(dxNorm);\ndouble previousFP = fp;\nfp = dxNorm - delta;\nif ((FastMath.abs(fp) <= 0.1 * delta) ||\nreturn;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = work3[pj] * diag[pj] / dxNorm;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] /= work2[j];\ndouble tmp = work1[pj];\nfor (int i = j + 1; i < solvedCols; ++i) {\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ndouble s = work1[permutation[j]];\nsum2 += s * s;\ndouble correction = fp / (delta * sum2);\nif (fp > 0) {\n} else if (fp < 0) {\nparu = FastMath.min(paru, lmPar);\nlmPar = FastMath.max(parl, lmPar + correction);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "protected PointVectorValuePair doOptimize() {\ncheckParameters();\nfinal int nR = getTarget().length; // Number of observed data.\nfinal double[] currentPoint = getStartPoint();\nfinal int nC = currentPoint.length; // Number of parameters.\nsolvedCols  = FastMath.min(nR, nC);\ndiagR       = new double[nC];\njacNorm     = new double[nC];\nbeta        = new double[nC];\npermutation = new int[nC];\nlmDir       = new double[nC];\ndouble   delta   = 0;\ndouble   xNorm   = 0;\ndouble[] diag    = new double[nC];\ndouble[] oldX    = new double[nC];\ndouble[] oldRes  = new double[nR];\ndouble[] oldObj  = new double[nR];\ndouble[] qtf     = new double[nR];\ndouble[] work1   = new double[nC];\ndouble[] work2   = new double[nC];\ndouble[] work3   = new double[nC];\nfinal RealMatrix weightMatrixSqrt = getWeightSquareRoot();\ndouble[] currentObjective = computeObjectiveValue(currentPoint);\ndouble[] currentResiduals = computeResiduals(currentObjective);\nPointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\ndouble currentCost = computeCost(currentResiduals);\nlmPar = 0;\nboolean firstIteration = true;\nint iter = 0;\nfinal ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n++iter;\nfinal PointVectorValuePair previous = current;\nqrDecomposition(computeWeightedJacobian(currentPoint));\nweightedResidual = weightMatrixSqrt.operate(currentResiduals);\nfor (int i = 0; i < nR; i++) {\nqtf[i] = weightedResidual[i];\nqTy(qtf);\nfor (int k = 0; k < solvedCols; ++k) {\nint pk = permutation[k];\nweightedJacobian[k][pk] = diagR[pk];\nif (firstIteration) {\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble dk = jacNorm[k];\nif (dk == 0) {\ndouble xk = dk * currentPoint[k];\nxNorm  += xk * xk;\ndiag[k] = dk;\nxNorm = FastMath.sqrt(xNorm);\ndelta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\ndouble maxCosine = 0;\nif (currentCost != 0) {\nfor (int j = 0; j < solvedCols; ++j) {\nint    pj = permutation[j];\ndouble s  = jacNorm[pj];\nif (s != 0) {\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qtf[i];\nmaxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\nif (maxCosine <= orthoTolerance) {\nfor (int j = 0; j < nC; ++j) {\ndiag[j] = FastMath.max(diag[j], jacNorm[j]);\nfor (double ratio = 0; ratio < 1.0e-4;) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\noldX[pj] = currentPoint[pj];\nfinal double previousCost = currentCost;\ndouble[] tmpVec = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\ndetermineLMParameter(qtf, delta, diag, work1, work2, work3);\ndouble lmNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nlmDir[pj] = -lmDir[pj];\ncurrentPoint[pj] = oldX[pj] + lmDir[pj];\ndouble s = diag[pj] * lmDir[pj];\nlmNorm  += s * s;\nlmNorm = FastMath.sqrt(lmNorm);\nif (firstIteration) {\ndelta = FastMath.min(delta, lmNorm);\ncurrentObjective = computeObjectiveValue(currentPoint);\ncurrentResiduals = computeResiduals(currentObjective);\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\ncurrentCost = computeCost(currentResiduals);\ndouble actRed = -1.0;\nif (0.1 * currentCost < previousCost) {\ndouble r = currentCost / previousCost;\nactRed = 1.0 - r * r;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dirJ = lmDir[pj];\nwork1[j] = 0;\nfor (int i = 0; i <= j; ++i) {\nwork1[i] += weightedJacobian[i][pj] * dirJ;\ndouble coeff1 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ncoeff1 += work1[j] * work1[j];\ndouble pc2 = previousCost * previousCost;\ncoeff1 = coeff1 / pc2;\ndouble coeff2 = lmPar * lmNorm * lmNorm / pc2;\ndouble preRed = coeff1 + 2 * coeff2;\ndouble dirDer = -(coeff1 + coeff2);\nratio = (preRed == 0) ? 0 : (actRed / preRed);\nif (ratio <= 0.25) {\ndouble tmp =\nif ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\ntmp = 0.1;\ndelta = tmp * FastMath.min(delta, 10.0 * lmNorm);\nlmPar /= tmp;\n} else if ((lmPar == 0) || (ratio >= 0.75)) {\ndelta = 2 * lmNorm;\nlmPar *= 0.5;\nif (ratio >= 1.0e-4) {\nfirstIteration = false;\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble xK = diag[k] * currentPoint[k];\nxNorm += xK * xK;\nxNorm = FastMath.sqrt(xNorm);\nif (checker != null) {\ncurrentCost = previousCost;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ncurrentPoint[pj] = oldX[pj];\ntmpVec    = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\nif ((FastMath.abs(actRed) <= costRelativeTolerance &&\nsetCost(currentCost);\nreturn current;\nif ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n} else if (delta <= 2.2204e-16 * xNorm) {\n} else if (maxCosine <= 2.2204e-16)  {\n}\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMDirection([D[D[D[D)V",
            "method_body": "private void determineLMDirection(double[] qy, double[] diag,\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nfor (int i = j + 1; i < solvedCols; ++i) {\nlmDir[j] = diagR[pj];\nwork[j]  = qy[j];\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dpj = diag[pj];\nif (dpj != 0) {\nArrays.fill(lmDiag, j + 1, lmDiag.length, 0);\nlmDiag[j] = dpj;\ndouble qtbpj = 0;\nfor (int k = j; k < solvedCols; ++k) {\nint pk = permutation[k];\nif (lmDiag[k] != 0) {\ndouble rkk = weightedJacobian[k][pk];\nif (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\nfinal double cotan = rkk / lmDiag[k];\nsin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\ncos   = sin * cotan;\n} else {\nweightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\nfinal double temp = cos * work[k] + sin * qtbpj;\nqtbpj = -sin * work[k] + cos * qtbpj;\nwork[k] = temp;\nfor (int i = k + 1; i < solvedCols; ++i) {\nlmDiag[j] = weightedJacobian[j][permutation[j]];\nweightedJacobian[j][permutation[j]] = lmDir[j];\nint nSing = solvedCols;\nfor (int j = 0; j < solvedCols; ++j) {\nif ((lmDiag[j] == 0) && (nSing == solvedCols)) {\nif (nSing < solvedCols) {\nif (nSing > 0) {\nfor (int j = nSing - 1; j >= 0; --j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = j + 1; i < nSing; ++i) {\nwork[j] = (work[j] - sum) / lmDiag[j];\nfor (int j = 0; j < lmDir.length; ++j) {\nlmDir[permutation[j]] = work[j];\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qrDecomposition(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\nweightedJacobian = jacobian.scalarMultiply(-1).getData();\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\nfor (int k = 0; k < nC; ++k) {\npermutation[k] = k;\ndouble norm2 = 0;\nfor (int i = 0; i < nR; ++i) {\ndouble akk = weightedJacobian[i][k];\nnorm2 += akk * akk;\njacNorm[k] = FastMath.sqrt(norm2);\nfor (int k = 0; k < nC; ++k) {\nint nextColumn = -1;\ndouble ak2 = Double.NEGATIVE_INFINITY;\nfor (int i = k; i < nC; ++i) {\ndouble norm2 = 0;\nfor (int j = k; j < nR; ++j) {\ndouble aki = weightedJacobian[j][permutation[i]];\nnorm2 += aki * aki;\nif (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\nif (norm2 > ak2) {\nnextColumn = i;\nak2        = norm2;\nif (ak2 <= qrRankingThreshold) {\nint pk                  = permutation[nextColumn];\npermutation[nextColumn] = permutation[k];\npermutation[k]          = pk;\ndouble akk   = weightedJacobian[k][pk];\ndouble alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\ndouble betak = 1.0 / (ak2 - akk * alpha);\nbeta[pk]     = betak;\ndiagR[pk]        = alpha;\nweightedJacobian[k][pk] -= alpha;\nfor (int dk = nC - 1 - k; dk > 0; --dk) {\nrank = solvedCols;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qTy([D)V",
            "method_body": "private void qTy(double[] y) {\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\nfor (int k = 0; k < nC; ++k) {\nint pk = permutation[k];\ndouble gamma = 0;\nfor (int i = k; i < nR; ++i) {\ngamma += weightedJacobian[i][pk] * y[i];\ngamma *= beta[pk];\nfor (int i = k; i < nR; ++i) {\ny[i] -= gamma * weightedJacobian[i][pk];\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\nreturn super.optimize(optData);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\nif (data instanceof MaxIter) {\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nparseOptimizationData(optData);\nevaluations.resetCount();\niterations.resetCount();\nreturn doOptimize();\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (getLowerBound() != null ||\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>(DDDDD)V",
            "method_body": "public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\nsuper(null); // No custom convergence criterion.\nthis.initialStepBoundFactor = initialStepBoundFactor;\nthis.costRelativeTolerance = costRelativeTolerance;\nthis.parRelativeTolerance = parRelativeTolerance;\nthis.orthoTolerance = orthoTolerance;\nthis.qrRankingThreshold = threshold;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\nevaluations.incrementCount();\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nmaxEval = max;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>()V",
            "method_body": "public LevenbergMarquardtOptimizer() {\nthis(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 19
        }
    ]
}