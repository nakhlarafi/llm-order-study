{
    "bug_id": 44,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.events.EventStateTest.testIssue695",
    "test_body": "80: public void testIssue695() {\n81: 82: FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n83: 84: public int getDimension() {\n85: return 1;\n86: }\n87: 88: public void computeDerivatives(double t, double[] y, double[] yDot) {\n89: yDot[0] = 1.0;\n90: }\n91: };\n92: 93: DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n94: integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n95: integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n96: integrator.setInitialStepSize(3.0);\n97: 98: double target = 30.0;\n99: double[] y = new double[1];\n100: double tEnd = integrator.integrate(equation, 0.0, y, target, y);\n101: Assert.assertEquals(target, tEnd, 1.0e-10);",
    "stack_trace": "junit.framework.AssertionFailedError: going backard in time! (7.796578226186635 < 10.99)\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math.ode.events.EventStateTest$ResettingEvent.g(EventStateTest.java:120)\nat org.apache.commons.math.ode.events.EventState.evaluateStep(EventState.java:214)\nat org.apache.commons.math.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:302)\nat org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:296)\nat org.apache.commons.math.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:213)\nat org.apache.commons.math.ode.events.EventStateTest.testIssue695(EventStateTest.java:100)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:acceptStep(Lorg/apache/commons/math/ode/sampling/AbstractStepInterpolator;[D[DD)D",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nresetOccurred = false;\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\nstatesInitialized = true;\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\nreturn orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\noccuringEvents.add(state);\nwhile (!occuringEvents.isEmpty()) {\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\nfor (final StepHandler handler : stepHandlers) {\nif (isLastStep) {\nif (currentEvent.reset(eventT, eventY)) {\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nreturn eventT;\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\nfor (StepHandler handler : stepHandlers) {\nreturn currentT;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nif (y0.length != equations.getDimension()) {\nif (y.length != equations.getDimension()) {\nfinal ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\nexpandableODE.setTime(t0);\nexpandableODE.setPrimaryState(y0);\nintegrate(expandableODE, t);\nSystem.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\nreturn expandableODE.getTime();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:sanityChecks(Lorg/apache/commons/math/ode/ExpandableStatefulODE;D)V",
            "method_body": "protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\nfinal double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\nfinal double dt = FastMath.abs(equations.getTime() - t);\nif (dt <= threshold) {\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsStates = new ArrayList<EventState>();\nstatesInitialized = false;\nevaluations = new Incrementor();\nsetMaxEvaluations(-1);\nresetEvaluations();\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public abstract void integrate(ExpandableStatefulODE equations, double t)\nevaluations.incrementCount();\nexpandable.computeDerivatives(t, y, yDot);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nevaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:resetEvaluations()V",
            "method_body": "protected void resetEvaluations() {\nevaluations.resetCount();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math/ode/ExpandableStatefulODE;)V",
            "method_body": "protected void setEquations(final ExpandableStatefulODE equations) {\nthis.expandable = equations;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setStateInitialized(Z)V",
            "method_body": "protected void setStateInitialized(final boolean stateInitialized) {\nthis.statesInitialized = stateInitialized;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDILorg/apache/commons/math/analysis/solvers/UnivariateRealSolver;)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\neventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\naddEventHandler(handler, maxCheckInterval, convergence,\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:setInitialStepSize(D)V",
            "method_body": "public void setInitialStepSize(final double initialStepSize) {\nif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\ninitialStep = initialStepSize;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y) {\nif (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\nif (nextAction == EventHandler.Action.RESET_STATE) {\nhandler.resetState(t, y);\npendingEvent      = false;\npendingEventTime  = Double.NaN;\nreturn (nextAction == EventHandler.Action.RESET_STATE) ||\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setSoftPreviousTime(D)V",
            "method_body": "public void setSoftPreviousTime(final double softPreviousTime) {\nthis.softPreviousTime = softPreviousTime;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$1:compare(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/events/EventState;)I",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nresetOccurred = false;\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\nstatesInitialized = true;\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\nreturn orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\noccuringEvents.add(state);\nwhile (!occuringEvents.isEmpty()) {\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\nfor (final StepHandler handler : stepHandlers) {\nif (isLastStep) {\nif (currentEvent.reset(eventT, eventY)) {\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nreturn eventT;\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\nfor (StepHandler handler : stepHandlers) {\nreturn currentT;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEvent ?\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stop()Z",
            "method_body": "public boolean stop() {\nreturn nextAction == EventHandler.Action.STOP;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateRealSolver<?>) {\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 19
        }
    ]
}