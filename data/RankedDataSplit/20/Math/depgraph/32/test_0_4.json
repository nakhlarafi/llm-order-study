{
    "bug_id": 32,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest.testIssue780",
    "test_body": "237: public void testIssue780() {\n238: float[] coords = {\n239: 1.000000f, -1.000000f, -1.000000f, \n240: 1.000000f, -1.000000f, 1.000000f, \n241: -1.000000f, -1.000000f, 1.000000f, \n242: -1.000000f, -1.000000f, -1.000000f, \n243: 1.000000f, 1.000000f, -1f, \n244: 0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n245: -1.000000f, 1.000000f, 1.000000f, \n246: -1.000000f, 1.000000f, -1.000000f};\n247: int[] indices = {\n248: 0, 1, 2, 0, 2, 3, \n249: 4, 7, 6, 4, 6, 5, \n250: 0, 4, 5, 0, 5, 1, \n251: 1, 5, 6, 1, 6, 2, \n252: 2, 6, 7, 2, 7, 3, \n253: 4, 0, 3, 4, 3, 7};\n254: ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n255: for (int idx = 0; idx < indices.length; idx += 3) {\n256: int idxA = indices[idx] * 3;\n257: int idxB = indices[idx + 1] * 3;\n258: int idxC = indices[idx + 2] * 3;\n259: Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n260: Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n261: Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n262: Vector3D[] vertices = {v_1, v_2, v_3};\n263: Plane polyPlane = new Plane(v_1, v_2, v_3);\n264: ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n265: 266: Vector2D[] projPts = new Vector2D[vertices.length];\n267: for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n268: projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n269: }\n270: 271: SubLine lineInPlane = null;\n272: for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n273: lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n274: lines.add(lineInPlane);\n275: }\n276: Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n277: SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n278: subHyperplaneList.add(polygon);\n279: }\n280: PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n281: Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n282: Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);",
    "stack_trace": "java.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:136)\nat org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.addContribution(PolyhedronsSet.java:171)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitInternalNode(PolyhedronsSet.java:153)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:263)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:264)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties(PolyhedronsSet.java:118)\nat org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest.testIssue780(PolyhedronsSetTest.java:281)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:getMidPoint()D",
            "method_body": "public double getMidPoint() {\nreturn 0.5 * (lower + upper);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:<init>()V",
            "method_body": "public Characterization() {\nin  = null;\nout = null;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:hasIn()Z",
            "method_body": "public boolean hasIn() {\nreturn (in != null) && (!in.isEmpty());\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:getIn()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getIn() {\nreturn in;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:hasOut()Z",
            "method_body": "public boolean hasOut() {\nreturn (out != null) && (!out.isEmpty());\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:getOut()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getOut() {\nreturn out;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:add(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Z)V",
            "method_body": "public void add(final SubHyperplane<S> sub, final boolean inside) {\nif (inside) {\nif (in == null) {\nin = sub;\nif (out == null) {\nout = sub;\nout = out.reunite(sub);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)V",
            "method_body": "public BoundaryAttribute(final SubHyperplane<S> plusOutside,\nfinal SubHyperplane<S> plusInside) {\nthis.plusOutside = plusOutside;\nthis.plusInside  = plusInside;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:getPlusOutside()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getPlusOutside() {\nreturn plusOutside;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:getPlusInside()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getPlusInside() {\nreturn plusInside;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:delete()V",
            "method_body": "public void delete() {\nif ((parent == null) && (left == null) && (right == null)) {\nelement = null;\ntop     = null;\nif ((left == null) && (right == null)) {\nnode       = this;\nelement    = null;\nleftShrunk = node == node.parent.left;\nchild      = null;\nnode       = (left != null) ? left.getLargest() : right.getSmallest();\nelement    = node.element;\nleftShrunk = node == node.parent.left;\nchild      = (node.left != null) ? node.left : node.right;\nnode = node.parent;\nif (leftShrunk) {\nnode.left = child;\nnode.right = child;\nif (child != null) {\nwhile (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) {\nif (node.parent == null) {\nreturn;\nleftShrunk = node == node.parent.left;\nnode = node.parent;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceLeftGrown()Z",
            "method_body": "private boolean rebalanceLeftGrown() {\nswitch (skew) {\nif (left.skew == Skew.LEFT_HIGH) {\nrotateCW();\nskew       = Skew.BALANCED;\nright.skew = Skew.BALANCED;\nfinal Skew s = left.right.skew;\nleft.rotateCCW();\nrotateCW();\nswitch(s) {\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.BALANCED;\nskew = Skew.BALANCED;\nreturn false;\nskew = Skew.BALANCED;\nreturn false;\nskew = Skew.LEFT_HIGH;\nreturn true;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceRightShrunk()Z",
            "method_body": "private boolean rebalanceRightShrunk() {\nswitch (skew) {\nskew = Skew.BALANCED;\nreturn true;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:reunite(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {\nAbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;\nreturn buildNew(hyperplane,\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:chopOffPlus(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)V",
            "method_body": "private void chopOffPlus(final Hyperplane<S> hyperplane) {\nif (cut != null) {\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:orthogonal()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D orthogonal() {\ndouble threshold = 0.6 * getNorm();\nif (threshold == 0) {\nif ((x >= -threshold) && (x <= threshold)) {\ndouble inverse  = 1 / FastMath.sqrt(y * y + z * z);\nreturn new Vector3D(0, inverse * z, -inverse * y);\n} else if ((y >= -threshold) && (y <= threshold)) {\ndouble inverse  = 1 / FastMath.sqrt(x * x + z * z);\nreturn new Vector3D(-inverse * z, 0, inverse * x);\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:getOffset(Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)D",
            "method_body": "public double getOffset(final Line line) {\nreturn originOffset +\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn isEmpty(tree);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:isEmpty(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Z",
            "method_body": "public boolean isEmpty(final BSPTree<S> node) {\nif (node.getCut() == null) {\nreturn !((Boolean) node.getAttribute());\nreturn isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:side(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/Side;",
            "method_body": "public Side side(final Hyperplane<S> hyperplane) {\nfinal Sides sides = new Sides();\nrecurseSides(tree, hyperplane.wholeHyperplane(), sides);\nreturn sides.plusFound() ?\n}",
            "method_id": 99
        }
    ]
}