{
    "bug_id": 100,
    "test_id": 0,
    "test_name": "org.apache.commons.math.estimation.GaussNewtonEstimatorTest.testBoundParameters",
    "test_body": "451: public void testBoundParameters() throws EstimationException {\n452: EstimatedParameter[] p = {\n453: new EstimatedParameter(\"unbound0\", 2, false),\n454: new EstimatedParameter(\"unbound1\", 2, false),\n455: new EstimatedParameter(\"bound\",    2, true)\n456: };\n457: LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n458: new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n459: new EstimatedParameter[] { p[0], p[1], p[2] },\n460: 3.0),\n461: new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n462: new EstimatedParameter[] { p[0], p[1], p[2] },\n463: 1.0),\n464: new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },\n465: new EstimatedParameter[] { p[0], p[1], p[2] },\n466: 7.0)\n467: });\n468: 469: GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n470: estimator.estimate(problem);\n471: assertTrue(estimator.getRMS(problem) < 1.0e-10);\n472: double[][] covariances = estimator.getCovariances(problem);\n473: int i0 = 0, i1 = 1;",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 6\nat org.apache.commons.math.estimation.AbstractEstimator.getCovariances(AbstractEstimator.java:173)\nat org.apache.commons.math.estimation.GaussNewtonEstimatorTest.testBoundParameters(GaussNewtonEstimatorTest.java:472)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.estimation.WeightedMeasurement:<init>(DDZ)V",
            "method_body": "public WeightedMeasurement(double weight, double measuredValue,\nboolean ignored) {\nthis.weight        = weight;\nthis.measuredValue = measuredValue;\nthis.ignored       = ignored;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.estimation.WeightedMeasurement:setIgnored(Z)V",
            "method_body": "public abstract double getPartial(EstimatedParameter parameter);\nthis.ignored = ignored;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.estimation.SimpleEstimationProblem:<init>()V",
            "method_body": "public SimpleEstimationProblem() {\nparameters   = new ArrayList();\nmeasurements = new ArrayList();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.estimation.SimpleEstimationProblem:getUnboundParameters()[Lorg/apache/commons/math/estimation/EstimatedParameter;",
            "method_body": "public EstimatedParameter[] getUnboundParameters() {\nList unbound = new ArrayList(parameters.size());\nfor (Iterator iterator = parameters.iterator(); iterator.hasNext();) {\nEstimatedParameter p = (EstimatedParameter) iterator.next();\nif (! p.isBound()) {\nunbound.add(p);\n}\nreturn (EstimatedParameter[]) unbound.toArray(new EstimatedParameter[unbound.size()]);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.estimation.SimpleEstimationProblem:getMeasurements()[Lorg/apache/commons/math/estimation/WeightedMeasurement;",
            "method_body": "public WeightedMeasurement[] getMeasurements() {\nreturn (WeightedMeasurement[]) measurements.toArray(new WeightedMeasurement[measurements.size()]);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.estimation.SimpleEstimationProblem:addParameter(Lorg/apache/commons/math/estimation/EstimatedParameter;)V",
            "method_body": "protected void addParameter(EstimatedParameter p) {\nparameters.add(p);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.estimation.SimpleEstimationProblem:addMeasurement(Lorg/apache/commons/math/estimation/WeightedMeasurement;)V",
            "method_body": "protected void addMeasurement(WeightedMeasurement m) {\nmeasurements.add(m);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.estimation.EstimatedParameter:isBound()Z",
            "method_body": "public boolean isBound() {\nreturn bound;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:add(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\nif (this.getColumnDimension() != m.getColumnDimension() ||\nint rowCount = this.getRowDimension();\nint columnCount = this.getColumnDimension();\ndouble[][] outData = new double[rowCount][columnCount];\nfor (int row = 0; row < rowCount; row++) {\nfor (int col = 0; col < columnCount; col++) {\noutData[row][col] = data[row][col] + m.getEntry(row, col);\nreturn new RealMatrixImpl(outData);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:solve(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\nif (b.getRowDimension() != this.getRowDimension()) {\nif (!this.isSquare()) {\nif (this.isSingular()) { // side effect: compute LU decomp\nint nCol = this.getColumnDimension();\nint nColB = b.getColumnDimension();\nint nRowB = b.getRowDimension();\ndouble[][] bp = new double[nRowB][nColB];\nfor (int row = 0; row < nRowB; row++) {\nfor (int col = 0; col < nColB; col++) {\nbp[row][col] = b.getEntry(permutation[row], col);\nfor (int col = 0; col < nCol; col++) {\nfor (int i = col + 1; i < nCol; i++) {\nfor (int j = 0; j < nColB; j++) {\nbp[i][j] -= bp[col][j] * lu[i][col];\nfor (int col = nCol - 1; col >= 0; col--) {\nfor (int j = 0; j < nColB; j++) {\nbp[col][j] /= lu[col][col];\nfor (int i = 0; i < col; i++) {\nfor (int j = 0; j < nColB; j++) {\nbp[i][j] -= bp[col][j] * lu[i][col];\nRealMatrixImpl outMat = new RealMatrixImpl(bp);\nreturn outMat;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:isSingular()Z",
            "method_body": "public boolean isSingular() {\nif (lu == null) {\nluDecompose();\nreturn false;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:luDecompose()V",
            "method_body": "public void luDecompose() throws InvalidMatrixException {\nint nRows = this.getRowDimension();\nint nCols = this.getColumnDimension();\nif (nRows != nCols) {\nlu = this.getData();\npermutation = new int[nRows];\nfor (int row = 0; row < nRows; row++) {\npermutation[row] = row;\nparity = 1;\nfor (int col = 0; col < nCols; col++) {\ndouble sum = 0;\nfor (int row = 0; row < col; row++) {\nsum = lu[row][col];\nfor (int i = 0; i < row; i++) {\nlu[row][col] = sum;\nint max = col; // permutation row\ndouble largest = 0d;\nfor (int row = col; row < nRows; row++) {\nsum = lu[row][col];\nfor (int i = 0; i < col; i++) {\nsum -= lu[row][i] * lu[i][col];\nlu[row][col] = sum;\nif (Math.abs(sum) > largest) {\nlargest = Math.abs(sum);\nmax = row;\nif (Math.abs(lu[max][col]) < TOO_SMALL) {\nif (max != col) {\nfor (int row = col + 1; row < nRows; row++) {\nlu[row][col] /= lu[col][col];\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn (this.getColumnDimension() == this.getRowDimension());\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nint nRows = this.getRowDimension();\ndouble[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:getEntry(II)D",
            "method_body": "public double getEntry(int row, int column)\nif (!isValidCoordinate(row,column)) {\nreturn data[row][column];\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:isValidCoordinate(II)Z",
            "method_body": "private boolean isValidCoordinate(int row, int col) {\nint nRows = this.getRowDimension();\nint nCols = this.getColumnDimension();\nreturn !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(double[][] subMatrix, int row, int column)\nif ((row < 0) || (column < 0)){\nint nRows = subMatrix.length;\nif (nRows == 0) {\nint nCols = subMatrix[0].length;\nif (nCols == 0) {\nfor (int r = 1; r < nRows; r++) {\nif (subMatrix[r].length != nCols) {\nif (data == null) {\nif ((row > 0)||(column > 0)) throw new MatrixIndexException\ndata = new double[nRows][nCols];\nSystem.arraycopy(subMatrix, 0, data, 0, subMatrix.length);\nif (((nRows + row) > this.getRowDimension()) ||\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\nlu = null;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:copyIn([[D)V",
            "method_body": "private void copyIn(double[][] in) {\nsetSubMatrix(in,0,0);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealMatrixImpl:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn data.length;\n}",
            "method_id": 39
        }
    ]
}