{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution",
    "test_body": "139: public void testUnivariateDistribution() {\n140: final double[] mu = { -1.5 };\n141: final double[][] sigma = { { 1 } };\n142: 143: final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n144: 145: final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\n146: final Random rng = new Random();\n147: final int numCases = 100;\n148: final double tol = Math.ulp(1d);\n149: for (int i = 0; i < numCases; i++) {\n150: final double v = rng.nextDouble() * 10 - 5;\n151: Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n152: }",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.23644016090654427> but was:<0.5926675925866471>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution(MultivariateNormalDistributionTest.java:151)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;I)V",
            "method_body": "protected AbstractMultivariateRealDistribution(RandomGenerator rng,\nint n) {\nrandom = rng;\ndimension = n;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getDeterminant()D",
            "method_body": "public double getDeterminant() {\ndouble determinant = 1;\nfor (double lambda : realEigenvalues) {\ndeterminant *= lambda;\nreturn determinant;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumn(I[D)V",
            "method_body": "public void setColumn(final int column, final double[] array)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (array.length != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, array[i]);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:getInverse()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getInverse() {\nif (!isNonSingular()) {\nfinal int m = realEigenvalues.length;\nfinal double[][] invData = new double[m][m];\nfor (int i = 0; i < m; ++i) {\nfinal double[] invI = invData[i];\nfor (int j = 0; j < m; ++j) {\ndouble invIJ = 0;\nfor (int k = 0; k < m; ++k) {\nfinal double[] vK = eigenvectors[k].getDataRef();\ninvIJ += vK[i] * vK[j] / realEigenvalues[k];\ninvI[j] = invIJ;\nreturn MatrixUtils.createRealMatrix(invData);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:hasComplexEigenvalues()Z",
            "method_body": "public boolean hasComplexEigenvalues() {\nfor (int i = 0; i < imagEigenvalues.length; i++) {\nif (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\nreturn false;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getEigenvector(I)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector getEigenvector(final int i) {\nreturn eigenvectors[i].copy();\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getSolver()Lorg/apache/commons/math3/linear/DecompositionSolver;",
            "method_body": "public DecompositionSolver getSolver() {\nif (hasComplexEigenvalues()) {\nreturn new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:<init>([D[D[Lorg/apache/commons/math3/linear/ArrayRealVector;)V",
            "method_body": "private Solver(final double[] realEigenvalues,\nfinal ArrayRealVector[] eigenvectors) {\nthis.realEigenvalues = realEigenvalues;\nthis.imagEigenvalues = imagEigenvalues;\nthis.eigenvectors = eigenvectors;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:isNonSingular()Z",
            "method_body": "public boolean isNonSingular() {\nfor (int i = 0; i < realEigenvalues.length; ++i) {\nif (realEigenvalues[i] == 0 &&\nreturn true;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getRealEigenvalues()[D",
            "method_body": "public double[] getRealEigenvalues() {\nreturn realEigenvalues.clone();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:transformToTridiagonal(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void transformToTridiagonal(final RealMatrix matrix) {\ntransformer = new TriDiagonalTransformer(matrix);\nmain = transformer.getMainDiagonalRef();\nsecondary = transformer.getSecondaryDiagonalRef();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getMainDiagonalRef()[D",
            "method_body": "double[] getMainDiagonalRef() {\nreturn main;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getSecondaryDiagonalRef()[D",
            "method_body": "double[] getSecondaryDiagonalRef() {\nreturn secondary;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public EigenDecomposition(final RealMatrix matrix)\nthrows MathArithmeticException {\nfinal double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\nisSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\nif (isSymmetric) {\ntransformToTridiagonal(matrix);\nfindEigenVectors(transformer.getQ().getData());\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:findEigenVectors([[D)V",
            "method_body": "private void findEigenVectors(final double[][] householderMatrix) {\nfinal double[][]z = householderMatrix.clone();\nfinal int n = main.length;\nrealEigenvalues = new double[n];\nimagEigenvalues = new double[n];\nfinal double[] e = new double[n];\nfor (int i = 0; i < n - 1; i++) {\nrealEigenvalues[n - 1] = main[n - 1];\ne[n - 1] = 0;\ndouble maxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\nif (FastMath.abs(e[i]) > maxAbsoluteValue) {\nif (maxAbsoluteValue != 0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\nif (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\ne[i]=0;\nfor (int j = 0; j < n; j++) {\nint its = 0;\nfor (m = j; m < n - 1; m++) {\nif (m != j) {\n} while (m != j);\nfor (int i = 0; i < n; i++) {\nint k = i;\ndouble p = realEigenvalues[i];\nfor (int j = i + 1; j < n; j++) {\nif (k != i) {\nmaxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\nif (maxAbsoluteValue != 0.0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\neigenvectors = new ArrayRealVector[n];\nfinal double[] tmp = new double[n];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[j] = z[j][i];\neigenvectors[i] = new ArrayRealVector(tmp);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetric(Lorg/apache/commons/math3/linear/RealMatrix;D)Z",
            "method_body": "public static boolean isSymmetric(RealMatrix matrix,\nreturn isSymmetricInternal(matrix, eps, false);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQ()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQ() {\nif (cachedQ == null) {\ncachedQ = getQT().transpose();\nreturn cachedQ;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetricInternal(Lorg/apache/commons/math3/linear/RealMatrix;DZ)Z",
            "method_body": "private static boolean isSymmetricInternal(RealMatrix matrix,\nfinal int rows = matrix.getRowDimension();\nif (rows != matrix.getColumnDimension()) {\nfor (int i = 0; i < rows; i++) {\nfor (int j = i + 1; j < rows; j++) {\nreturn true;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:transform()V",
            "method_body": "private void transform() {\nfinal int m = householderVectors.length;\nfinal double[] z = new double[m];\nfor (int k = 0; k < m - 1; k++) {\nmain[m - 1] = householderVectors[m - 1][m - 1];\n}",
            "method_id": 39
        }
    ]
}