{
    "bug_id": 77,
    "test_id": 0,
    "test_name": "org.apache.commons.math.linear.SparseRealVectorTest.testBasicFunctions",
    "test_body": "950: public void testBasicFunctions() {\n951: OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n952: OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n953: OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n954: OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n955: 956: SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n957: 958: // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n959: double d_getNorm = v5.getNorm();\n960: assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n961: 962: // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n963: double d_getL1Norm = v5.getL1Norm();\n964: assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n965: 966: // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n967: double d_getLInfNorm = v5.getLInfNorm();\n968: assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n969: 970: //octave =  sqrt(sumsq(v1-v2))\n971: double dist = v1.getDistance(v2);\n972: assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n973: 974: //octave =  sqrt(sumsq(v1-v2))\n975: double dist_2 = v1.getDistance(v2_t);\n976: assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n977: 978: //octave =  ???\n979: double d_getL1Distance = v1. getL1Distance(v2);\n980: assertEquals(\"compare values  \",9d, d_getL1Distance );\n981: 982: double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n983: assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n984: 985: //octave =  ???\n986: double d_getLInfDistance = v1. getLInfDistance(v2);\n987: assertEquals(\"compare values  \",3d, d_getLInfDistance );\n988: 989: double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n990: assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n991: 992: //octave =  v1 + v2\n993: OpenMapRealVector v_add = v1.add(v2);\n994: double[] result_add = {5d, 7d, 9d};\n995: assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n996: 997: SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n998: RealVector v_add_i = v1.add(vt2);\n999: double[] result_add_i = {5d, 7d, 9d};\n1000: assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n1001: 1002: //octave =  v1 - v2\n1003: OpenMapRealVector v_subtract = v1.subtract(v2);\n1004: double[] result_subtract = {-3d, -3d, -3d};\n1005: assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n1006: 1007: RealVector v_subtract_i = v1.subtract(vt2);\n1008: double[] result_subtract_i = {-3d, -3d, -3d};\n1009: assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n1010: 1011: // octave v1 .* v2\n1012: RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n1013: double[] result_ebeMultiply = {4d, 10d, 18d};\n1014: assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n1015: 1016: RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n1017: double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n1018: assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n1019: 1020: // octave v1 ./ v2\n1021: RealVector  v_ebeDivide = v1.ebeDivide(v2);\n1022: double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n1023: assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n1024: 1025: RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n1026: double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n1027: assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n1028: 1029: // octave  dot(v1,v2)\n1030: double dot =  v1.dotProduct(v2);\n1031: assertEquals(\"compare val \",32d, dot);\n1032: 1033: // octave  dot(v1,v2_t)\n1034: double dot_2 =  v1.dotProduct(v2_t);\n1035: assertEquals(\"compare val \",32d, dot_2);\n1036: 1037: RealMatrix m_outerProduct = v1.outerProduct(v2);\n1038: assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n1039: 1040: RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n1041: assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n1042: 1043: RealVector v_unitVector = v1.unitVector();\n1044: RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n1045: assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n1046: 1047: try {\n1048: v_null.unitVector();\n1049: fail(\"Expecting ArithmeticException\");\n1050: } catch (ArithmeticException ex) {\n1051: // expected behavior\n1052: } catch (Exception e) {\n1053: fail(\"wrong exception caught\");\n1054: }\n1055: 1056: OpenMapRealVector v_unitize = v1.copy();\n1057: v_unitize.unitize();\n1058: assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n1059: try {\n1060: v_null.unitize();\n1061: fail(\"Expecting ArithmeticException\");\n1062: } catch (ArithmeticException ex) {\n1063: // expected behavior\n1064: } catch (Exception e) {\n1065: fail(\"wrong exception caught\");\n1066: }\n1067: 1068: RealVector v_projection = v1.projection(v2);\n1069: double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n1070: assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n1071: 1072: RealVector v_projection_2 = v1.projection(v2_t);\n1073: double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n1074: assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n1075: 1076: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.TestCase.assertEquals(TestCase.java:244)\nat org.apache.commons.math.linear.SparseRealVectorTest.testBasicFunctions(SparseRealVectorTest.java:968)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector:getLInfNorm()D",
            "method_body": "public double getLInfNorm() {\ndouble max = 0;\nIterator iter = entries.iterator();\nwhile (iter.hasNext()) {\niter.advance();\nmax += iter.value();\nreturn max;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector:sparseIterator()Ljava/util/Iterator;",
            "method_body": "public java.util.Iterator<Entry> sparseIterator() {\nreturn new OpenMapSparseIterator();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector:isDefaultValue(D)Z",
            "method_body": "protected boolean isDefaultValue(double value) {\nreturn Math.abs(value) < epsilon;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator:value()D",
            "method_body": "public double value()\nif (referenceCount != count) {\nif (current < 0) {\nreturn values[current];\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector:<init>([DD)V",
            "method_body": "public OpenMapRealVector(double[] values, double epsilon) {\nvirtualSize = values.length;\nentries = new OpenIntToDoubleHashMap(0.0);\nthis.epsilon = epsilon;\nfor (int key = 0; key < values.length; key++) {\ndouble value = values[key];\nif (!isDefaultValue(value)) {\nentries.put(key, value);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:put(ID)D",
            "method_body": "public double put(final int key, final double value) {\nint index = findInsertionIndex(key);\ndouble previous = missingEntries;\nboolean newMapping = true;\nif (index < 0) {\nkeys[index]   = key;\nstates[index] = FULL;\nvalues[index] = value;\nif (newMapping) {\n++size;\nif (shouldGrowTable()) {\n++count;\nreturn previous;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator:hasNext()Z",
            "method_body": "public boolean hasNext() {\nreturn next >= 0;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:iterator()Lorg/apache/commons/math/util/OpenIntToDoubleHashMap$Iterator;",
            "method_body": "public Iterator iterator() {\nreturn new Iterator();\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:findInsertionIndex([I[BII)I",
            "method_body": "private static int findInsertionIndex(final int[] keys, final byte[] states,\nfinal int hash = hashOf(key);\nint index = hash & mask;\nif (states[index] == FREE) {\nreturn index;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:hashOf(I)I",
            "method_body": "private static int hashOf(final int key) {\nfinal int h = key ^ ((key >>> 20) ^ (key >>> 12));\nreturn h ^ (h >>> 7) ^ (h >>> 4);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator:advance()V",
            "method_body": "public void advance()\nif (referenceCount != count) {\ncurrent = next;\nwhile (states[++next] != FULL) {\n} catch (ArrayIndexOutOfBoundsException e) {\nnext = -2;\nif (current < 0) {\n}\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:shouldGrowTable()Z",
            "method_body": "private boolean shouldGrowTable() {\nreturn size > (mask + 1) * LOAD_FACTOR;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:findInsertionIndex(I)I",
            "method_body": "private int findInsertionIndex(final int key) {\nreturn findInsertionIndex(keys, states, key, mask);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector:<init>([D)V",
            "method_body": "public OpenMapRealVector(double[] values) {\nthis(values, DEFAULT_ZERO_TOLERANCE);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator:<init>(Lorg/apache/commons/math/util/OpenIntToDoubleHashMap;)V",
            "method_body": "private Iterator() {\nreferenceCount = count;\nnext = -1;\nadvance();\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealVector:getNorm()D",
            "method_body": "public double getNorm() {\ndouble sum = 0;\nIterator<Entry> it = sparseIterator();\nwhile (it.hasNext() && (e = it.next()) != null) {\nfinal double value = e.getValue();\nsum += value * value;\n}\nreturn Math.sqrt(sum);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealVector:getL1Norm()D",
            "method_body": "public double getL1Norm() {\ndouble norm = 0;\nIterator<Entry> it = sparseIterator();\nwhile (it.hasNext() && (e = it.next()) != null) {\nnorm += Math.abs(e.getValue());\nreturn norm;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector$OpenMapSparseIterator:<init>(Lorg/apache/commons/math/linear/OpenMapRealVector;)V",
            "method_body": "protected OpenMapSparseIterator() {\niter = entries.iterator();\ncurrent = new OpenMapEntry(iter);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector$OpenMapSparseIterator:hasNext()Z",
            "method_body": "public boolean hasNext() {\nreturn iter.hasNext();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.linear.OpenMapRealVector$OpenMapSparseIterator:next()Lorg/apache/commons/math/linear/RealVector$Entry;",
            "method_body": "public Entry next() {\niter.advance();\nreturn current;\n}",
            "method_id": 19
        }
    ]
}