{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "136: public void polynomial() throws DerivativeException, IntegratorException {\n137: TestProblem6 pb = new TestProblem6();\n138: double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n139: 140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\n141: AdamsMoultonIntegrator integ =\n142: new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n143: TestProblemHandler handler = new TestProblemHandler(pb, integ);\n144: integ.addStepHandler(handler);\n145: integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n146: pb.getFinalTime(), new double[pb.getDimension()]);\n147: if (nSteps < 4) {\n148: assertTrue(integ.getEvaluations() > 140);\n149: } else {\n150: assertTrue(integ.getEvaluations() < 90);\n151: }",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:reinitialize([DZ)V",
            "method_body": "public void reinitialize(final double[] y, final boolean forward) {\nsuper.reinitialize(y, forward);\nstateVariation = new double[y.length];\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nsuper(100, 1E-6);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:<init>(IDDDD)V",
            "method_body": "public AdamsMoultonIntegrator(final int nSteps,\nsuper(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nfor (EventState state : states) {\nstate.stepAccepted(t, y);\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:start(IIIIII)V",
            "method_body": "public void start(int rows, int columns,\nArrays.fill(after, 0.0);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:visit(IID)V",
            "method_body": "public void visit(int row, int column, double value)\nif ((row & 0x1) == 0) {\nafter[column] -= value;\nafter[column] += value;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:end()D",
            "method_body": "public double end() {\ndouble error = 0;\nfor (int i = 0; i < after.length; ++i) {\nafter[i] += previous[i] + scaled[i];\nfinal double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\nfinal double ratio  = (after[i] - before[i]) / tol;\nerror += ratio * ratio;\nreturn Math.sqrt(error / after.length);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:computeStepGrowShrinkFactor(D)D",
            "method_body": "protected double computeStepGrowShrinkFactor(final double error) {\nreturn Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:initializeHighOrderDerivatives([D[[D)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\nreturn transformer.initializeHighOrderDerivatives(first, multistep);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:updateHighOrderDerivativesPhase1(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\nreturn transformer.updateHighOrderDerivativesPhase1(highOrder);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:updateHighOrderDerivativesPhase2([D[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void updateHighOrderDerivativesPhase2(final double[] start,\ntransformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:initializeHighOrderDerivatives([D[[D)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\nfor (int i = 0; i < multistep.length; ++i) {\nfinal double[] msI = multistep[i];\nfor (int j = 0; j < first.length; ++j) {\nmsI[j] -= first[j];\nreturn initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:updateHighOrderDerivativesPhase1(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\nreturn update.multiply(highOrder);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:updateHighOrderDerivativesPhase2([D[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void updateHighOrderDerivativesPhase2(final double[] start,\nfinal double[][] data = highOrder.getDataRef();\nfor (int i = 0; i < data.length; ++i) {\nfinal double[] dataI = data[i];\nfinal double c1I = c1[i];\nfor (int j = 0; j < dataI.length; ++j) {\ndataI[j] += c1I * (start[j] - end[j]);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\nfinal double x = interpolatedTime - referenceTime;\nfinal double normalizedAbscissa = x / scalingH;\nArrays.fill(stateVariation, 0.0);\nArrays.fill(interpolatedDerivatives, 0.0);\nfinal double[][] nData = nordsieck.getDataRef();\nfor (int i = nData.length - 1; i >= 0; --i) {\nfinal int order = i + 2;\nfinal double[] nDataI = nData[i];\nfinal double power = Math.pow(normalizedAbscissa, order);\nfor (int j = 0; j < nDataI.length; ++j) {\nfinal double d = nDataI[j] * power;\nstateVariation[j]          += d;\ninterpolatedDerivatives[j] += order * d;\nfor (int j = 0; j < currentState.length; ++j) {\nstateVariation[j] += scaled[j] * normalizedAbscissa;\ninterpolatedState[j] = currentState[j] + stateVariation[j];\ninterpolatedDerivatives[j] =\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer:handleStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;Z)V",
            "method_body": "RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\npublic NordsieckInitializer(final int n) {\nthis.n = n;\n}\nfinal double prev = interpolator.getPreviousTime();\nfinal double curr = interpolator.getCurrentTime();\nstepStart = prev;\nstepSize  = (curr - prev) / (nSteps + 1);\ninterpolator.setInterpolatedTime(prev);\nscaled = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nscaled[j] *= stepSize;\nfinal double[][] multistep = new double[nSteps][];\nfor (int i = 1; i <= nSteps; ++i) {\ninterpolator.setInterpolatedTime(prev + stepSize * i);\nfinal double[] msI = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nmsI[j] *= stepSize;\nmultistep[i - 1] = msI;\nnordsieck = initializeHighOrderDerivatives(scaled, multistep);\nthrow new InitializationCompletedMarkerException();\nreturn true;\n}\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$InitializationCompletedMarkerException:<init>()V",
            "method_body": "public InitializationCompletedMarkerException() {\nsuper((Throwable) null);\n}",
            "method_id": 39
        }
    ]
}