{
    "bug_id": 49,
    "test_id": 0,
    "test_name": "org.apache.commons.math.linear.SparseRealVectorTest.testConcurrentModification",
    "test_body": "1004: public void testConcurrentModification() {\n1005: final RealVector u = new OpenMapRealVector(3, 1e-6);\n1006: u.setEntry(0, 1);\n1007: u.setEntry(1, 0);\n1008: u.setEntry(2, 2);\n1009: 1010: final RealVector v1 = new OpenMapRealVector(3, 1e-6);\n1011: final double[] v2 = new double[3];\n1012: v1.setEntry(0, 0);\n1013: v2[0] = 0;\n1014: v1.setEntry(1, 3);\n1015: v2[1] = 3;\n1016: v1.setEntry(2, 0);\n1017: v2[2] = 0;\n1018: 1019: RealVector w;\n1020: 1021: w = u.ebeMultiply(v1);\n1022: w = u.ebeMultiply(v2);",
    "stack_trace": "org.apache.commons.math.MathRuntimeException$6: map has been modified while iterating\nat org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373)\nat org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.advance(OpenIntToDoubleHashMap.java:564)\nat org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372)\nat org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:33)\nat org.apache.commons.math.linear.SparseRealVectorTest.testConcurrentModification(SparseRealVectorTest.java:1021)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:remove(I)D",
            "method_body": "public double remove(final int key) {\nfinal int hash  = hashOf(key);\nint index = hash & mask;\nif (containsKey(key, index)) {\nreturn doRemove(index);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:<init>(D)V",
            "method_body": "public OpenIntToDoubleHashMap(final double missingEntries) {\nthis(DEFAULT_EXPECTED_SIZE, missingEntries);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:get(I)D",
            "method_body": "public double get(final int key) {\nfinal int hash  = hashOf(key);\nint index = hash & mask;\nif (containsKey(key, index)) {\nif (states[index] == FREE) {\nreturn missingEntries;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:containsKey(II)Z",
            "method_body": "private boolean containsKey(final int key, final int index) {\nreturn (key != 0 || states[index] == FULL) && keys[index] == key;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:findInsertionIndex(I)I",
            "method_body": "private int findInsertionIndex(final int key) {\nreturn findInsertionIndex(keys, states, key, mask);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:findInsertionIndex([I[BII)I",
            "method_body": "private static int findInsertionIndex(final int[] keys, final byte[] states,\nfinal int hash = hashOf(key);\nint index = hash & mask;\nif (states[index] == FREE) {\nreturn index;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:put(ID)D",
            "method_body": "public double put(final int key, final double value) {\nint index = findInsertionIndex(key);\ndouble previous = missingEntries;\nboolean newMapping = true;\nif (index < 0) {\nkeys[index]   = key;\nstates[index] = FULL;\nvalues[index] = value;\nif (newMapping) {\n++size;\nif (shouldGrowTable()) {\n++count;\nreturn previous;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:shouldGrowTable()Z",
            "method_body": "private boolean shouldGrowTable() {\nreturn size > (mask + 1) * LOAD_FACTOR;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:<init>(ID)V",
            "method_body": "public OpenIntToDoubleHashMap(final int expectedSize,\nfinal double missingEntries) {\nfinal int capacity = computeCapacity(expectedSize);\nkeys   = new int[capacity];\nvalues = new double[capacity];\nstates = new byte[capacity];\nthis.missingEntries = missingEntries;\nmask   = capacity - 1;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:computeCapacity(I)I",
            "method_body": "private static int computeCapacity(final int expectedSize) {\nif (expectedSize == 0) {\nfinal int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\nfinal int powerOfTwo = Integer.highestOneBit(capacity);\nif (powerOfTwo == capacity) {\nreturn capacity;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap:hashOf(I)I",
            "method_body": "private static int hashOf(final int key) {\nfinal int h = key ^ ((key >>> 20) ^ (key >>> 12));\nreturn h ^ (h >>> 7) ^ (h >>> 4);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:ceil(D)D",
            "method_body": "public static double ceil(double x) {\nif (x != x) { // NaN\ny = floor(x);\nif (y == x) {\nreturn y;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:floor(D)D",
            "method_body": "public static double floor(double x) {\nif (x != x) { // NaN\nif (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\ny = (long) x;\nif (x < 0 && y != x) {\nif (y == 0) {\nreturn y;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.MathRuntimeException$6:<init>(Lorg/apache/commons/math/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public static ConcurrentModificationException createConcurrentModificationException(final Localizable pattern,\nreturn new ConcurrentModificationException() {\n}",
            "method_id": 34
        }
    ]
}