{
    "bug_id": 21,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest.testMath789",
    "test_body": "public void testMath789() {\n78: final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{\n{0.013445532, 0.010394690, 0.009881156, 0.010499559},\n{0.010394690, 0.023006616, 0.008196856, 0.010732709},\n{0.009881156, 0.008196856, 0.019023866, 0.009210099},\n{0.010499559, 0.010732709, 0.009210099, 0.019107243}\n});\nRealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix();\nRealMatrix rebuiltM1 = root1.multiply(root1.transpose());\nAssert.assertEquals(0.0, m1.subtract(rebuiltM1).getNorm(), 1.0e-16);\n88: final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{\n{0.0, 0.0, 0.0, 0.0, 0.0},\n{0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n{0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n{0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n{0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n});\nRealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix();\nRealMatrix rebuiltM2 = root2.multiply(root2.transpose());\nAssert.assertEquals(0.0, m2.subtract(rebuiltM2).getNorm(), 1.0e-16);\n99: final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{\n{0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n{0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n{0.0, 0.0, 0.0, 0.0, 0.0},\n{0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n{0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n});\nRealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix();\nRealMatrix rebuiltM3 = root3.multiply(root3.transpose());\nAssert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16);\n110: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.0> but was:<0.0180652917341963>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest.testMath789(RectangularCholeskyDecompositionTest.java:108)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.RectangularCholeskyDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;D)V",
            "method_body": "public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\nthrows NonPositiveDefiniteMatrixException {\nfinal int order = matrix.getRowDimension();\nfinal double[][] c = matrix.getData();\nfinal double[][] b = new double[order][order];\nint[] swap  = new int[order];\nint[] index = new int[order];\nfor (int i = 0; i < order; ++i) {\nindex[i] = i;\nint r = 0;\nfor (boolean loop = true; loop;) {\nswap[r] = r;\nfor (int i = r + 1; i < order; ++i) {\nint ii  = index[i];\nint isi = index[swap[i]];\nif (c[ii][ii] > c[isi][isi]) {\nswap[r] = i;\nif (swap[r] != r) {\nint tmp = index[r];\nindex[r] = index[swap[r]];\nindex[swap[r]] = tmp;\nint ir = index[r];\nif (c[ir][ir] < small) {\nif (r == 0) {\nfor (int i = r; i < order; ++i) {\nif (c[index[i]][index[i]] < -small) {\n++r;\nloop = false;\nfinal double sqrt = FastMath.sqrt(c[ir][ir]);\nb[r][r] = sqrt;\nfinal double inverse  = 1 / sqrt;\nfor (int i = r + 1; i < order; ++i) {\nfinal int ii = index[i];\nfinal double e = inverse * c[ii][ir];\nb[i][r] = e;\nc[ii][ii] -= e * e;\nfor (int j = r + 1; j < i; ++j) {\nfinal int ij = index[j];\nfinal double f = c[ii][ij] - e * b[j][r];\nc[ii][ij] = f;\nc[ij][ii] = f;\nloop = ++r < order;\n}\nrank = r;\nroot = MatrixUtils.createRealMatrix(order, r);\nfor (int i = 0; i < order; ++i) {\nfor (int j = 0; j < r; ++j) {\nroot.setEntry(index[i], j, b[i][j]);\n}",
            "method_id": 0,
            "loc": 49
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(final double[][] subMatrix,\nif (data == null) {\nif (row > 0) {\nif (column > 0) {\nMathUtils.checkNotNull(subMatrix);\nfinal int nRows = subMatrix.length;\nif (nRows == 0) {\nfinal int nCols = subMatrix[0].length;\nif (nCols == 0) {\ndata = new double[subMatrix.length][nCols];\nfor (int i = 0; i < data.length; ++i) {\nif (subMatrix[i].length != nCols) {\nSystem.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n} else {\n}",
            "method_id": 1,
            "loc": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m) {\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\nout.setEntry(row, col, sum);\nreturn out;\n}",
            "method_id": 2,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getNorm()D",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 3,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$1:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;)V",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 4,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$1:start(IIIIII)V",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 5,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$1:visit(IID)V",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 6,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$1:end()D",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 7,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m) {\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 8,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 9,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 10,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 11,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 12,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInColumnOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int j = 0; j < columns; ++j) {\nfor (int i = 0; i < rows; ++i) {\nvisitor.visit(i, j, data[i][j]);\nreturn visitor.end();\n}",
            "method_id": 13,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:transpose()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 14,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 15,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data)\nif (data == null ||\nreturn (data.length * data[0].length <= 4096) ?\n}",
            "method_id": 16,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 17,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\nif (rowDimension < 1) {\nif (columnDimension < 1) {\n}",
            "method_id": 18,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 19,
            "loc": 4
        }
    ]
}