{
    "bug_id": 23,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testKeepInitIfBest",
    "test_body": "public void testKeepInitIfBest() {\nfinal double minSin = 3 * Math.PI / 2;\nfinal double offset = 1e-8;\nfinal double delta = 1e-7;\nfinal UnivariateFunction f1 = new Sin();\nfinal UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\nnew double[] { 0, -1, 0 });\nfinal UnivariateFunction f = FunctionUtils.add(f1, f2);\n// A slightly less stringent tolerance would make the test pass\n// even with the previous implementation.\nfinal double relTol = 1e-8;\nfinal UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\nfinal double init = minSin + 1.5 * offset;\nfinal UnivariatePointValuePair result\n= optimizer.optimize(200, f, GoalType.MINIMIZE,\nminSin - 6.789 * delta,\nminSin + 9.876 * delta,\ninit);\nfinal int numEval = optimizer.getEvaluations();\n213: final double sol = result.getPoint();\nfinal double expected = init;\n216: //         System.out.println(\"numEval=\" + numEval);\n//         System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n//         System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n//         System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n221: Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Best point not reported\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testKeepInitIfBest(BrentOptimizerTest.java:221)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 40,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemA()D",
            "method_body": "double getRemA() {\nreturn finalRemA;\n}",
            "method_id": 41,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\n}",
            "method_id": 42,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 43,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.function.Sin:value(D)D",
            "method_body": "public double value(double x) {\nreturn FastMath.sin(x);\n}",
            "method_id": 44,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemB()D",
            "method_body": "double getRemB() {\nreturn finalRemB;\n}",
            "method_id": 45,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getMax()D",
            "method_body": "public double getMax() {\nreturn searchMax;\n}",
            "method_id": 46,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optimization/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 47,
            "loc": 3
        }
    ]
}