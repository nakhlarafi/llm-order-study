{
    "bug_id": 38,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints",
    "test_body": "public void testConstrainedRosenWithMoreInterpolationPoints() {\nfinal double[] startPoint = point(DIM, 0.1);\nfinal double[][] boundaries = boundaries(DIM, -1, 2);\nfinal RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n247: // This should have been 78 because in the code the hard limit is\n// said to be\n//   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n// i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n// 65, 66, ...\nfinal int maxAdditionalPoints = 47;\n254: for (int num = 1; num <= maxAdditionalPoints; num++) {\ndoTest(new Rosen(), startPoint, boundaries,\nGoalType.MINIMIZE,",
    "stack_trace": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException: If this exception is thrown, just remove it from the code prelim (at line 1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim(BOBYQAOptimizer.java:1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqb(BOBYQAOptimizer.java:407)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqa(BOBYQAOptimizer.java:332)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.doOptimize(BOBYQAOptimizer.java:244)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(BaseAbstractMultivariateOptimizer.java:125)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(BaseAbstractMultivariateSimpleBoundsOptimizer.java:138)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.doTest(BOBYQAOptimizerTest.java:327)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints(BOBYQAOptimizerTest.java:255)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>(I)V",
            "method_body": "public ArrayRealVector(int size) {\ndata = new double[size];\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start.clone();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value) {\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:prelim([D[D)V",
            "method_body": "private void prelim(double[] lowerBound,\nprintMethod(); // XXX\nfinal int n = currentBest.getDimension();\nfinal int npt = numberOfInterpolationPoints;\nfinal int ndim = bMatrix.getRowDimension();\nfinal double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\nfinal double recip = 1d / rhosq;\nfinal int np = n + 1;\nfor (int j = 0; j < n; j++) {\noriginShift.setEntry(j, currentBest.getEntry(j));\nfor (int k = 0; k < npt; k++) {\ninterpolationPoints.setEntry(k, j, ZERO);\nfor (int i = 0; i < ndim; i++) {\nbMatrix.setEntry(i, j, ZERO);\nfor (int i = 0, max = n * np / 2; i < max; i++) {\nmodelSecondDerivativesValues.setEntry(i, ZERO);\nfor (int k = 0; k < npt; k++) {\nmodelSecondDerivativesParameters.setEntry(k, ZERO);\nfor (int j = 0, max = npt - np; j < max; j++) {\nzMatrix.setEntry(k, j, ZERO);\nint ipt = 0;\nint jpt = 0;\ndouble fbeg = Double.NaN;\nfinal int nfm = getEvaluations();\nfinal int nfx = nfm - n;\nfinal int nfmm = nfm - 1;\nfinal int nfxm = nfx - 1;\ndouble stepa = 0;\ndouble stepb = 0;\nif (nfm <= 2 * n) {\nif (nfm >= 1 &&\nstepa = initialTrustRegionRadius;\nif (upperDifference.getEntry(nfmm) == ZERO) {\ninterpolationPoints.setEntry(nfm, nfmm, stepa);\n} else if (nfm > n) {\nstepa = interpolationPoints.getEntry(nfx, nfxm);\nstepb = -initialTrustRegionRadius;\nif (lowerDifference.getEntry(nfxm) == ZERO) {\nif (upperDifference.getEntry(nfxm) == ZERO) {\ninterpolationPoints.setEntry(nfm, nfxm, stepb);\nfinal int tmp1 = (nfm - np) / n;\njpt = nfm - tmp1 * n - n;\nipt = jpt + tmp1;\nif (ipt > n) {\nfinal int iptMinus1 = ipt;\nfinal int jptMinus1 = jpt;\ninterpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\ninterpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\nfor (int j = 0; j < n; j++) {\ncurrentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\nif (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\nif (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\nfinal double objectiveValue = computeObjectiveValue(currentBest.toArray());\nfinal double f = isMinimize ? objectiveValue : -objectiveValue;\nfinal int numEval = getEvaluations(); // nfm + 1\nfAtInterpolationPoints.setEntry(nfm, f);\nif (numEval == 1) {\nfbeg = f;\ntrustRegionCenterInterpolationPointIndex = 0;\n} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\nif (numEval <= 2 * n + 1) {\nif (numEval >= 2 &&\ngradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\nif (npt < numEval + n) {\n} else if (numEval >= n + 2) {\nfinal int ih = nfx * (nfx + 1) / 2 - 1;\nfinal double tmp = (f - fbeg) / stepb;\nfinal double diff = stepb - stepa;\nmodelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\ngradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\nif (stepa * stepb < ZERO) {\nif (f < fAtInterpolationPoints.getEntry(nfm - n)) {\nfAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\nfAtInterpolationPoints.setEntry(nfm - n, f);\nif (trustRegionCenterInterpolationPointIndex == nfm) {\ninterpolationPoints.setEntry(nfm - n, nfxm, stepb);\ninterpolationPoints.setEntry(nfm, nfxm, stepa);\nbMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\nbMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\nbMatrix.setEntry(nfm - n, nfxm,\nzMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\nzMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\nzMatrix.setEntry(nfm - n, nfxm,\n}\nzMatrix.setEntry(0, nfxm, recip);\nzMatrix.setEntry(nfm, nfxm, recip);\nzMatrix.setEntry(ipt, nfxm, -recip);\nzMatrix.setEntry(jpt, nfxm, -recip);\nfinal int ih = ipt * (ipt - 1) / 2 + jpt - 1;\nfinal double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\nmodelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\nthrow new PathIsExploredException(); // XXX\n} while (getEvaluations() < npt);\n} // prelim",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.optimization.AbstractConvergenceChecker:<init>()V",
            "method_body": "public AbstractConvergenceChecker() {\nthis.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\nthis.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getGoalType()Lorg/apache/commons/math/optimization/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound.clone();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:<init>(Lorg/apache/commons/math/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\nthis.checker = checker;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(ILorg/apache/commons/math/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\nif (rowDimension < 1) {\nif (columnDimension < 1) {\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:optimize(ILorg/apache/commons/math/analysis/MultivariateFunction;Lorg/apache/commons/math/optimization/GoalType;[D[D[D)Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\nfinal int dim = startPoint.length;\nif (lower != null) {\nif (lower.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double lo = lower[i];\nif (v < lo) {\nif (upper != null) {\nif (upper.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double hi = upper[i];\nif (v > hi) {\nif (lower == null) {\nlowerBound = lower.clone();\nif (upper == null) {\nupperBound = upper.clone();\nreturn super.optimize(maxEval, f, goalType, startPoint);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.optimization.RealPointValuePair:<init>([DD)V",
            "method_body": "public RealPointValuePair(final double[] point, final double value) {\nthis.point = (point == null) ? null : point.clone();\nthis.value = value;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:getEntry(I)D",
            "method_body": "public double getEntry(int index) {\nreturn data[index];\n}",
            "method_id": 39
        }
    ]
}