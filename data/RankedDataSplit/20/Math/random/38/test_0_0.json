{
    "bug_id": 38,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints",
    "test_body": "public void testConstrainedRosenWithMoreInterpolationPoints() {\nfinal double[] startPoint = point(DIM, 0.1);\nfinal double[][] boundaries = boundaries(DIM, -1, 2);\nfinal RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n247: // This should have been 78 because in the code the hard limit is\n// said to be\n//   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n// i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n// 65, 66, ...\nfinal int maxAdditionalPoints = 47;\n254: for (int num = 1; num <= maxAdditionalPoints; num++) {\ndoTest(new Rosen(), startPoint, boundaries,\nGoalType.MINIMIZE,",
    "stack_trace": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException: If this exception is thrown, just remove it from the code prelim (at line 1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim(BOBYQAOptimizer.java:1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqb(BOBYQAOptimizer.java:407)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqa(BOBYQAOptimizer.java:332)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.doOptimize(BOBYQAOptimizer.java:244)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(BaseAbstractMultivariateOptimizer.java:125)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(BaseAbstractMultivariateSimpleBoundsOptimizer.java:138)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.doTest(BOBYQAOptimizerTest.java:327)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints(BOBYQAOptimizerTest.java:255)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:optimize(ILorg/apache/commons/math/analysis/MultivariateFunction;Lorg/apache/commons/math/optimization/GoalType;[D)Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\nif (f == null) {\nif (goalType == null) {\nif (startPoint == null) {\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\nfunction = f;\ngoal = goalType;\nstart = startPoint.clone();\nreturn doOptimize();\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:toArray()[D",
            "method_body": "public double[] toArray(){\nreturn data.clone();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:<init>(IDD)V",
            "method_body": "public BOBYQAOptimizer(int numberOfInterpolationPoints,\ndouble stoppingTrustRegionRadius) {\nthis.numberOfInterpolationPoints = numberOfInterpolationPoints;\nthis.initialTrustRegionRadius = initialTrustRegionRadius;\nthis.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:<init>(I)V",
            "method_body": "public BOBYQAOptimizer(int numberOfInterpolationPoints) {\nthis(numberOfInterpolationPoints,\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound.clone();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column) {\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:<init>()V",
            "method_body": "protected BaseAbstractMultivariateOptimizer() {\nthis(new SimpleScalarValueChecker());\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row) {\nif (row < 0 ||\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException:<init>()V",
            "method_body": "PathIsExploredException() {\nsuper(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:bobyqb([D[D)D",
            "method_body": "private double bobyqb(double[] lowerBound,\nprintMethod(); // XXX\nfinal int n = currentBest.getDimension();\nfinal int npt = numberOfInterpolationPoints;\nfinal int np = n + 1;\nfinal int nptm = npt - np;\nfinal int nh = n * np / 2;\nfinal ArrayRealVector work1 = new ArrayRealVector(n);\nfinal ArrayRealVector work2 = new ArrayRealVector(npt);\nfinal ArrayRealVector work3 = new ArrayRealVector(npt);\ndouble cauchy = Double.NaN;\ndouble alpha = Double.NaN;\ndouble dsq = Double.NaN;\ndouble crvmin = Double.NaN;\ntrustRegionCenterInterpolationPointIndex = 0;\nprelim(lowerBound, upperBound);\ndouble xoptsq = ZERO;\nfor (int i = 0; i < n; i++) {\n} // bobyqb",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:doOptimize()Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "protected RealPointValuePair doOptimize() {\nfinal double[] lowerBound = getLowerBound();\nfinal double[] upperBound = getUpperBound();\nsetup(lowerBound, upperBound);\nisMinimize = (getGoalType() == GoalType.MINIMIZE);\ncurrentBest = new ArrayRealVector(getStartPoint());\nfinal double value = bobyqa(lowerBound, upperBound);\nreturn new RealPointValuePair(currentBest.getDataRef(),\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:bobyqa([D[D)D",
            "method_body": "private double bobyqa(double[] lowerBound,\nprintMethod(); // XXX\nfinal int n = currentBest.getDimension();\nfor (int j = 0; j < n; j++) {\nfinal double boundDiff = boundDifference[j];\nlowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\nupperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\nif (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n} else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\nreturn bobyqb(lowerBound, upperBound);\n} // bobyqa",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:setup([D[D)V",
            "method_body": "private void setup(double[] lowerBound,\nprintMethod(); // XXX\ndouble[] init = getStartPoint();\nfinal int dimension = init.length;\nif (dimension < MINIMUM_PROBLEM_DIMENSION) {\nfinal int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\nif (numberOfInterpolationPoints < nPointsInterval[0] ||\nboundDifference = new double[dimension];\ndouble requiredMinDiff = 2 * initialTrustRegionRadius;\ndouble minDiff = Double.POSITIVE_INFINITY;\nfor (int i = 0; i < dimension; i++) {\nboundDifference[i] = upperBound[i] - lowerBound[i];\nminDiff = Math.min(minDiff, boundDifference[i]);\nif (minDiff < requiredMinDiff) {\ninitialTrustRegionRadius = minDiff / 3.0;\nbMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\nzMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\ninterpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\noriginShift = new ArrayRealVector(dimension);\nfAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\ntrustRegionCenterOffset = new ArrayRealVector(dimension);\ngradientAtTrustRegionCenter = new ArrayRealVector(dimension);\nlowerDifference = new ArrayRealVector(dimension);\nupperDifference = new ArrayRealVector(dimension);\nmodelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\nnewPoint = new ArrayRealVector(dimension);\nalternativeNewPoint = new ArrayRealVector(dimension);\ntrialStepPoint = new ArrayRealVector(dimension);\nlagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\nmodelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column) {\nif (column < 0 || column >= m.getColumnDimension()) {\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:setEntry(ID)V",
            "method_body": "public void setEntry(int index, double value) {\ndata[index] = value;\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 19
        }
    ]
}