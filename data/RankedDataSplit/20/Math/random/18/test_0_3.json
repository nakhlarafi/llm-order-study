{
    "bug_id": 18,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary",
    "test_body": "public void testFitAccuracyDependsOnBoundary() {\nfinal CMAESOptimizer optimizer = new CMAESOptimizer();\nfinal MultivariateFunction fitnessFunction = new MultivariateFunction() {\npublic double value(double[] parameters) {\nfinal double target = 11.1;\nfinal double error = target - parameters[0];\nreturn error * error;\n}\n};\n449: final double[] start = { 1 };\n451: // No bounds.\nPointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\nstart);\nfinal double resNoBound = result.getPoint()[0];\n456: // Optimum is near the lower bound.\nfinal double[] lower = { -20 };\nfinal double[] upper = { 5e16 };\nresult = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\nstart, lower, upper);\nfinal double resNearLo = result.getPoint()[0];\n463: // Optimum is near the upper bound.\nlower[0] = -5e16;\nupper[0] = 20;\nresult = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\nstart, lower, upper);\nfinal double resNearHi = result.getPoint()[0];\n470: // System.out.println(\"resNoBound=\" + resNoBound +\n//                    \" resNearLo=\" + resNearLo +\n//                    \" resNearHi=\" + resNearHi);\n474: // The two values currently differ by a substantial amount, indicating that\n// the bounds definition can prevent reaching the optimum.\nAssert.assertEquals(resNoBound, resNearLo, 1e-3);\nAssert.assertEquals(resNoBound, resNearHi, 1e-3);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<11.100000000388787> but was:<8.0>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary(CMAESOptimizerTest.java:477)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:<init>(Lorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:max(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double max(final RealMatrix m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (max < e) {\nmax = e;\nreturn max;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor:end()D",
            "method_body": "public double end() {\nreturn 0;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:value([D)D",
            "method_body": "public double value(final double[] point) {\nif (boundaries != null && isRepairMode) {\ndouble[] repaired = repair(point);\nvalue = CMAESOptimizer.this\n} else {\nvalue = CMAESOptimizer.this\nreturn isMinimize ? value : -value;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getD()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getD() {\nif (cachedD == null) {\ncachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\nfor (int i = 0; i < imagEigenvalues.length; i++) {\nif (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n} else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\nreturn cachedD;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:isSymmetric(Lorg/apache/commons/math3/linear/RealMatrix;Z)Z",
            "method_body": "private boolean isSymmetric(final RealMatrix matrix,\nfinal int rows = matrix.getRowDimension();\nfinal int columns = matrix.getColumnDimension();\nfinal double eps = 10 * rows * columns * Precision.EPSILON;\nfor (int i = 0; i < rows; ++i) {\nfor (int j = i + 1; j < columns; ++j) {\nreturn true;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:optimize(ILorg/apache/commons/math3/analysis/MultivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;[D)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\nreturn optimize(maxEval, f, goalType, startPoint, null, null);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:optimize(ILorg/apache/commons/math3/analysis/MultivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;[D)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\nreturn optimizeInternal(maxEval, f, goalType, startPoint);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nfinal double[] init = getStartPoint();\nfinal double[] lB = getLowerBound();\nfinal double[] uB = getUpperBound();\nboolean hasFiniteBounds = false;\nfor (int i = 0; i < lB.length; i++) {\nif (!Double.isInfinite(lB[i]) ||\nhasFiniteBounds = true;\nbreak;\nboolean hasInfiniteBounds = false;\nif (hasFiniteBounds) {\nfor (int i = 0; i < lB.length; i++) {\nif (Double.isInfinite(lB[i]) ||\nif (hasInfiniteBounds) {\nboundaries = new double[2][];\nboundaries[0] = lB;\nboundaries[1] = uB;\nfor (int i = 0; i < lB.length; i++) {\nif (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\nboundaries = null;\nif (inputSigma != null) {\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:<init>(I)V",
            "method_body": "public CMAESOptimizer(int lambda) {\nthis(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getValue()Ljava/lang/Object;",
            "method_body": "public V getValue() {\nreturn value;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:reverse([I)[I",
            "method_body": "private static int[] reverse(final int[] indices) {\nint[] reverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\nreverse[i] = indices[indices.length - i - 1];\nreturn reverse;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nNullArgumentException {\nif (copyArray) {\nif (d == null) {\nfinal int nRows = d.length;\nif (nRows == 0) {\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\ndata = d;\n}",
            "method_id": 79
        }
    ]
}