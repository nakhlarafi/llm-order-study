{
    "bug_id": 6,
    "test_id": 8,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testMaximize",
    "test_body": "public void testMaximize() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),1.0);\ndoTest(new MinusElli(), startPoint, insigma, boundaries,\nGoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testMaximize(CMAESOptimizerTest.java:148)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:add(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix add(RealMatrix m)\nMatrixUtils.checkAdditionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:min(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double min(final RealMatrix m) {\ndouble min = Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (min > e) {\nmin = e;\nreturn min;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:compareTo(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer$DoubleIndex;)I",
            "method_body": "public int compareTo(DoubleIndex o) {\nreturn Double.compare(value, o.value);\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:zeros(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix zeros(int n, int m) {\nreturn new Array2DRowRealMatrix(n, m);\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:push([DD)V",
            "method_body": "private static void push(double[] vals, double val) {\nfor (int i = vals.length-1; i > 0; i--) {\nvals[i] = vals[i-1];\nvals[0] = val;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:max([D)D",
            "method_body": "private static double max(final double[] m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.length; r++) {\nif (max < m[r]) {\nmax = m[r];\nreturn max;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:diag(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix diag(final RealMatrix m) {\nif (m.getColumnDimension() == 1) {\nfinal double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\nfor (int i = 0; i < m.getRowDimension(); i++) {\nd[i][i] = m.getEntry(i, 0);\nreturn new Array2DRowRealMatrix(d, false);\nfinal double[][] d = new double[m.getRowDimension()][1];\nfor (int i = 0; i < m.getColumnDimension(); i++) {\nd[i][0] = m.getEntry(i, i);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getFrobeniusNorm()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof Sigma) {\ninputSigma = ((Sigma) data).getSigma();\ncontinue;\nif (data instanceof PopulationSize) {\nlambda = ((PopulationSize) data).getPopulationSize();\ncontinue;\ncheckParameters();\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:divide(Lorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:nextGaussian()D",
            "method_body": "public double nextGaussian() {\nif (Double.isNaN(nextGaussian)) {\nfinal double x = nextDouble();\nfinal double y = nextDouble();\nfinal double alpha = 2 * FastMath.PI * x;\nfinal double r      = FastMath.sqrt(-2 * FastMath.log(y));\nrandom       = r * FastMath.cos(alpha);\nnextGaussian = r * FastMath.sin(alpha);\n} else {\nrandom = nextGaussian;\nnextGaussian = Double.NaN;\nreturn random;\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor:end()D",
            "method_body": "public double end() {\nreturn 0;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getD()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getD() {\nif (cachedD == null) {\ncachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\nfor (int i = 0; i < imagEigenvalues.length; i++) {\nif (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n} else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\nreturn cachedD;\n}",
            "method_id": 139
        }
    ]
}