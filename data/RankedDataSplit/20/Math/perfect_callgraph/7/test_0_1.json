{
    "bug_id": 7,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling",
    "test_body": "public void testEventsScheduling() {\n339: FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n341: public int getDimension() {\nreturn 2;\n}\n345: public void computeDerivatives(double t, double[] y, double[] yDot) {\nyDot[0] =  y[1];\nyDot[1] = -y[0];\n}\n350: };\n352: SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\nSchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n355: FirstOrderIntegrator integ =\nnew DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\ninteg.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\ninteg.addStepHandler(sinChecker);\ninteg.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\ninteg.addStepHandler(cosChecker);\ndouble   t0 = 0.5;\ndouble[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\ndouble   t  = 10.0;\ndouble[] y  = new double[2];\ninteg.integrate(sincos, t0, y0, t, y);\n367: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest$SchedulingChecker.g(DormandPrince853IntegratorTest.java:389)\nat org.apache.commons.math3.ode.events.EventState.evaluateStep(EventState.java:224)\nat org.apache.commons.math3.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:323)\nat org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:303)\nat org.apache.commons.math3.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:228)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling(DormandPrince853IntegratorTest.java:365)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math3/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\naddEventHandler(handler, maxCheckInterval, convergence,\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:finalizeStep()V",
            "method_body": "public final void finalizeStep() throws MaxCountExceededException {\nif (! finalized) {\ndoFinalize();\nfinalized = true;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDLorg/apache/commons/math3/analysis/solvers/AllowedSolution;)D",
            "method_body": "public double solve(int maxEval, UnivariateFunction f, double min,\nthis.allowed = allowedSolution;\nreturn super.solve(maxEval, f, min, max);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math3/ode/ExpandableStatefulODE;)V",
            "method_body": "protected void setEquations(final ExpandableStatefulODE equations) {\nthis.expandable = equations;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.ode.EquationsMapper:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max, double startValue)\nsetup(maxEval, f, min, max, startValue);\nreturn doSolve();\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState$1:<init>(Lorg/apache/commons/math3/ode/events/EventState;Lorg/apache/commons/math3/ode/sampling/StepInterpolator;)V",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateFunction f = new UnivariateFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateSolver<?>) {\nBracketedUnivariateSolver<UnivariateFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator$1:compare(Ljava/lang/Object;Ljava/lang/Object;)I",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\nstatesInitialized = true;\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\noccuringEvents.add(state);\nwhile (!occuringEvents.isEmpty()) {\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState().clone();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\nfor (final StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\nif (isLastStep) {\nboolean needReset = currentEvent.reset(eventT, eventY);\nif (needReset) {\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nfor (final EventState remaining : occuringEvents) {\nreturn eventT;\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\nreturn currentT;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator:initializeStep(ZI[DD[D[D[D[D)D",
            "method_body": "public double initializeStep(final boolean forward, final int order, final double[] scale,\nif (initialStep > 0) {\ndouble yOnScale2 = 0;\ndouble yDotOnScale2 = 0;\nfor (int j = 0; j < scale.length; ++j) {\nratio         = y0[j] / scale[j];\nyOnScale2    += ratio * ratio;\nratio         = yDot0[j] / scale[j];\nyDotOnScale2 += ratio * ratio;\ndouble h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\nif (! forward) {\nfor (int j = 0; j < y0.length; ++j) {\ny1[j] = y0[j] + h * yDot0[j];\ncomputeDerivatives(t0 + h, y1, yDot1);\ndouble yDDotOnScale = 0;\nfor (int j = 0; j < scale.length; ++j) {\nratio         = (yDot1[j] - yDot0[j]) / scale[j];\nyDDotOnScale += ratio * ratio;\nyDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\nfinal double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\nfinal double h1 = (maxInv2 < 1.0e-15) ?\nh = FastMath.min(100.0 * FastMath.abs(h), h1);\nh = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\nif (h < getMinStep()) {\nif (h > getMaxStep()) {\nif (! forward) {\nreturn h;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateFunction f = new UnivariateFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateSolver<?>) {\nBracketedUnivariateSolver<UnivariateFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:doSolve()D",
            "method_body": "protected double doSolve()\nfinal double[] x = new double[maximalOrder + 1];\nfinal double[] y = new double[maximalOrder + 1];\nx[0] = getMin();\nx[1] = getStartValue();\nx[2] = getMax();\nverifySequence(x[0], x[1], x[2]);\ny[1] = computeObjectiveValue(x[1]);\nif (Precision.equals(y[1], 0.0, 1)) {\ny[0] = computeObjectiveValue(x[0]);\nif (Precision.equals(y[0], 0.0, 1)) {\nif (y[0] * y[1] < 0) {\ny[2] = computeObjectiveValue(x[2]);\nif (Precision.equals(y[2], 0.0, 1)) {\nif (y[1] * y[2] < 0) {\nnbPoints        = 3;\nsignChangeIndex = 2;\nfinal double[] tmpX = new double[x.length];\ndouble xA    = x[signChangeIndex - 1];\ndouble yA    = y[signChangeIndex - 1];\ndouble absYA = FastMath.abs(yA);\nint agingA   = 0;\ndouble xB    = x[signChangeIndex];\ndouble yB    = y[signChangeIndex];\ndouble absYB = FastMath.abs(yB);\nint agingB   = 0;\nfinal double xTol = getAbsoluteAccuracy() +\nif (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\nswitch (allowed) {\nreturn xB;\nif (agingA >= MAXIMAL_AGING) {\nfinal int p = agingA - MAXIMAL_AGING;\nfinal double weightA = (1 << p) - 1;\nfinal double weightB = p + 1;\ntargetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n} else if (agingB >= MAXIMAL_AGING) {\ntargetY = 0;\nint start = 0;\nint end   = nbPoints;\nSystem.arraycopy(x, start, tmpX, start, end - start);\nnextX = guessX(targetY, tmpX, y, start, end);\nif (!((nextX > xA) && (nextX < xB))) {\n} while (Double.isNaN(nextX) && (end - start > 1));\nif (Double.isNaN(nextX)) {\nfinal double nextY = computeObjectiveValue(nextX);\nif (Precision.equals(nextY, 0.0, 1)) {\nif ((nbPoints > 2) && (end - start != nbPoints)) {\n} else  if (nbPoints == x.length) {\nSystem.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\nx[signChangeIndex] = nextX;\nSystem.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\ny[signChangeIndex] = nextY;\n++nbPoints;\nif (nextY * yA <= 0) {\nxB = nextX;\nyB = nextY;\nabsYB = FastMath.abs(yB);\n++agingA;\nagingB = 0;\nxA = nextX;\nyA = nextY;\nabsYA = FastMath.abs(yA);\nagingA = 0;\n++agingB;\nsignChangeIndex++;\n}\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math3/ode/ExpandableStatefulODE;D)V",
            "method_body": "public void integrate(final ExpandableStatefulODE equations, final double t)\nsanityChecks(equations, t);\nsetEquations(equations);\nfinal boolean forward = t > equations.getTime();\nfinal double[] y0  = equations.getCompleteState();\nfinal double[] y = y0.clone();\nfinal int stages = c.length + 1;\nfinal double[][] yDotK = new double[stages][y.length];\nfinal double[] yTmp    = y0.clone();\nfinal double[] yDotTmp = new double[y.length];\nfinal RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\ninterpolator.reinitialize(this, yTmp, yDotK, forward,\ninterpolator.storeTime(equations.getTime());\nstepStart         = equations.getTime();\ndouble  hNew      = 0;\nboolean firstTime = true;\ninitIntegration(equations.getTime(), y0, t);\nisLastStep = false;\ninterpolator.shift();\ndouble error = 10;\nwhile (error >= 1.0) {\nif (firstTime || !fsal) {\ncomputeDerivatives(stepStart, y, yDotK[0]);\nif (firstTime) {\nfinal double[] scale = new double[mainSetDimension];\nif (vecAbsoluteTolerance == null) {\nfor (int i = 0; i < scale.length; ++i) {\nscale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\nhNew = initializeStep(forward, getOrder(), scale,\nfirstTime = false;\nstepSize = hNew;\nif (forward) {\nif (stepStart + stepSize >= t) {\nfor (int k = 1; k < stages; ++k) {\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error >= 1.0) {\ninterpolator.storeTime(stepStart + stepSize);\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nSystem.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\nstepStart = acceptStep(interpolator, y, yDotTmp, t);\nSystem.arraycopy(y, 0, yTmp, 0, y.length);\nif (!isLastStep) {\ninterpolator.storeTime(stepStart);\nif (fsal) {\nSystem.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\nfinal double factor =\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\nfinal double  filteredNextT      = stepStart + hNew;\nfinal boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\nif (filteredNextIsLast) {\n} while (!isLastStep);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.ode.EquationsMapper:insertEquationData([D[D)V",
            "method_body": "public void insertEquationData(double[] equationData, double[] complete)\nif (equationData.length != dimension) {\nSystem.arraycopy(equationData, 0, complete, firstIndex, dimension);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y) {\nif (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\nif (nextAction == EventHandler.Action.RESET_STATE) {\nhandler.resetState(t, y);\npendingEvent      = false;\npendingEventTime  = Double.NaN;\nreturn (nextAction == EventHandler.Action.RESET_STATE) ||\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:<init>(Ljava/lang/String;Z[D[[D[DLorg/apache/commons/math3/ode/nonstiff/RungeKuttaStepInterpolator;DDDD)V",
            "method_body": "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nthis.fsal      = fsal;\nthis.c         = c;\nthis.a         = a;\nthis.b         = b;\nthis.prototype = prototype;\nexp = -1.0 / getOrder();\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(10.0);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:setSoftPreviousTime(D)V",
            "method_body": "public void setSoftPreviousTime(final double softPreviousTime) {\nthis.softPreviousTime = softPreviousTime;\n}",
            "method_id": 39
        }
    ]
}