{
    "bug_id": 58,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519",
    "test_body": "public void testMath519() {\n// The optimizer will try negative sigma values but \"GaussianFitter\"\n// will catch the raised exceptions and return NaN values instead.\n302: final double[] data = { \n1.1143831578403364E-29,\n4.95281403484594E-28,\n1.1171347211930288E-26,\n1.7044813962636277E-25,\n1.9784716574832164E-24,\n1.8630236407866774E-23,\n1.4820532905097742E-22,\n1.0241963854632831E-21,\n6.275077366673128E-21,\n3.461808994532493E-20,\n1.7407124684715706E-19,\n8.056687953553974E-19,\n3.460193945992071E-18,\n1.3883326374011525E-17,\n5.233894983671116E-17,\n1.8630791465263745E-16,\n6.288759227922111E-16,\n2.0204433920597856E-15,\n6.198768938576155E-15,\n1.821419346860626E-14,\n5.139176445538471E-14,\n1.3956427429045787E-13,\n3.655705706448139E-13,\n9.253753324779779E-13,\n2.267636001476696E-12,\n5.3880460095836855E-12,\n1.2431632654852931E-11\n};\n332: GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\nfor (int i = 0; i < data.length; i++) {\nfitter.addObservedPoint(i, data[i]);\n}\nfinal double[] p = fitter.fit();\n338: Assert.assertEquals(53.1572792, p[1], 1e-7);\nAssert.assertEquals(5.75214622, p[2], 1e-8);\n}\n",
    "stack_trace": "org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than, or equal to, the minimum (0)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.validateParameters(Gaussian.java:183)\nat org.apache.commons.math.analysis.function.Gaussian$Parametric.value(Gaussian.java:128)\nat org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction.value(CurveFitter.java:203)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.computeObjectiveValue(BaseAbstractVectorialOptimizer.java:107)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateResidualsAndCost(AbstractLeastSquaresOptimizer.java:128)\nat org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize(LevenbergMarquardtOptimizer.java:350)\nat org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.optimize(BaseAbstractVectorialOptimizer.java:141)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:253)\nat org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:43)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:160)\nat org.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:126)\nat org.apache.commons.math.optimization.fitting.GaussianFitter.fit(GaussianFitter.java:121)\nat org.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519(GaussianFitterTest.java:336)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.exception.NumberIsTooSmallException:<init>(Lorg/apache/commons/math/exception/util/Localizable;Ljava/lang/Number;Ljava/lang/Number;Z)V",
            "method_body": "public NumberIsTooSmallException(Localizable specific,\nsuper(specific,\nthis.min = min;\nthis.boundIsAllowed = boundIsAllowed;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter:fit(ILorg/apache/commons/math/analysis/ParametricUnivariateRealFunction;[D)[D",
            "method_body": "public double[] fit(int maxEval, final ParametricUnivariateRealFunction f,\ndouble[] target  = new double[observations.size()];\ndouble[] weights = new double[observations.size()];\nint i = 0;\nfor (WeightedObservedPoint point : observations) {\ntarget[i]  = point.getY();\nweights[i] = point.getWeight();\n++i;\nVectorialPointValuePair optimum =\nreturn optimum.getPointRef();\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter:<init>(Lorg/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer;)V",
            "method_body": "public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\nsuper(optimizer);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.optimization.VectorialPointValuePair:<init>([D[D)V",
            "method_body": "public VectorialPointValuePair(final double[] point, final double[] value) {\nthis.point = (point == null) ? null : point.clone();\nthis.value = (value == null) ? null : value.clone();\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:qrDecomposition()V",
            "method_body": "private void qrDecomposition() throws ConvergenceException {\nfor (int k = 0; k < cols; ++k) {\npermutation[k] = k;\ndouble norm2 = 0;\nfor (int i = 0; i < weightedResidualJacobian.length; ++i) {\ndouble akk = weightedResidualJacobian[i][k];\nnorm2 += akk * akk;\njacNorm[k] = FastMath.sqrt(norm2);\nfor (int k = 0; k < cols; ++k) {\nint nextColumn = -1;\ndouble ak2 = Double.NEGATIVE_INFINITY;\nfor (int i = k; i < cols; ++i) {\ndouble norm2 = 0;\nfor (int j = k; j < weightedResidualJacobian.length; ++j) {\ndouble aki = weightedResidualJacobian[j][permutation[i]];\nnorm2 += aki * aki;\nif (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\nif (norm2 > ak2) {\nnextColumn = i;\nak2        = norm2;\nif (ak2 <= qrRankingThreshold) {\nint pk                  = permutation[nextColumn];\npermutation[nextColumn] = permutation[k];\npermutation[k]          = pk;\ndouble akk   = weightedResidualJacobian[k][pk];\ndouble alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\ndouble betak = 1.0 / (ak2 - akk * alpha);\nbeta[pk]     = betak;\ndiagR[pk]        = alpha;\nweightedResidualJacobian[k][pk] -= alpha;\nfor (int dk = cols - 1 - k; dk > 0; --dk) {\ndouble gamma = 0;\nfor (int j = k; j < weightedResidualJacobian.length; ++j) {\ngamma += weightedResidualJacobian[j][pk] * weightedResidualJacobian[j][permutation[k + dk]];\ngamma *= betak;\nfor (int j = k; j < weightedResidualJacobian.length; ++j) {\nweightedResidualJacobian[j][permutation[k + dk]] -= gamma * weightedResidualJacobian[j][pk];\nrank = solvedCols;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction$1:<init>(Lorg/apache/commons/math/optimization/fitting/CurveFitter$TheoreticalValuesFunction;)V",
            "method_body": "public MultivariateMatrixFunction jacobian() {\nreturn new MultivariateMatrixFunction() {\nfinal double[][] jacobian = new double[observations.size()][];\nint i = 0;\nfor (WeightedObservedPoint observed : observations) {\njacobian[i++] = f.gradient(observed.getX(), point);\nreturn jacobian;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.analysis.function.Gaussian$Parametric:gradient(D[D)[D",
            "method_body": "public double[] gradient(double x, double[] param) {\nvalidateParameters(param);\nfinal double norm = param[0];\nfinal double diff = x - param[1];\nfinal double sigma = param[2];\nfinal double i2s2 = 1 / (2 * sigma * sigma);\nfinal double n = Gaussian.value(diff, 1, i2s2);\nfinal double m = norm * n * 2 * i2s2 * diff;\nfinal double s = m * diff / sigma;\nreturn new double[] { n, m, s };\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction$1:value([D)[[D",
            "method_body": "public MultivariateMatrixFunction jacobian() {\nreturn new MultivariateMatrixFunction() {\nfinal double[][] jacobian = new double[observations.size()][];\nint i = 0;\nfor (WeightedObservedPoint observed : observations) {\njacobian[i++] = f.gradient(observed.getX(), point);\nreturn jacobian;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:determineLMDirection([D[D[D[D)V",
            "method_body": "private void determineLMDirection(double[] qy, double[] diag,\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nfor (int i = j + 1; i < solvedCols; ++i) {\nweightedResidualJacobian[i][pj] = weightedResidualJacobian[j][permutation[i]];\nlmDir[j] = diagR[pj];\nwork[j]  = qy[j];\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dpj = diag[pj];\nif (dpj != 0) {\nArrays.fill(lmDiag, j + 1, lmDiag.length, 0);\nlmDiag[j] = dpj;\ndouble qtbpj = 0;\nfor (int k = j; k < solvedCols; ++k) {\nint pk = permutation[k];\nif (lmDiag[k] != 0) {\ndouble rkk = weightedResidualJacobian[k][pk];\nif (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\nfinal double cotan = rkk / lmDiag[k];\nsin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\ncos   = sin * cotan;\n} else {\nfinal double tan = lmDiag[k] / rkk;\ncos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\nsin = cos * tan;\nweightedResidualJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\nfinal double temp = cos * work[k] + sin * qtbpj;\nqtbpj = -sin * work[k] + cos * qtbpj;\nwork[k] = temp;\nfor (int i = k + 1; i < solvedCols; ++i) {\ndouble rik = weightedResidualJacobian[i][pk];\nfinal double temp2 = cos * rik + sin * lmDiag[i];\nlmDiag[i] = -sin * rik + cos * lmDiag[i];\nweightedResidualJacobian[i][pk] = temp2;\nlmDiag[j] = weightedResidualJacobian[j][permutation[j]];\nweightedResidualJacobian[j][permutation[j]] = lmDir[j];\nint nSing = solvedCols;\nfor (int j = 0; j < solvedCols; ++j) {\nif ((lmDiag[j] == 0) && (nSing == solvedCols)) {\nif (nSing < solvedCols) {\nif (nSing > 0) {\nfor (int j = nSing - 1; j >= 0; --j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = j + 1; i < nSing; ++i) {\nsum += weightedResidualJacobian[i][pj] * work[i];\nwork[j] = (work[j] - sum) / lmDiag[j];\nfor (int j = 0; j < lmDir.length; ++j) {\nlmDir[permutation[j]] = work[j];\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:interpolateXAtY([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;IID)D",
            "method_body": "private double interpolateXAtY(WeightedObservedPoint[] points,\nif (idxStep == 0) {\nWeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\nWeightedObservedPoint pointA = twoPoints[0];\nWeightedObservedPoint pointB = twoPoints[1];\nif (pointA.getY() == y) {\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer:getTargetRef()[D",
            "method_body": "protected double[] getTargetRef() {\nreturn target;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:<init>([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)V",
            "method_body": "public ParameterGuesser(WeightedObservedPoint[] observations) {\nif (observations == null) {\nif (observations.length < 3) {\nthis.observations = observations.clone();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.WeightedObservedPoint:getWeight()D",
            "method_body": "public double getWeight() {\nreturn weight;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\nif (a < b) {\nreturn a;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.exception.NumberIsTooSmallException:<init>(Ljava/lang/Number;Ljava/lang/Number;Z)V",
            "method_body": "public NumberIsTooSmallException(Number wrong,\nthis(null, wrong, min, boundIsAllowed);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.CurveFitter:fit(Lorg/apache/commons/math/analysis/ParametricUnivariateRealFunction;[D)[D",
            "method_body": "public double[] fit(final ParametricUnivariateRealFunction f, final double[] initialGuess) {\nreturn fit(Integer.MAX_VALUE, f, initialGuess);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.optimization.fitting.GaussianFitter$ParameterGuesser:basicGuess([Lorg/apache/commons/math/optimization/fitting/WeightedObservedPoint;)[D",
            "method_body": "private double[] basicGuess(WeightedObservedPoint[] points) {\nArrays.sort(points, createWeightedObservedPointComparator());\ndouble[] params = new double[3];\nint maxYIdx = findMaxY(points);\nparams[0] = points[maxYIdx].getY();\nparams[1] = points[maxYIdx].getX();\ndouble halfY = params[0] + ((params[1] - params[0]) / 2.0);\ndouble fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\ndouble fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\nfwhmApprox = fwhmX2 - fwhmX1;\n} catch (OutOfRangeException e) {\nfwhmApprox = points[points.length - 1].getX() - points[0].getX();\n}\nparams[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\nreturn params;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer:computeObjectiveValue([D)[D",
            "method_body": "protected double[] computeObjectiveValue(double[] point) {\nevaluations.incrementCount();\n}\nreturn function.value(point);\n}",
            "method_id": 39
        }
    ]
}