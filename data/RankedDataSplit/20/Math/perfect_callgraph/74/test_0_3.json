{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize()\nif (currentState == null) {\nreturn;\nfinal double[] yTmp = new double[currentState.length];\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:multiply(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = this.getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum = this.getColumnDimension();\nfinal double[][] outData = new double[nRows][nCols];\nfor (int row = 0; row < nRows; row++) {\nfinal double[] dataRow    = data[row];\nfinal double[] outDataRow = outData[row];\nfor (int col = 0; col < nCols; col++) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; i++) {\nsum += dataRow[i] * m.data[i][col];\noutDataRow[col] = sum;\nreturn new Array2DRowRealMatrix(outData, false);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:clearResult()V",
            "method_body": "protected final void clearResult() {\nthis.iterationCount = 0;\nthis.resultComputed = false;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:filterStep(DZZ)D",
            "method_body": "protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\ndouble filteredH = h;\nif (Math.abs(h) < minStep) {\nif (filteredH > maxStep) {\nfilteredH = maxStep;\n} else if (filteredH < -maxStep) {\nreturn filteredH;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:estimateError([[D[D[DD)D",
            "method_body": "protected double estimateError(final double[][] yDotK,\ndouble error1 = 0;\ndouble error2 = 0;\nfor (int j = 0; j < y0.length; ++j) {\nfinal double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\nfinal double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\nfinal double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\nfinal double ratio1  = errSum1 / tol;\nerror1        += ratio1 * ratio1;\nfinal double ratio2  = errSum2 / tol;\nerror2        += ratio2 * ratio2;\ndouble den = error1 + 0.01 * error2;\nif (den <= 0.0) {\nreturn Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal int n = y0.length;\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, n);\nfinal double[] yDot = new double[y0.length];\nfinal double[] yTmp = new double[y0.length];\nfinal NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\ninterpolator.reinitialize(y, forward);\nfinal NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\ninterpolatorTmp.reinitialize(yTmp, forward);\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nstart(t0, y, t);\ninterpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\ninterpolator.storeTime(stepStart);\ndouble hNew = stepSize;\ninterpolator.rescale(hNew);\nboolean lastStep = false;\nwhile (!lastStep) {\ninterpolator.shift();\ndouble error = 0;\nfor (boolean loop = true; loop;) {\nstepSize = hNew;\nfinal double stepEnd = stepStart + stepSize;\ninterpolator.setInterpolatedTime(stepEnd);\nSystem.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\ncomputeDerivatives(stepEnd, yTmp, yDot);\nfinal double[] predictedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\npredictedScaled[j] = stepSize * yDot[j];\nfinal Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\nupdateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\nerror = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\nif (error <= 1.0) {\ncomputeDerivatives(stepEnd, yTmp, yDot);\nfinal double[] correctedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\ncorrectedScaled[j] = stepSize * yDot[j];\nupdateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\ninterpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\ninterpolatorTmp.storeTime(stepStart);\ninterpolatorTmp.shift();\ninterpolatorTmp.storeTime(stepEnd);\nif (manager.evaluateStep(interpolatorTmp)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\nhNew = dt;\ninterpolator.rescale(hNew);\n} else {\nscaled    = correctedScaled;\nnordsieck = nordsieckTmp;\ninterpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\nloop = false;\n} else {\nfinal double factor = computeStepGrowShrinkFactor(error);\nhNew = filterStep(stepSize * factor, forward, false);\ninterpolator.rescale(hNew);\n}\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, n);\ninterpolator.storeTime(nextStep);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\nfor (StepHandler handler : stepHandlers) {\ninterpolator.setInterpolatedTime(nextStep);\nhandler.handleStep(interpolator, lastStep);\nstepStart = nextStep;\nif (!lastStep && manager.reset(stepStart, y)) {\nif (! lastStep) {\nstepSize = filterStep(stepSize, forward, true);\nfinal double  factor     = computeStepGrowShrinkFactor(error);\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\ninterpolator.rescale(hNew);\n}\nfinal double stopTime  = stepStart;\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\nreturn stopTime;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nthis.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:eventOccurred(D[DZ)I",
            "method_body": "public int eventOccurred(double t, double[] y, boolean increasing) {\nreturn STOP;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage(Ljava/util/Locale;)Ljava/lang/String;",
            "method_body": "public String getMessage(final Locale locale) {\nreturn (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:computeStepGrowShrinkFactor(D)D",
            "method_body": "protected double computeStepGrowShrinkFactor(final double error) {\nreturn Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getCurrentTime()D",
            "method_body": "public double getCurrentTime() {\nreturn currentTime;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventsStates()Ljava/util/Collection;",
            "method_body": "public Collection<EventState> getEventsStates() {\nreturn states;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows IllegalArgumentException, NullPointerException {\nif (copyArray) {\nif (d == null) {\nfinal int nRows = d.length;\nif (nRows == 0) {\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\ndata = d;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:start(D[DD)V",
            "method_body": "protected void start(final double t0, final double[] y0, final double t)\nstarter.clearEventHandlers();\nstarter.clearStepHandlers();\nstarter.addStepHandler(new NordsieckInitializer(y0.length));\nstarter.integrate(new CountingDifferentialEquations(y0.length),\n} catch (DerivativeException de) {\nif (!(de instanceof InitializationCompletedMarkerException)) {\n}\nstarter.clearStepHandlers();\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:verifyInterval(DD)V",
            "method_body": "protected void verifyInterval(final double lower, final double upper) {\nif (lower >= upper) {\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:reinitialize(DD[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void reinitialize(final double time, final double stepSize,\nthis.referenceTime = time;\nthis.scalingH      = stepSize;\nthis.scaled        = scaledDerivative;\nthis.nordsieck     = nordsieckVector;\nsetInterpolatedTime(getInterpolatedTime());\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setInterpolatedTime(D)V",
            "method_body": "public void setInterpolatedTime(final double time) {\ninterpolatedTime = time;\ndirtyState       = true;\n}",
            "method_id": 79
        }
    ]
}