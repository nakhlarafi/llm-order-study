{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZ)V",
            "method_body": "public void reinitialize(final AbstractIntegrator integrator,\nsuper.reinitialize(integrator, y, yDotK, forward);\nfinal int dimension = currentState.length;\nyDotKLast = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k]  = new double[dimension];\nvectorsInitialized = false;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\nsuper.storeTime(t);\nvectorsInitialized = false;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize()\nif (currentState == null) {\nreturn;\nfinal double[] yTmp = new double[currentState.length];\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:estimateError([[D[D[DD)D",
            "method_body": "protected double estimateError(final double[][] yDotK,\ndouble error1 = 0;\ndouble error2 = 0;\nfor (int j = 0; j < y0.length; ++j) {\nfinal double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\nfinal double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\nfinal double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\nfinal double ratio1  = errSum1 / tol;\nerror1        += ratio1 * ratio1;\nfinal double ratio2  = errSum2 / tol;\nerror2        += ratio2 * ratio2;\ndouble den = error1 + 0.01 * error2;\nif (den <= 0.0) {\nreturn Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.MathException:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public MathException(Throwable rootCause) {\nsuper(rootCause);\nthis.pattern   = getMessage();\nthis.arguments = new Object[0];\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:getOrder()I",
            "method_body": "public int getOrder() {\nreturn 8;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getDataRef()[[D",
            "method_body": "public double[][] getDataRef() {\nreturn data;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:getCurrentSignedStepsize()D",
            "method_body": "public double getCurrentSignedStepsize() {\nreturn stepSize;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage()Ljava/lang/String;",
            "method_body": "public String getMessage() {\nreturn getMessage(Locale.US);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage(Ljava/util/Locale;)Ljava/lang/String;",
            "method_body": "public String getMessage(final Locale locale) {\nreturn (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:<init>(Ljava/lang/String;Z[D[[D[DLorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;DDDD)V",
            "method_body": "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nthis.fsal      = fsal;\nthis.c         = c;\nthis.a         = a;\nthis.b         = b;\nthis.prototype = prototype;\nexp = -1.0 / getOrder();\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(10.0);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedTime()D",
            "method_body": "public double getInterpolatedTime() {\nreturn interpolatedTime;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\nfinal int stages = c.length + 1;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, y0.length);\nfinal double[][] yDotK = new double[stages][y0.length];\nfinal double[] yTmp = new double[y0.length];\nif (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\nfinal RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\nrki.reinitialize(this, yTmp, yDotK, forward);\ninterpolator = rki;\n} else {\ninterpolator.storeTime(t0);\nstepStart         = t0;\ndouble  hNew      = 0;\nboolean firstTime = true;\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nboolean lastStep = false;\nwhile (!lastStep) {\ninterpolator.shift();\ndouble error = 0;\nfor (boolean loop = true; loop;) {\nif (firstTime || !fsal) {\ncomputeDerivatives(stepStart, y, yDotK[0]);\nif (firstTime) {\nif (vecAbsoluteTolerance == null) {\nscale = new double[y0.length];\njava.util.Arrays.fill(scale, scalAbsoluteTolerance);\nhNew = initializeStep(equations, forward, getOrder(), scale,\nfirstTime = false;\nstepSize = hNew;\nfor (int k = 1; k < stages; ++k) {\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error <= 1.0) {\ninterpolator.storeTime(stepStart + stepSize);\nif (manager.evaluateStep(interpolator)) {\nloop = false;\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\ninterpolator.storeTime(nextStep);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, lastStep);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getMinStep()D",
            "method_body": "public double getMinStep() {\nreturn minStep;\n}",
            "method_id": 59
        }
    ]
}