{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution",
    "test_body": "public void testUnivariateDistribution() {\nfinal double[] mu = { -1.5 };\nfinal double[][] sigma = { { 1 } };\n143: final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n145: final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\nfinal Random rng = new Random();\nfinal int numCases = 100;\nfinal double tol = Math.ulp(1d);\nfor (int i = 0; i < numCases; i++) {\nfinal double v = rng.nextDouble() * 10 - 5;\nAssert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n}",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.23644016090654427> but was:<0.5926675925866471>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution(MultivariateNormalDistributionTest.java:151)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:density([D)D",
            "method_body": "public double density(final double[] vals) throws DimensionMismatchException {\nfinal int dim = getDimension();\nif (vals.length != dim) {\nreturn FastMath.pow(2 * FastMath.PI, -dim / 2) *\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:getExponentTerm([D)D",
            "method_body": "private double getExponentTerm(final double[] values) {\nfinal double[] centered = new double[values.length];\nfor (int i = 0; i < centered.length; i++) {\ncentered[i] = values[i] - getMeans()[i];\nfinal double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);\ndouble sum = 0;\nfor (int i = 0; i < preMultiplied.length; i++) {\nsum += preMultiplied[i] * centered[i];\nreturn FastMath.exp(-0.5 * sum);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:getMeans()[D",
            "method_body": "public double[] getMeans() {\nreturn MathArrays.copyOf(means);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:preMultiply([D)[D",
            "method_body": "public double[] preMultiply(final double[] v)\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nif (v.length != nRows) {\nfinal double[] out = new double[nCols];\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nRows; ++i) {\nsum += data[i][col] * v[i];\nout[col] = sum;\nreturn out;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:multiplyEntry(IID)V",
            "method_body": "public void multiplyEntry(final int row, final int column,\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] *= factor;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;I)V",
            "method_body": "protected AbstractMultivariateRealDistribution(RandomGenerator rng,\nint n) {\nrandom = rng;\ndimension = n;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:<init>([D[[D)V",
            "method_body": "public MultivariateNormalDistribution(final double[] means,\nthis(new Well19937c(), means, covariances);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;[D[[D)V",
            "method_body": "public MultivariateNormalDistribution(RandomGenerator rng,\nsuper(rng, means.length);\nfinal int dim = means.length;\nif (covariances.length != dim) {\nfor (int i = 0; i < dim; i++) {\nif (dim != covariances[i].length) {\nthis.means = MathArrays.copyOf(means);\ncovarianceMatrix = new Array2DRowRealMatrix(covariances);\nfinal EigenDecomposition covMatDec = new EigenDecomposition(covarianceMatrix);\ncovarianceMatrixInverse = covMatDec.getSolver().getInverse();\ncovarianceMatrixDeterminant = covMatDec.getDeterminant();\nfinal double[] covMatEigenvalues = covMatDec.getRealEigenvalues();\nfor (int i = 0; i < covMatEigenvalues.length; i++) {\nif (covMatEigenvalues[i] < 0) {\nfinal Array2DRowRealMatrix covMatEigenvectors = new Array2DRowRealMatrix(dim, dim);\nfor (int v = 0; v < dim; v++) {\nfinal double[] evec = covMatDec.getEigenvector(v).toArray();\ncovMatEigenvectors.setColumn(v, evec);\nfinal RealMatrix tmpMatrix = covMatEigenvectors.transpose();\nfor (int row = 0; row < dim; row++) {\nfinal double factor = FastMath.sqrt(covMatEigenvalues[row]);\nfor (int col = 0; col < dim; col++) {\ntmpMatrix.multiplyEntry(row, col, factor);\nsamplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getDeterminant()D",
            "method_body": "public double getDeterminant() {\ndouble determinant = 1;\nfor (double lambda : realEigenvalues) {\ndeterminant *= lambda;\nreturn determinant;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumn(I[D)V",
            "method_body": "public void setColumn(final int column, final double[] array)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (array.length != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, array[i]);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:getInverse()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getInverse() {\nif (!isNonSingular()) {\nfinal int m = realEigenvalues.length;\nfinal double[][] invData = new double[m][m];\nfor (int i = 0; i < m; ++i) {\nfinal double[] invI = invData[i];\nfor (int j = 0; j < m; ++j) {\ndouble invIJ = 0;\nfor (int k = 0; k < m; ++k) {\nfinal double[] vK = eigenvectors[k].getDataRef();\ninvIJ += vK[i] * vK[j] / realEigenvalues[k];\ninvI[j] = invIJ;\nreturn MatrixUtils.createRealMatrix(invData);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:hasComplexEigenvalues()Z",
            "method_body": "public boolean hasComplexEigenvalues() {\nfor (int i = 0; i < imagEigenvalues.length; i++) {\nif (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\nreturn false;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getEigenvector(I)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector getEigenvector(final int i) {\nreturn eigenvectors[i].copy();\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getSolver()Lorg/apache/commons/math3/linear/DecompositionSolver;",
            "method_body": "public DecompositionSolver getSolver() {\nif (hasComplexEigenvalues()) {\nreturn new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:<init>([D[D[Lorg/apache/commons/math3/linear/ArrayRealVector;)V",
            "method_body": "private Solver(final double[] realEigenvalues,\nfinal ArrayRealVector[] eigenvectors) {\nthis.realEigenvalues = realEigenvalues;\nthis.imagEigenvalues = imagEigenvalues;\nthis.eigenvectors = eigenvectors;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:isNonSingular()Z",
            "method_body": "public boolean isNonSingular() {\nfor (int i = 0; i < realEigenvalues.length; ++i) {\nif (realEigenvalues[i] == 0 &&\nreturn true;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getRealEigenvalues()[D",
            "method_body": "public double[] getRealEigenvalues() {\nreturn realEigenvalues.clone();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.NormalDistribution:density(D)D",
            "method_body": "public double density(double x) {\nfinal double x0 = x - mean;\nfinal double x1 = x0 / standardDeviation;\nreturn FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.NormalDistribution:<init>(DD)V",
            "method_body": "public NormalDistribution(double mean, double sd)\nthis(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n}",
            "method_id": 19
        }
    ]
}