{
    "bug_id": 14,
    "test_id": 0,
    "test_name": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.testCompatibilityWithOriginalVersion",
    "test_body": "public void testCompatibilityWithOriginalVersion() {\n// see CODEC-187\n// comparison: http://stevemorse.org/census/soundex.html\n185: Map<String, String> args = new TreeMap<String, String>();\nargs.put(\"nameType\", \"GENERIC\");\nargs.put(\"ruleType\", \"APPROX\");\n189: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\");\nassertEquals(encode(args, true, \"Bendzin\"), \"bndzn|bntsn|bnzn|vndzn|vntsn\");\n192: args.put(\"nameType\", \"ASHKENAZI\");\nargs.put(\"ruleType\", \"APPROX\");\n195: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom\");\nassertEquals(encode(args, true, \"Halpern\"), \"YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn\");\n198: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<...dzn|bntsn|bnzn|vndzn[]> but was:<...dzn|bntsn|bnzn|vndzn[|vntsn]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.testCompatibilityWithOriginalVersion(PhoneticEngineRegressionTest.java:190)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<init>(Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)V",
            "method_body": "public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\nthis.phonemeText = new StringBuilder(phonemeText);\nthis.languages = languages;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$4:isMatch(Ljava/lang/CharSequence;)Z",
            "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;)V",
            "method_body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\nthis.pattern = pattern;\nthis.lContext = pattern(lContext + \"$\");\nthis.rContext = pattern(\"^\" + rContext);\nthis.phoneme = phoneme;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$1:isMatch(Ljava/lang/CharSequence;)Z",
            "method_body": "boolean isMatch(CharSequence input);\npublic static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\nreturn true;\n};",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule:pattern(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$RPattern;",
            "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule:parsePhonemeExpr(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;",
            "method_body": "private static PhonemeExpr parsePhonemeExpr(final String ph) {\nif (ph.startsWith(\"(\")) { // we have a bracketed list of options\nif (!ph.endsWith(\")\")) {\nfinal List<Phoneme> phs = new ArrayList<Phoneme>();\nfinal String body = ph.substring(1, ph.length() - 1);\nfor (final String part : body.split(\"[|]\")) {\nphs.add(parsePhoneme(part));\nif (body.startsWith(\"|\") || body.endsWith(\"|\")) {\nphs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\nreturn new PhonemeList(phs);\nreturn parsePhoneme(ph);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Languages:langResourceName(Lorg/apache/commons/codec/language/bm/NameType;)Ljava/lang/String;",
            "method_body": "private static String langResourceName(final NameType nameType) {\nreturn String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:<init>(Ljava/util/Map;Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;II)V",
            "method_body": "public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\nfinal PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\nif (finalRules == null) {\nthis.finalRules = finalRules;\nthis.phonemeBuilder = phonemeBuilder;\nthis.input = input;\nthis.i = i;\nthis.maxPhonemes = maxPhonemes;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule:startsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
            "method_body": "private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\nif (prefix.length() > input.length()) {\nreturn false;\nfor (int i = 0; i < prefix.length(); i++) {\nif (input.charAt(i) != prefix.charAt(i)) {\nreturn false;\nreturn true;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$5:isMatch(Ljava/lang/CharSequence;)Z",
            "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Languages$1:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn true;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:join(Ljava/lang/Iterable;Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "private static String join(final Iterable<String> strings, final String sep) {\nfinal StringBuilder sb = new StringBuilder();\nfinal Iterator<String> si = strings.iterator();\nif (si.hasNext()) {\nsb.append(si.next());\nwhile (si.hasNext()) {\nreturn sb.toString();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule:getInstanceMap(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/util/Map;",
            "method_body": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\nfinal Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\nif (rules == null) {\nreturn rules;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:getPhonemeBuilder()Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
            "method_body": "public PhonemeBuilder getPhonemeBuilder() {\nreturn this.phonemeBuilder;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getPhonemeText()Ljava/lang/CharSequence;",
            "method_body": "public CharSequence getPhonemeText() {\nreturn this.phonemeText;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$3:isMatch(Ljava/lang/CharSequence;)Z",
            "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\nif (!boxes) {\nif (startsWith && endsWith) {\nif (content.length() == 0) {\nreturn new RPattern() {\nreturn input.length() == 0;\nreturn new RPattern() {\nreturn input.equals(content);\n} else if ((startsWith || endsWith) && content.length() == 0) {\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn startsWith(input, content);\n} else if (endsWith) {\nreturn new RPattern() {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\nif (startsWith && endsWith) {\nreturn new RPattern() {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (startsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n} else if (endsWith) {\nreturn new RPattern() {\nreturn input.length() > 0 &&\nreturn new RPattern() {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:getPhonemes()Ljava/util/Set;",
            "method_body": "public Set<Rule.Phoneme> getPhonemes() {\nreturn this.phonemes;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$PhonemeList:getPhonemes()Ljava/util/List;",
            "method_body": "Iterable<Phoneme> getPhonemes();\npublic PhonemeList(final List<Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}\nreturn this.phonemes;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:append(Ljava/lang/CharSequence;)Lorg/apache/commons/codec/language/bm/Rule$Phoneme;",
            "method_body": "public Phoneme append(final CharSequence str) {\nthis.phonemeText.append(str);\nreturn this;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.codec.language.bm.Lang:<init>(Ljava/util/List;Lorg/apache/commons/codec/language/bm/Languages;)V",
            "method_body": "private Lang(final List<LangRule> rules, final Languages languages) {\nthis.rules = Collections.unmodifiableList(rules);\nthis.languages = languages;\n}",
            "method_id": 19
        }
    ]
}