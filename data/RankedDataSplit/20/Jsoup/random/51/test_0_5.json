{
    "bug_id": 51,
    "test_id": 0,
    "test_name": "org.jsoup.parser.HtmlParserTest.testSupportsNonAsciiTags",
    "test_body": "887: @Test public void testSupportsNonAsciiTags() {\n888: String body = \"<\u00e9\u0080\u00b2\u00e6\u008d\u0097\u00e6\u008e\u00a8\u00e7\u00a7\u00bb\u00e3\u0082\u00b0\u00e3\u0083\u00a9\u00e3\u0083\u0095>Yes</\u00e9\u0080\u00b2\u00e6\u008d\u0097\u00e6\u008e\u00a8\u00e7\u00a7\u00bb\u00e3\u0082\u00b0\u00e3\u0083\u00a9\u00e3\u0083\u0095>\";\n889: Document doc = Jsoup.parse(body);\n890: Elements els = doc.select(\"\u00e9\u0080\u00b2\u00e6\u008d\u0097\u00e6\u008e\u00a8\u00e7\u00a7\u00bb\u00e3\u0082\u00b0\u00e3\u0083\u00a9\u00e3\u0083\u0095\");\n891: assertEquals(\"Yes\", els.text());\n892: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:runParser()V",
            "method_body": "protected void runParser() {\nToken token = tokeniser.read();\nprocess(token);\ntoken.reset();\nif (token.type == Token.TokenType.EOF)\nbreak;\n}\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.Token:asComment()Lorg/jsoup/parser/Token$Comment;",
            "method_body": "final Comment asComment() {\nreturn (Comment) this;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "boolean isEmpty() {\nreturn pos >= length;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNodeSize()I",
            "method_body": "public final int childNodeSize() {\nreturn childNodes.size();\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Character;)V",
            "method_body": "void insert(Token.Character characterToken) {\nString tagName = currentElement().tagName();\nif (tagName.equals(\"script\") || tagName.equals(\"style\"))\nnode = new TextNode(characterToken.getData(), baseUri);\ncurrentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:<init>(Lorg/jsoup/select/NodeVisitor;)V",
            "method_body": "public NodeTraversor(NodeVisitor visitor) {\nthis.visitor = visitor;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.select.Evaluator$Tag:matches(Lorg/jsoup/nodes/Element;Lorg/jsoup/nodes/Element;)Z",
            "method_body": "public abstract boolean matches(Element root, Element element);\npublic Tag(String tagName) {\nthis.tagName = tagName;\n}\nreturn (element.tagName().equals(tagName));\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNode(I)Lorg/jsoup/nodes/Node;",
            "method_body": "public Node childNode(int index) {\nreturn childNodes.get(index);\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:<init>()V",
            "method_body": "final StringBuilder data = new StringBuilder();\nboolean bogus = false;\nreset(data);\nbogus = false;\nreturn this;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn pos >= length ? EOF : input[pos];\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:put(Lorg/jsoup/nodes/Attribute;)V",
            "method_body": "public void put(Attribute attribute) {\nValidate.notNull(attribute);\nif (attributes == null)\nattributes = new LinkedHashMap<String, Attribute>(2);\nattributes.put(attribute.getKey(), attribute);\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(final String str) {\nif (charsString == null) {\ncharsString = str;\nif (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\ncharsBuilder.append(charsString);\ncharsBuilder.append(str);\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:loadEntities(Ljava/lang/String;)Ljava/util/Map;",
            "method_body": "private static Map<String, Character> loadEntities(String filename) {\nProperties properties = new Properties();\nMap<String, Character> entities = new HashMap<String, Character>();\nInputStream in = Entities.class.getResourceAsStream(filename);\nproperties.load(in);\nin.close();\n}\nfor (Map.Entry entry: properties.entrySet()) {\nCharacter val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\nString name = (String) entry.getKey();\nentities.put(name, val);\n}\nreturn entities;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:<init>(II)V",
            "method_body": "ParseErrorList(int initialCapacity, int maxSize) {\nsuper(initialCapacity);\nthis.maxSize = maxSize;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$1:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\n} else if (t.isComment()) {\n} else if (t.isDoctype()) {\ntb.transition(BeforeHtml);\nreturn tb.process(t); // re-process token\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Comment;)V",
            "method_body": "void insert(Token.Comment commentToken) {\nComment comment = new Comment(commentToken.getData(), baseUri);\ninsertNode(comment);\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<clinit>()V",
            "method_body": "private Tag tag;\nprivate static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\nsuper(baseUri, attributes);\nValidate.notNull(tag);\nthis.tag = tag;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(Z)V",
            "method_body": "public static void isFalse(boolean val) {\nif (val)\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.nodes.Comment:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public Comment(String data, String baseUri) {\nsuper(baseUri);\nattributes.put(COMMENT_KEY, data);\n}",
            "method_id": 119
        }
    ]
}