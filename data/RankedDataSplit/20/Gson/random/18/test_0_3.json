{
    "bug_id": 18,
    "test_id": 0,
    "test_name": "com.google.gson.functional.CollectionTest.testIssue1107",
    "test_body": "public void testIssue1107() {\nString json = \"{\\n\" +\n\"  \\\"inBig\\\": {\\n\" +\n\"    \\\"key\\\": [\\n\" +\n\"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n\"    ]\\n\" +\n\"  }\\n\" +\n\"}\";\nBigClass bigClass = new Gson().fromJson(json, BigClass.class);\nSmallClass small = bigClass.inBig.get(\"key\").get(0);\nassertNotNull(small);",
    "stack_trace": "java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.google.gson.functional.CollectionTest$SmallClass\nat com.google.gson.functional.CollectionTest.testIssue1107(CollectionTest.java:410)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}",
            "method_id": 60
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
            "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\nif (previous != null) {\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
            "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};",
            "method_id": 63
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor$13:construct()Ljava/lang/Object;",
            "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\n} else if (Set.class.isAssignableFrom(rawType)) {\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new ArrayList<Object>();\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedTreeMap<String, Object>();\nreturn null;\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
            "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
            "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
            "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
            "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}",
            "method_id": 69
        },
        {
            "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}",
            "method_id": 70
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\npublic static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n};",
            "method_id": 71
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
            "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}",
            "method_id": 72
        },
        {
            "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
            "method_body": "public static <T> Class<T> wrap(Class<T> type) {\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\nreturn (wrapped == null) ? type : wrapped;\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
            "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\nreader.setLenient(oldLenient);\n}",
            "method_id": 76
        },
        {
            "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
            "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}",
            "method_id": 78
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
            "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}",
            "method_id": 79
        }
    ]
}