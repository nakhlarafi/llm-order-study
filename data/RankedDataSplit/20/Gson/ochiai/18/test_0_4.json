{
    "bug_id": 18,
    "test_id": 0,
    "test_name": "com.google.gson.functional.CollectionTest.testIssue1107",
    "test_body": "public void testIssue1107() {\nString json = \"{\\n\" +\n\"  \\\"inBig\\\": {\\n\" +\n\"    \\\"key\\\": [\\n\" +\n\"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n\"    ]\\n\" +\n\"  }\\n\" +\n\"}\";\nBigClass bigClass = new Gson().fromJson(json, BigClass.class);\nSmallClass small = bigClass.inBig.get(\"key\").get(0);\nassertNotNull(small);",
    "stack_trace": "java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.google.gson.functional.CollectionTest$SmallClass\nat com.google.gson.functional.CollectionTest.testIssue1107(CollectionTest.java:410)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
            "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}",
            "method_id": 80
        },
        {
            "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}",
            "method_id": 81
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}",
            "method_id": 82
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
            "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}",
            "method_id": 83
        },
        {
            "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}",
            "method_id": 84
        },
        {
            "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}",
            "method_id": 85
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}",
            "method_id": 86
        },
        {
            "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}",
            "method_id": 87
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
            "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.BEGIN_ARRAY;\nreturn JsonToken.STRING;\nreturn JsonToken.END_DOCUMENT;\n}",
            "method_id": 88
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
            "method_body": "public final Type getType() {\nreturn type;\n}",
            "method_id": 89
        },
        {
            "method_signature": "com.google.gson.Gson:<init>()V",
            "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}",
            "method_id": 90
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
            "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}",
            "method_id": 91
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
            "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\nif (throwOnEof) {\nreturn -1;\n}",
            "method_id": 92
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
            "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_ARRAY;\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_OBJECT;\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\n}",
            "method_id": 93
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
            "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}",
            "method_id": 94
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}",
            "method_id": 95
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}",
            "method_id": 96
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}",
            "method_id": 97
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n}",
            "method_id": 98
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
            "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}",
            "method_id": 99
        }
    ]
}