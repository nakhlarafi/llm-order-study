{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking",
    "test_body": "1002: public void testIteratorSequenceBreaking() throws IOException {\n1003: final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n1004: 1005: // Iterator hasNext() shouldn't break sequence\n1006: CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1007: int recordNumber = 0;\n1008: Iterator<CSVRecord> iter = parser.iterator();\n1009: recordNumber = 0;\n1010: while (iter.hasNext()) {\n1011: CSVRecord record = iter.next();\n1012: recordNumber++;\n1013: assertEquals(String.valueOf(recordNumber), record.get(0));\n1014: if (recordNumber >= 2) {\n1015: break;\n1016: }\n1017: }\n1018: iter.hasNext();\n1019: while (iter.hasNext()) {\n1020: CSVRecord record = iter.next();\n1021: recordNumber++;\n1022: assertEquals(String.valueOf(recordNumber), record.get(0));\n1023: }\n1024: 1025: // Consecutive enhanced for loops shouldn't break sequence\n1026: parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1027: recordNumber = 0;\n1028: for (CSVRecord record : parser) {\n1029: recordNumber++;\n1030: assertEquals(String.valueOf(recordNumber), record.get(0));\n1031: if (recordNumber >= 2) {\n1032: break;\n1033: }\n1034: }\n1035: for (CSVRecord record : parser) {\n1036: recordNumber++;\n1037: assertEquals(String.valueOf(recordNumber), record.get(0));\n1038: }\n1039: 1040: // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n1041: parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1042: recordNumber = 0;\n1043: for (CSVRecord record : parser) {\n1044: recordNumber++;\n1045: assertEquals(String.valueOf(recordNumber), record.get(0));\n1046: if (recordNumber >= 2) {\n1047: break;\n1048: }\n1049: }\n1050: parser.iterator().hasNext();\n1051: for (CSVRecord record : parser) {\n1052: recordNumber++;\n1053: assertEquals(String.valueOf(recordNumber), record.get(0));\n1054: }",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withIgnoreSurroundingSpaces(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withNullString(Ljava/lang/String;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withNullString(final String nullString) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withQuote(Ljava/lang/Character;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withQuote(final Character quoteChar) {\nif (isLineBreak(quoteChar)) {\nreturn new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withQuoteMode(Lorg/apache/commons/csv/QuoteMode;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withRecordSeparator(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withRecordSeparator(final char recordSeparator) {\nreturn withRecordSeparator(String.valueOf(recordSeparator));\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withRecordSeparator(Ljava/lang/String;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withRecordSeparator(final String recordSeparator) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withSystemRecordSeparator()Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withSystemRecordSeparator() {\nreturn withRecordSeparator(System.getProperty(\"line.separator\"));\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withTrim()Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withTrim() {\nreturn withTrim(true);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withTrim(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withTrim(final boolean trim) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.csv.Constants:<clinit>()V",
            "method_body": "static final char BACKSLASH = '\\\\';\nstatic final Character DOUBLE_QUOTE_CHAR = Character.valueOf('\"');\n}",
            "method_id": 69
        }
    ]
}