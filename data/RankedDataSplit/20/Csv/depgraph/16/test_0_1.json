{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking",
    "test_body": "1002: public void testIteratorSequenceBreaking() throws IOException {\n1003: final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n1004: 1005: // Iterator hasNext() shouldn't break sequence\n1006: CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1007: int recordNumber = 0;\n1008: Iterator<CSVRecord> iter = parser.iterator();\n1009: recordNumber = 0;\n1010: while (iter.hasNext()) {\n1011: CSVRecord record = iter.next();\n1012: recordNumber++;\n1013: assertEquals(String.valueOf(recordNumber), record.get(0));\n1014: if (recordNumber >= 2) {\n1015: break;\n1016: }\n1017: }\n1018: iter.hasNext();\n1019: while (iter.hasNext()) {\n1020: CSVRecord record = iter.next();\n1021: recordNumber++;\n1022: assertEquals(String.valueOf(recordNumber), record.get(0));\n1023: }\n1024: 1025: // Consecutive enhanced for loops shouldn't break sequence\n1026: parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1027: recordNumber = 0;\n1028: for (CSVRecord record : parser) {\n1029: recordNumber++;\n1030: assertEquals(String.valueOf(recordNumber), record.get(0));\n1031: if (recordNumber >= 2) {\n1032: break;\n1033: }\n1034: }\n1035: for (CSVRecord record : parser) {\n1036: recordNumber++;\n1037: assertEquals(String.valueOf(recordNumber), record.get(0));\n1038: }\n1039: 1040: // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n1041: parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n1042: recordNumber = 0;\n1043: for (CSVRecord record : parser) {\n1044: recordNumber++;\n1045: assertEquals(String.valueOf(recordNumber), record.get(0));\n1046: if (recordNumber >= 2) {\n1047: break;\n1048: }\n1049: }\n1050: parser.iterator().hasNext();\n1051: for (CSVRecord record : parser) {\n1052: recordNumber++;\n1053: assertEquals(String.valueOf(recordNumber), record.get(0));\n1054: }",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:<clinit>()V",
            "method_body": "private static final String[] EMPTY_STRING_ARRAY = new String[0];\nfinal long characterPosition) {\nthis.recordNumber = recordNumber;\nthis.values = values != null ? values : EMPTY_STRING_ARRAY;\nthis.mapping = mapping;\nthis.comment = comment;\nthis.characterPosition = characterPosition;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:parseSimpleToken(Lorg/apache/commons/csv/Token;I)Lorg/apache/commons/csv/Token;",
            "method_body": "private Token parseSimpleToken(final Token token, int ch) throws IOException {\nif (readEndOfLine(ch)) {\ntoken.type = EORECORD;\nbreak;\n} else if (isEndOfFile(ch)) {\n} else if (isDelimiter(ch)) {\n} else if (isEscape(ch)) {\ntoken.content.append((char) ch);\nch = reader.read(); // continue\nif (ignoreSurroundingSpaces) {\nreturn token;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isStartOfLine(I)Z",
            "method_body": "boolean isStartOfLine(final int ch) {\nreturn ch == LF || ch == CR || ch == UNDEFINED;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEscape(I)Z",
            "method_body": "boolean isEscape(final int ch) {\nreturn ch == escape;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isQuoteChar(I)Z",
            "method_body": "boolean isQuoteChar(final int ch) {\nreturn ch == quoteChar;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isCommentStart(I)Z",
            "method_body": "boolean isCommentStart(final int ch) {\nreturn ch == commentStart;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:nextToken(Lorg/apache/commons/csv/Token;)Lorg/apache/commons/csv/Token;",
            "method_body": "Token nextToken(final Token token) throws IOException {\nint lastChar = reader.getLastChar();\nint c = reader.read();\nboolean eol = readEndOfLine(c);\nif (ignoreEmptyLines) {\nwhile (eol && isStartOfLine(lastChar)) {\nif (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\ntoken.type = EOF;\nreturn token;\nif (isStartOfLine(lastChar) && isCommentStart(c)) {\nwhile (token.type == INVALID) {\nif (ignoreSurroundingSpaces) {\nif (isDelimiter(c)) {\n} else if (eol) {\n} else if (isQuoteChar(c)) {\n} else if (isEndOfFile(c)) {\nparseSimpleToken(token, c);\nreturn token;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:readEndOfLine(I)Z",
            "method_body": "boolean readEndOfLine(int ch) throws IOException {\nif (ch == CR && reader.lookAhead() == LF) {\nif (firstEol == null) {\nif (ch == LF) {\nthis.firstEol = LF_STRING;\n} else if (ch == CR) {\nreturn ch == LF || ch == CR;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEndOfFile(I)Z",
            "method_body": "boolean isEndOfFile(final int ch) {\nreturn ch == END_OF_STREAM;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isDelimiter(I)Z",
            "method_body": "boolean isDelimiter(final int ch) {\nreturn ch == delimiter;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:<init>(Lorg/apache/commons/csv/CSVFormat;Lorg/apache/commons/csv/ExtendedBufferedReader;)V",
            "method_body": "Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\nthis.reader = reader;\nthis.delimiter = format.getDelimiter();\nthis.escape = mapNullToDisabled(format.getEscapeCharacter());\nthis.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\nthis.commentStart = mapNullToDisabled(format.getCommentMarker());\nthis.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\nthis.ignoreEmptyLines = format.getIgnoreEmptyLines();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:<clinit>()V",
            "method_body": "private static final String CR_STRING = Character.toString(Constants.CR);\nprivate static final String LF_STRING = Character.toString(Constants.LF);\n* won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:mapNullToDisabled(Ljava/lang/Character;)C",
            "method_body": "private char mapNullToDisabled(final Character c) {\nreturn c == null ? DISABLED : c.charValue();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getLastChar()I",
            "method_body": "int getLastChar() {\nreturn lastChar;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:read()I",
            "method_body": "public int read() throws IOException {\nfinal int current = super.read();\nif (current == CR || current == LF && lastChar != CR) {\neolCounter++;\nlastChar = current;\nthis.position++;\nreturn lastChar;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:<init>(Ljava/io/Reader;)V",
            "method_body": "private int lastChar = UNDEFINED;\nsuper(reader);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.csv.Token:<init>()V",
            "method_body": "Token.Type type = INVALID;\nfinal StringBuilder content = new StringBuilder(INITIAL_TOKEN_LENGTH);\ncontent.setLength(0);\ntype = INVALID;\nisReady = false;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.csv.Token$Type:<clinit>()V",
            "method_body": "private static final int INITIAL_TOKEN_LENGTH = 50;\nenum Type {\nINVALID,\nTOKEN,\nEOF,\nEORECORD,\nCOMMENT\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreSurroundingSpaces()Z",
            "method_body": "public boolean getIgnoreSurroundingSpaces() {\nreturn ignoreSurroundingSpaces;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreEmptyLines()Z",
            "method_body": "public boolean getIgnoreEmptyLines() {\nreturn ignoreEmptyLines;\n}",
            "method_id": 39
        }
    ]
}