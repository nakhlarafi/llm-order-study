{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking",
    "test_body": "public void testIteratorSequenceBreaking() throws IOException {\nfinal String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n1005: // Iterator hasNext() shouldn't break sequence\nCSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nint recordNumber = 0;\nIterator<CSVRecord> iter = parser.iterator();\nrecordNumber = 0;\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\niter.hasNext();\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1025: // Consecutive enhanced for loops shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1040: // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nparser.iterator().hasNext();\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.Token:reset()V",
            "method_body": "void reset() {\ncontent.setLength(0);\ntype = INVALID;\nisReady = false;\n}",
            "method_id": 20,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:toStringArray([Ljava/lang/Object;)[Ljava/lang/String;",
            "method_body": "private String[] toStringArray(final Object[] values) {\nif (values == null) {\nreturn null;\n}",
            "method_id": 21,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withDelimiter(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withDelimiter(final char delimiter) {\nif (isLineBreak(delimiter)) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 22,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withEscape(Ljava/lang/Character;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withEscape(final Character escape) {\nif (isLineBreak(escape)) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n}",
            "method_id": 23,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withQuote(Ljava/lang/Character;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withQuote(final Character quoteChar) {\nif (isLineBreak(quoteChar)) {\nreturn new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n}",
            "method_id": 24,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.csv.Assertions:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(final Object parameter, final String parameterName) {\nif (parameter == null) {\n}",
            "method_id": 25,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getHeader()[Ljava/lang/String;",
            "method_body": "public String[] getHeader() {\nreturn header != null ? header.clone() : null;\n}",
            "method_id": 26,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(C)Z",
            "method_body": "private static boolean isLineBreak(final char c) {\nreturn c == LF || c == CR;\n}",
            "method_id": 27,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(Ljava/lang/Character;)Z",
            "method_body": "private static boolean isLineBreak(final Character c) {\nreturn c != null && isLineBreak(c.charValue());\n}",
            "method_id": 28,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getCommentMarker()Ljava/lang/Character;",
            "method_body": "public Character getCommentMarker() {\nreturn commentMarker;\n}",
            "method_id": 29,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getDelimiter()C",
            "method_body": "public char getDelimiter() {\nreturn delimiter;\n}",
            "method_id": 30,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getEscapeCharacter()Ljava/lang/Character;",
            "method_body": "public Character getEscapeCharacter() {\nreturn escapeCharacter;\n}",
            "method_id": 31,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreEmptyLines()Z",
            "method_body": "public boolean getIgnoreEmptyLines() {\nreturn ignoreEmptyLines;\n}",
            "method_id": 32,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreSurroundingSpaces()Z",
            "method_body": "public boolean getIgnoreSurroundingSpaces() {\nreturn ignoreSurroundingSpaces;\n}",
            "method_id": 33,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getNullString()Ljava/lang/String;",
            "method_body": "public String getNullString() {\nreturn nullString;\n}",
            "method_id": 34,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getQuoteCharacter()Ljava/lang/Character;",
            "method_body": "public Character getQuoteCharacter() {\nreturn quoteCharacter;\n}",
            "method_id": 35,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getTrim()Z",
            "method_body": "public boolean getTrim() {\nreturn trim;\n}",
            "method_id": 36,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:parse(Ljava/io/Reader;)Lorg/apache/commons/csv/CSVParser;",
            "method_body": "public CSVParser parse(final Reader in) throws IOException {\nreturn new CSVParser(in, this);\n}",
            "method_id": 37,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withAllowMissingColumnNames()Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withAllowMissingColumnNames() {\nreturn this.withAllowMissingColumnNames(true);\n}",
            "method_id": 38,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withAllowMissingColumnNames(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 39,
            "loc": 3
        }
    ]
}