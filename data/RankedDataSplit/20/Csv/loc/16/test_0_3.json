{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking",
    "test_body": "public void testIteratorSequenceBreaking() throws IOException {\nfinal String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n1005: // Iterator hasNext() shouldn't break sequence\nCSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nint recordNumber = 0;\nIterator<CSVRecord> iter = parser.iterator();\nrecordNumber = 0;\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\niter.hasNext();\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1025: // Consecutive enhanced for loops shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1040: // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nparser.iterator().hasNext();\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.Lexer:isDelimiter(I)Z",
            "method_body": "boolean isDelimiter(final int ch) {\nreturn ch == delimiter;\n}",
            "method_id": 60,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEscape(I)Z",
            "method_body": "boolean isEscape(final int ch) {\nreturn ch == escape;\n}",
            "method_id": 61,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isQuoteChar(I)Z",
            "method_body": "boolean isQuoteChar(final int ch) {\nreturn ch == quoteChar;\n}",
            "method_id": 62,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isCommentStart(I)Z",
            "method_body": "boolean isCommentStart(final int ch) {\nreturn ch == commentStart;\n}",
            "method_id": 63,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:<init>(Ljava/io/Reader;)V",
            "method_body": "private int lastChar = UNDEFINED;\nsuper(reader);\n}",
            "method_id": 64,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getLastChar()I",
            "method_body": "int getLastChar() {\nreturn lastChar;\n}",
            "method_id": 65,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getPosition()J",
            "method_body": "long getPosition() {\nreturn this.position;\n}",
            "method_id": 66,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:isClosed()Z",
            "method_body": "public boolean isClosed() {\nreturn closed;\n}",
            "method_id": 67,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:get(I)Ljava/lang/String;",
            "method_body": "public String get(final int i) {\nreturn values[i];\n}",
            "method_id": 68,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<clinit>()V",
            "method_body": "public static final CSVFormat MYSQL = DEFAULT\n* characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}. Values are trimmed.",
            "method_id": 69,
            "loc": 2
        }
    ]
}