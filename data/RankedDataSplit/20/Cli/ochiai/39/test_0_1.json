{
    "bug_id": 39,
    "test_id": 0,
    "test_name": "org.apache.commons.cli.PatternOptionBuilderTest.testExistingFilePatternFileNotExist",
    "test_body": "public void testExistingFilePatternFileNotExist() throws Exception {\nfinal Options options = PatternOptionBuilder.parsePattern(\"f<\");\nfinal CommandLineParser parser = new PosixParser();\nfinal CommandLine line = parser.parse(options, new String[] { \"-f\", \"non-existing.file\" });\n180: assertNull(\"option f parsed\", line.getOptionObject(\"f\"));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: option f parsed expected null, but was:<non-existing.file>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotNull(Assert.java:664)\nat org.junit.Assert.assertNull(Assert.java:646)\nat org.apache.commons.cli.PatternOptionBuilderTest.testExistingFilePatternFileNotExist(PatternOptionBuilderTest.java:180)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
            "method_body": "public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException\nwhile (iter.hasNext())\nfinal String str = iter.next();\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\n}\nif (opt.getValues() == null && !opt.hasOptionalArg())\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
            "method_body": "private void gobble(final Iterator<String> iter)\nif (eatTheRest)\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Lorg/apache/commons/cli/Option;)Ljava/lang/String;",
            "method_body": "public String getOptionValue(final Option option)\nif (option == null)\nfinal String[] values = getOptionValues(option);\nreturn (values == null) ? null : values[0];\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:init()V",
            "method_body": "private void init()\neatTheRest = false;\ntokens.clear();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
            "method_body": "protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\ninit();\nthis.options = options;\nfinal Iterator<String> iter = Arrays.asList(arguments).iterator();\nwhile (iter.hasNext())\nfinal String token = iter.next();\nif (\"-\".equals(token) || \"--\".equals(token))\nelse if (token.startsWith(\"--\"))\nelse if (token.startsWith(\"-\"))\nif (token.length() == 2 || options.hasOption(token))\nprocessOptionToken(token, stopAtNonOption);\nprocessNonOptionToken(token, stopAtNonOption);\ngobble(iter);\n}\nreturn tokens.toArray(new String[tokens.size()]);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "static String stripLeadingAndTrailingQuotes(String str)\nfinal int length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\nreturn str;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
            "method_body": "public String[] getValues()\nreturn hasNoValues() ? null : values.toArray(new String[values.size()]);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
            "method_body": "private boolean hasNoValues()\nreturn values.isEmpty();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Lorg/apache/commons/cli/Option;)[Ljava/lang/String;",
            "method_body": "public String[] getOptionValues(final Option option)\nfinal List<String> values = new ArrayList<String>();\nfor (final Option processedOption : options)\nif (processedOption.equals(option))\nvalues.addAll(processedOption.getValuesList());\n}\nreturn values.isEmpty() ? null : values.toArray(new String[values.size()]);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
            "method_body": "public List<String> getValuesList()\nreturn values;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
            "method_body": "public boolean hasValueSeparator()\nreturn valuesep > 0;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
            "method_body": "void addValueForProcessing(final String value)\nif (numberOfArgs == UNINITIALIZED)\nprocessValue(value);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
            "method_body": "private void processValue(String value)\nif (hasValueSeparator())\nadd(value);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
            "method_body": "private void add(final String value)\nif (!acceptsArg())\nvalues.add(value);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
            "method_body": "boolean acceptsArg()\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
            "method_body": "public CommandLine parse(final Options options, final String[] arguments) throws ParseException\nreturn parse(options, arguments, null, false);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
            "method_body": "protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException\nfinal boolean hasOption = getOptions().hasOption(arg);\nif (!hasOption)\nfinal Option opt = (Option) getOptions().getOption(arg).clone();\nupdateRequiredOptions(opt);\nif (opt.hasArg())\nprocessArgs(opt, iter);\ncmd.addOption(opt);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
            "method_body": "protected List getRequiredOptions()\nreturn requiredOptions;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
            "method_body": "protected void checkRequiredOptions() throws MissingOptionException\nif (!getRequiredOptions().isEmpty())\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
            "method_body": "private void updateRequiredOptions(final Option opt) throws ParseException\nif (opt.isRequired())\nif (getOptions().getOptionGroup(opt) != null)\n}",
            "method_id": 39
        }
    ]
}