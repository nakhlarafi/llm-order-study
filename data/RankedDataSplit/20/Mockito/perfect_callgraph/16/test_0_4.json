{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest.shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS",
    "test_body": "public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\nIMethods mock = mock(IMethods.class, RETURNS_MOCKS);\nwhen(mock.objectReturningMethodNoArgs()).thenReturn(null);\n}\n",
    "stack_trace": "org.mockito.exceptions.misusing.MissingMethodInvocationException:\nwhen() requires an argument which has to be a method call on a mock.\nFor example:\nwhen(mock.getArticles()).thenReturn(articles);\n\nAlso, this error might show up because you stub final/private/equals() or hashCode() method.\nThose methods *cannot* be stubbed/verified.\n\nat org.mockito.exceptions.Reporter.missingMethodInvocation(Reporter.java:77)\nat org.mockito.internal.MockitoCore.stub(MockitoCore.java:43)\nat org.mockito.internal.MockitoCore.when(MockitoCore.java:56)\nat org.mockito.Mockito.when(Mockito.java:994)\nat org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest.shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS(StubbingMocksThatAreConfiguredToReturnMocksTest.java:19)",
    "covered_methods": [
        {
            "method_signature": "org.mockito.internal.util.ObjectMethodsGuru:isHashCodeMethod(Ljava/lang/reflect/Method;)Z",
            "method_body": "public boolean isHashCodeMethod(Method method) {\nreturn method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.mockito.internal.progress.ThreadSafeMockingProgress:getArgumentMatcherStorage()Lorg/mockito/internal/progress/ArgumentMatcherStorage;",
            "method_body": "public ArgumentMatcherStorage getArgumentMatcherStorage() {\nreturn threadSafely().getArgumentMatcherStorage();\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.mockito.internal.stubbing.InvocationContainerImpl:<init>(Lorg/mockito/internal/progress/MockingProgress;)V",
            "method_body": "public InvocationContainerImpl(MockingProgress mockingProgress) {\nthis.mockingProgress = mockingProgress;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:setConstructorsAccessible(Ljava/lang/Class;Z)V",
            "method_body": "private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\nfor (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\nconstructor.setAccessible(accessible);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.mockito.MockitoAnnotations:scan(Ljava/lang/Object;Ljava/lang/Class;)V",
            "method_body": "private static void scan(Object testClass, Class<?> clazz) {\nAnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\nField[] fields = clazz.getDeclaredFields();\nfor (Field field : fields) {\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.mockito.internal.verification.RegisteredInvocations:add(Lorg/mockito/internal/invocation/Invocation;)V",
            "method_body": "public void add(Invocation invocation) {\ninvocations.add(invocation);\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.mockito.internal.util.MockName:<init>(Ljava/lang/String;Ljava/lang/Class;)V",
            "method_body": "public MockName(String mockName, Class classToMock) {\nif (mockName == null) {\nthis.mockName = toInstanceName(classToMock);\nthis.surrogate = true;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.mockito.internal.progress.ThreadSafeMockingProgress:reportOngoingStubbing(Lorg/mockito/internal/progress/IOngoingStubbing;)V",
            "method_body": "public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\nthreadSafely().reportOngoingStubbing(iOngoingStubbing);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:createProxy(Ljava/lang/Class;Lorg/mockito/cglib/proxy/MethodInterceptor;)Ljava/lang/Object;",
            "method_body": "private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\nFactory proxy = (Factory) objenesis.newInstance(proxyClass);\nproxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\nreturn proxy;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.mockito.internal.invocation.Invocation:isToString(Lorg/mockito/invocation/InvocationOnMock;)Z",
            "method_body": "public static boolean isToString(InvocationOnMock invocation) {\nreturn new ObjectMethodsGuru().isToString(invocation.getMethod());\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.mockito.internal.invocation.InvocationMatcher:<init>(Lorg/mockito/internal/invocation/Invocation;Ljava/util/List;)V",
            "method_body": "public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\nthis.invocation = invocation;\nif (matchers.isEmpty()) {\nthis.matchers = invocation.argumentsToMatchers();\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:createProxyClass(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/Class;",
            "method_body": "private Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\nif (mockedType == Object.class) {\nmockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\nEnhancer enhancer = new Enhancer() {\nenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));\nenhancer.setUseFactory(true);\nif (mockedType.isInterface()) {\nenhancer.setSuperclass(Object.class);\nenhancer.setInterfaces(prepend(mockedType, interfaces));\nenhancer.setSuperclass(mockedType);\nenhancer.setInterfaces(interfaces);\nenhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\nenhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\nif (mockedType.getSigners() != null) {\nenhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\nreturn enhancer.createClass();\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.mockito.internal.creation.MockSettingsImpl:getSpiedInstance()Ljava/lang/Object;",
            "method_body": "public Object getSpiedInstance() {\nreturn spiedInstance;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.mockito.internal.progress.SequenceNumber:next()I",
            "method_body": "public static synchronized int next() {\nreturn sequenceNumber++;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.mockito.internal.configuration.GlobalConfiguration:validate()V",
            "method_body": "public static void validate() {\nnew GlobalConfiguration();\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.mockito.internal.progress.MockingProgressImpl:pullOngoingStubbing()Lorg/mockito/internal/progress/IOngoingStubbing;",
            "method_body": "public IOngoingStubbing pullOngoingStubbing() {\nIOngoingStubbing temp = iOngoingStubbing;\niOngoingStubbing = null;\nreturn temp;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl:pullMatchers()Ljava/util/List;",
            "method_body": "public List<Matcher> pullMatchers() {\nif (matcherStack.isEmpty()) {\nreturn Collections.emptyList();\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.SearchingClassLoader:combine(Ljava/util/List;)Ljava/lang/ClassLoader;",
            "method_body": "private static ClassLoader combine(List<ClassLoader> parentLoaders) {\nClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\nfor (int i = parentLoaders.size()-2; i >= 0; i--) {\nreturn loader;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.mockito.Mockito:mock(Ljava/lang/Class;Lorg/mockito/stubbing/Answer;)Ljava/lang/Object;",
            "method_body": "public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\nreturn mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.mockito.internal.MockHandler:handle(Lorg/mockito/internal/invocation/Invocation;)Ljava/lang/Object;",
            "method_body": "public Object handle(Invocation invocation) throws Throwable {\nif (invocationContainerImpl.hasAnswersForStubbing()) {\nVerificationMode verificationMode = mockingProgress.pullVerificationMode();\nInvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\nmockingProgress.validateState();\nif (verificationMode != null) {\ninvocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\nOngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\nmockingProgress.reportOngoingStubbing(ongoingStubbing);\nStubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\nif (!invocation.isVoid() && stubbedInvocation == null) {\nmockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\nif (stubbedInvocation != null) {\nObject ret = mockSettings.getDefaultAnswer().answer(invocation);\ninvocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\nreturn ret;\n}",
            "method_id": 99
        }
    ]
}