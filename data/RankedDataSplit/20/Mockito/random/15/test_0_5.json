{
    "bug_id": 15,
    "test_id": 0,
    "test_name": "org.mockitousage.bugs.InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.shouldInjectUsingPropertySetterIfAvailable",
    "test_body": "public void shouldInjectUsingPropertySetterIfAvailable() {\nassertTrue(awaitingInjection.propertySetterUsed);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.mockitousage.bugs.InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.shouldInjectUsingPropertySetterIfAvailable(InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java:25)",
    "covered_methods": [
        {
            "method_signature": "org.mockito.internal.configuration.injection.FinalMockCandidateFilter$1:thenInject()Z",
            "method_body": "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\nif(mocks.size() == 1) {\nfinal Object matchingMock = mocks.iterator().next();\nreturn new OngoingInjecter() {\nnew FieldSetter(fieldInstance, field).set(matchingMock);\n}\nreturn true;\nreturn new OngoingInjecter() {\nreturn false;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.mockito.internal.util.MockCreationValidator:validateType(Ljava/lang/Class;)V",
            "method_body": "public void validateType(Class classToMock) {\nif (!isTypeMockable(classToMock)) {\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.mockito.Mockito:withSettings()Lorg/mockito/MockSettings;",
            "method_body": "public static MockSettings withSettings() {\nreturn new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.mockito.internal.configuration.InjectingAnnotationEngine:injectMocks(Ljava/lang/Object;)V",
            "method_body": "public void injectMocks(Object testClass) {\nClass<?> clazz = testClass.getClass();\nSet<Field> mockDependents = new HashSet<Field>();\nSet<Object> mocks = new HashSet<Object>();\nwhile (clazz != Object.class) {\nmockDependents.addAll(scanForInjection(testClass, clazz));\nmocks.addAll(scanMocks(testClass, clazz));\nclazz = clazz.getSuperclass();\nnew DefaultInjectionEngine().injectMocksOnFields(mockDependents, mocks, testClass);\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.mockito.internal.configuration.injection.FinalMockCandidateFilter$2:<init>(Lorg/mockito/internal/configuration/injection/FinalMockCandidateFilter;)V",
            "method_body": "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\nif(mocks.size() == 1) {\nfinal Object matchingMock = mocks.iterator().next();\nreturn new OngoingInjecter() {\nnew FieldSetter(fieldInstance, field).set(matchingMock);\n}\nreturn true;\nreturn new OngoingInjecter() {\nreturn false;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.mockito.internal.util.MockCreationValidator:isTypeMockable(Ljava/lang/Class;)Z",
            "method_body": "public boolean isTypeMockable(Class<?> clz) {\nreturn ClassImposterizer.INSTANCE.canImposterise(clz);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.SearchingClassLoader:combineLoadersOf([Ljava/lang/Class;)Ljava/lang/ClassLoader;",
            "method_body": "public static ClassLoader combineLoadersOf(Class<?>... classes) {\nreturn combineLoadersOf(classes[0], classes);\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.mockito.internal.progress.MockingProgressImpl:mockingStarted(Ljava/lang/Object;Ljava/lang/Class;Lorg/mockito/MockSettings;)V",
            "method_body": "public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\nif (listener != null && listener instanceof MockingStartedListener) {\nvalidateMostStuff();\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.mockito.internal.util.reflection.FieldInitializer:acquireFieldInstance(Ljava/lang/Object;Ljava/lang/reflect/Field;)Ljava/lang/Object;",
            "method_body": "private Object acquireFieldInstance(Object testClass, Field field) throws IllegalAccessException {\nObject fieldInstance = field.get(testClass);\nif(fieldInstance != null) {\ninitializeField(testClass, field);\nreturn field.get(testClass);\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.mockito.internal.configuration.InjectingAnnotationEngine:process(Ljava/lang/Class;Ljava/lang/Object;)V",
            "method_body": "public void process(Class<?> context, Object testClass) {\ndelegate.process(context, testClass);\nspyAnnotationEngine.process(context, testClass);\nField[] fields = context.getDeclaredFields();\nfor (Field field : fields) {\nif (field.isAnnotationPresent(InjectMocks.class)) {\nassertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\ninjectMocks(testClass);\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.mockito.internal.configuration.DefaultInjectionEngine:injectMocksOnFields(Ljava/util/Set;Ljava/util/Set;Ljava/lang/Object;)V",
            "method_body": "public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\nfor (Field field : testClassFields) {\nObject fieldInstance = null;\nfieldInstance = new FieldInitializer(testClass, field).initialize();\n}\nClass<?> fieldClass = fieldInstance.getClass();\nwhile (fieldClass != Object.class) {\ninjectMockCandidate(fieldClass, mocks, fieldInstance);\nfieldClass = fieldClass.getSuperclass();\n}\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:setConstructorsAccessible(Ljava/lang/Class;Z)V",
            "method_body": "private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\nfor (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:canImposterise(Ljava/lang/Class;)Z",
            "method_body": "public boolean canImposterise(Class<?> type) {\nreturn !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n}",
            "method_id": 112
        }
    ]
}