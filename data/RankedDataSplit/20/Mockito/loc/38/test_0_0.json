{
    "bug_id": 38,
    "test_id": 0,
    "test_name": "org.mockitousage.bugs.ActualInvocationHasNullArgumentNPEBugTest.shouldAllowPassingNullArgument",
    "test_body": "public void shouldAllowPassingNullArgument() {\n//given\nFun mockFun = mock(Fun.class);\nwhen(mockFun.doFun((String) anyObject())).thenReturn(\"value\");\n25: //when\nmockFun.doFun(null);\n28: //then\ntry {\nverify(mockFun).doFun(\"hello\");\n} catch(AssertionError r) {",
    "stack_trace": "java.lang.NullPointerException\nat org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(ArgumentMatchingTool.java:48)\nat org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(ArgumentMatchingTool.java:30)\nat org.mockito.internal.verification.checkers.MissingInvocationChecker.check(MissingInvocationChecker.java:38)\nat org.mockito.internal.verification.Times.verify(Times.java:34)\nat org.mockito.internal.MockHandler.intercept(MockHandler.java:74)\nat org.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:46)\nat org.mockitousage.bugs.ActualInvocationHasNullArgumentNPEBugTest$Fun$$EnhancerByMockitoWithCGLIB$$9a91cf77.doFun(<generated>)\nat org.mockitousage.bugs.ActualInvocationHasNullArgumentNPEBugTest.shouldAllowPassingNullArgument(ActualInvocationHasNullArgumentNPEBugTest.java:30)",
    "covered_methods": [
        {
            "method_signature": "org.mockito.internal.MockHandler:intercept(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lorg/mockito/cglib/proxy/MethodProxy;)Ljava/lang/Object;",
            "method_body": "public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\nif (mockitoStubber.hasAnswersForStubbing()) {\nVerificationMode verificationMode = mockingProgress.pullVerificationMode();\nInvocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\nInvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\nmockingProgress.validateState();\nif (verificationMode != null) {\nVerificationDataImpl data = new VerificationDataImpl(registeredInvocations.getAll(), invocationMatcher);\nverificationMode.verify(data);\nreturn null;\nregisteredInvocations.add(invocationMatcher.getInvocation());\nmockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\nOngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\nmockingProgress.reportOngoingStubbing(ongoingStubbing);\nAnswer<?> stubbedAnswer = mockitoStubber.findAnswerFor(invocation);\nif (!invocation.isVoid() && stubbedAnswer == null) {\nmockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\nif (stubbedAnswer != null) {\nmockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\nreturn stubbedAnswer.answer(invocation);\nObject ret = mockSettings.getDefaultAnswer().answer(invocation);\nmockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\nreturn ret;\n}",
            "method_id": 0,
            "loc": 24
        },
        {
            "method_signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues:returnValueFor(Ljava/lang/Class;)Ljava/lang/Object;",
            "method_body": "Object returnValueFor(Class<?> type) {\nif (type.isPrimitive()) {\n} else if (Primitives.isPrimitiveWrapper(type)) {\n} else if (type == Collection.class) {\n} else if (type == Set.class) {\n} else if (type == HashSet.class) {\n} else if (type == SortedSet.class) {\n} else if (type == TreeSet.class) {\n} else if (type == LinkedHashSet.class) {\n} else if (type == List.class) {\n} else if (type == LinkedList.class) {\n} else if (type == ArrayList.class) {\n} else if (type == Map.class) {\n} else if (type == HashMap.class) {\n} else if (type == SortedMap.class) {\n} else if (type == TreeMap.class) {\n} else if (type == LinkedHashMap.class) {\nreturn null;\n}",
            "method_id": 1,
            "loc": 19
        },
        {
            "method_signature": "org.mockito.internal.exceptions.base.StackTraceFilter:filter([Ljava/lang/StackTraceElement;Z)[Ljava/lang/StackTraceElement;",
            "method_body": "public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\nList<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\nint lastBad = -1;\nint firstBad = -1;\nfor (int i = 0; i < unfilteredStackTrace.size(); i++) {\nif (!this.isBad(unfilteredStackTrace.get(i))) {\ncontinue;\nlastBad = i;\nif (firstBad == -1) {\nfirstBad = i;\nif (keepTop && firstBad != -1) {\ntop = new LinkedList<StackTraceElement>();\nList<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\nList<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\nfiltered.addAll(bottom);\nreturn filtered.toArray(new StackTraceElement[]{});\n}",
            "method_id": 2,
            "loc": 17
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer$3:<init>(Lorg/mockito/internal/creation/jmock/ClassImposterizer;)V",
            "method_body": "private <T> Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\nif (mockedType == Object.class) {\nEnhancer enhancer = new Enhancer() {\n}\nenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));\nenhancer.setUseFactory(true);\nif (mockedType.isInterface()) {\nenhancer.setSuperclass(Object.class);\nenhancer.setInterfaces(prepend(mockedType, interfaces));\nenhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\nenhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\nif (mockedType.getSigners() != null) {\nenhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\nreturn enhancer.createClass();\n}",
            "method_id": 3,
            "loc": 15
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:createProxyClass(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/Class;",
            "method_body": "private <T> Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\nif (mockedType == Object.class) {\nEnhancer enhancer = new Enhancer() {\n}\nenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));\nenhancer.setUseFactory(true);\nif (mockedType.isInterface()) {\nenhancer.setSuperclass(Object.class);\nenhancer.setInterfaces(prepend(mockedType, interfaces));\nenhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\nenhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\nif (mockedType.getSigners() != null) {\nenhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\nreturn enhancer.createClass();\n}",
            "method_id": 4,
            "loc": 15
        },
        {
            "method_signature": "org.mockito.internal.util.MockUtil:createMock(Ljava/lang/Class;Lorg/mockito/internal/progress/MockingProgress;Lorg/mockito/internal/creation/MockSettingsImpl;)Ljava/lang/Object;",
            "method_body": "public <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\ncreationValidator.validateType(classToMock);\ncreationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\nMockName mockName = new MockName(settings.getMockName(), classToMock);\nMockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings);\nMethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\nClass<?>[] interfaces = settings.getExtraInterfaces();\nClass<?>[] ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\nObject spiedInstance = settings.getSpiedInstance();\nT mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\nif (spiedInstance != null) {\nreturn mock;\n}",
            "method_id": 5,
            "loc": 13
        },
        {
            "method_signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker:check(Ljava/util/List;Lorg/mockito/internal/invocation/InvocationMatcher;)V",
            "method_body": "public void check(List<Invocation> invocations, InvocationMatcher wanted) {\nList<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\nif (actualInvocations.isEmpty()) {\nInvocation similar = finder.findSimilarInvocation(invocations, wanted);\nif (similar != null) {\nArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\nInteger[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\nSmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\nreporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n} else {\n}",
            "method_id": 6,
            "loc": 11
        },
        {
            "method_signature": "org.mockito.internal.invocation.InvocationMatcher:hasSimilarMethod(Lorg/mockito/internal/invocation/Invocation;)Z",
            "method_body": "public boolean hasSimilarMethod(Invocation candidate) {\nString wantedMethodName = getMethod().getName();\nString currentMethodName = candidate.getMethod().getName();\nfinal boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\nfinal boolean isUnverified = !candidate.isVerified();\nfinal boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\nfinal boolean methodEquals = hasSameMethod(candidate);\nfinal boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\nif (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\nreturn true;\n}",
            "method_id": 7,
            "loc": 11
        },
        {
            "method_signature": "org.mockito.internal.creation.cglib.CGLIBHacker:setMockitoNamingPolicy(Lorg/mockito/cglib/proxy/MethodProxy;)V",
            "method_body": "public void setMockitoNamingPolicy(MethodProxy methodProxy) {\nField createInfoField = reflectOnCreateInfo(methodProxy);\ncreateInfoField.setAccessible(true);\nObject createInfo = createInfoField.get(methodProxy);\nField namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\nnamingPolicyField.setAccessible(true);\nif (namingPolicyField.get(createInfo) == null) {\nnamingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n}\n}",
            "method_id": 8,
            "loc": 10
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.SearchingClassLoader:combineLoadersOf(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/ClassLoader;",
            "method_body": "private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\nList<ClassLoader> loaders = new ArrayList<ClassLoader>();\naddIfNewElement(loaders, first.getClassLoader());\nfor (Class<?> c : others) {\naddIfNewElement(loaders, c.getClassLoader());\naddIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\naddIfNewElement(loaders, currentThread().getContextClassLoader());\nreturn combine(loaders);\n}",
            "method_id": 9,
            "loc": 9
        },
        {
            "method_signature": "org.mockito.internal.invocation.InvocationsFinder:findSimilarInvocation(Ljava/util/List;Lorg/mockito/internal/invocation/InvocationMatcher;)Lorg/mockito/internal/invocation/Invocation;",
            "method_body": "public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\nInvocation firstSimilar = null;\nfor (Invocation invocation : invocations) {\nif (!wanted.hasSimilarMethod(invocation)) {\nif (firstSimilar == null) {\nfirstSimilar = invocation;\nif (wanted.hasSameMethod(invocation)) {\nreturn invocation;\n}",
            "method_id": 10,
            "loc": 9
        },
        {
            "method_signature": "org.mockito.internal.invocation.Invocation:<init>(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;ILorg/mockito/internal/invocation/realmethod/RealMethod;)V",
            "method_body": "public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\nthis.mock = mock;\nthis.method = method;\nthis.realMethod = realMethod;\nthis.arguments = expandVarArgs(method.isVarArgs(), args);\nthis.rawArguments = args;\nthis.sequenceNumber = sequenceNumber;\nthis.location = new Location();\n}",
            "method_id": 11,
            "loc": 9
        },
        {
            "method_signature": "org.mockito.internal.stubbing.MockitoStubber:addAnswer(Lorg/mockito/stubbing/Answer;Z)V",
            "method_body": "private void addAnswer(Answer answer, boolean isConsecutive) {\nInvocation invocation = invocationForStubbing.getInvocation();\nmockingProgress.stubbingCompleted(invocation);\nAnswersValidator answersValidator = new AnswersValidator();\nanswersValidator.validate(answer, invocation);\nif (isConsecutive) {\nstubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n}",
            "method_id": 12,
            "loc": 8
        },
        {
            "method_signature": "org.mockito.internal.MockHandler:<init>(Lorg/mockito/internal/util/MockName;Lorg/mockito/internal/progress/MockingProgress;Lorg/mockito/internal/invocation/MatchersBinder;Lorg/mockito/internal/creation/MockSettingsImpl;)V",
            "method_body": "public MockHandler(MockName mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, MockSettingsImpl mockSettings) {\nthis.mockName = mockName;\nthis.mockingProgress = mockingProgress;\nthis.matchersBinder = matchersBinder;\nthis.mockSettings = mockSettings;\nthis.mockitoStubber = new MockitoStubber(mockingProgress);\nthis.registeredInvocations = new RegisteredInvocations();\n}",
            "method_id": 13,
            "loc": 8
        },
        {
            "method_signature": "org.mockito.internal.creation.MethodInterceptorFilter:<init>(Ljava/lang/Class;Lorg/mockito/cglib/proxy/MethodInterceptor;)V",
            "method_body": "public MethodInterceptorFilter(Class toMock, T delegate) {\nif (toMock.isInterface()) {\ntoMock = Object.class;\nequalsMethod = toMock.getMethod(\"equals\", new Class[] { Object.class });\nhashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n}\nthis.delegate = delegate;\n}",
            "method_id": 14,
            "loc": 8
        },
        {
            "method_signature": "org.mockito.internal.util.ListUtil:filter(Ljava/util/Collection;Lorg/mockito/internal/util/ListUtil$Filter;)Ljava/util/LinkedList;",
            "method_body": "public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\nLinkedList<T> filtered = new LinkedList<T>();\nfor (T t : collection) {\nif (!filter.isOut(t)) {\nfiltered.add(t);\nreturn filtered;\n}",
            "method_id": 15,
            "loc": 7
        },
        {
            "method_signature": "org.mockito.internal.exceptions.base.StackTraceFilter:isBad(Ljava/lang/StackTraceElement;)Z",
            "method_body": "public boolean isBad(StackTraceElement e) {\nboolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\nboolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\nboolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\nboolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\nreturn (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n}",
            "method_id": 16,
            "loc": 7
        },
        {
            "method_signature": "org.mockito.internal.progress.MockingProgressImpl:pullVerificationMode()Lorg/mockito/internal/verification/api/VerificationMode;",
            "method_body": "public VerificationMode pullVerificationMode() {\nif (verificationMode == null) {\nreturn null;\nVerificationMode temp = verificationMode.getObject();\nverificationMode = null;\nreturn temp;\n}",
            "method_id": 17,
            "loc": 7
        },
        {
            "method_signature": "org.mockito.internal.invocation.InvocationMatcher:argumentsMatch([Ljava/lang/Object;)Z",
            "method_body": "private boolean argumentsMatch(Object[] actualArgs) {\nif (actualArgs.length != matchers.size()) {\nfor (int i = 0; i < actualArgs.length; i++) {\nif (!matchers.get(i).matches(actualArgs[i])) {\nreturn false;\nreturn true;\n}",
            "method_id": 18,
            "loc": 7
        },
        {
            "method_signature": "org.mockito.MockitoAnnotations:initMocks(Ljava/lang/Object;)V",
            "method_body": "public static void initMocks(Object testClass) {\nif (testClass == null) {\nClass<?> clazz = testClass.getClass();\nwhile (clazz != Object.class) {\nscan(testClass, clazz);\nclazz = clazz.getSuperclass();\n}",
            "method_id": 19,
            "loc": 7
        }
    ]
}