{
    "bug_id": 26,
    "test_id": 1,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW",
    "test_body": "1172: public void testBug2182444_ausNSW() {\n1173: Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n1174: Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n1175: DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n1176: DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n1177: assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n1178: assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n1179: 1180: DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n1181: DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n1182: assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n1183: assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n1184: assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n1185: assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n1186: assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n1187: assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n1188: assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW(TestDateTimeZoneCutover.java:1187)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
            "method_body": "protected void assemble(Fields fields) {\nif (getBase() == null) {\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.joda.time.base.AbstractDateTime:<init>()V",
            "method_body": "protected AbstractDateTime() {\nsuper();\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object readableInstant) {\nif (this == readableInstant) {\nreturn true;\nif (readableInstant instanceof ReadableInstant == false) {\nReadableInstant otherInstant = (ReadableInstant) readableInstant;\nreturn\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iRange - 1;\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder:readFrom(Ljava/io/InputStream;Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\nif (in instanceof DataInput) {\nreturn readFrom((DataInput)new DataInputStream(in), id);\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nprintTo(buf, null, instant, chrono);\n}\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getWrappedField()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField getWrappedField() {\nreturn iField;\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millisOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField millisOfDay() {\nreturn iMillisOfDay;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nif (displayZone == null) {\nif (displayOffset == 0 && iZeroOffsetPrintText != null) {\nif (displayOffset >= 0) {\nbuf.append('+');\nbuf.append('-');\ndisplayOffset = -displayOffset;\nint hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\nif (iMaxFields == 1) {\ndisplayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\nif (displayOffset == 0 && iMinFields <= 1) {\nint minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\nif (iShowSeparators) {\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\nif (iMaxFields == 2) {\ndisplayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (displayOffset == 0 && iMinFields <= 2) {\nreturn;\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfMonth(instant);\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minutes()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField minutes() {\nreturn iMinutes;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long instant) {\nreturn getInfo(instant).getStandardOffset(instant);\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:millisOfSecond()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType millisOfSecond() {\nreturn MILLIS_OF_SECOND_TYPE;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDurationField:getWrappedField()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField getWrappedField() {\nreturn iField;\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:centuryOfEra()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField centuryOfEra() {\nreturn iCenturyOfEra;\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:getZone(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone(String id) {\nif (id == null) {\nObject obj = iZoneInfoMap.get(id);\nif (obj == null) {\nif (id.equals(obj)) {\nreturn loadZoneData(id);\nif (obj instanceof SoftReference<?>) {\nSoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\nDateTimeZone tz = ref.get();\nif (tz != null) {\nreturn tz;\nreturn getZone((String)obj);\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:readFrom(Ljava/io/DataInput;Ljava/lang/String;)Lorg/joda/time/tz/DateTimeZoneBuilder$PrecalculatedZone;",
            "method_body": "static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\nint poolSize = in.readUnsignedShort();\nString[] pool = new String[poolSize];\nfor (int i=0; i<poolSize; i++) {\npool[i] = in.readUTF();\nint size = in.readInt();\nlong[] transitions = new long[size];\nint[] wallOffsets = new int[size];\nint[] standardOffsets = new int[size];\nString[] nameKeys = new String[size];\nfor (int i=0; i<size; i++) {\ntransitions[i] = readMillis(in);\nwallOffsets[i] = (int)readMillis(in);\nstandardOffsets[i] = (int)readMillis(in);\nif (poolSize < 256) {\nindex = in.readUnsignedByte();\nnameKeys[i] = pool[index];\n}\nDSTZone tailZone = null;\nif (in.readBoolean()) {\ntailZone = DSTZone.readFrom(in, id);\nreturn new PrecalculatedZone\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn null;\n}",
            "method_id": 179
        }
    ]
}