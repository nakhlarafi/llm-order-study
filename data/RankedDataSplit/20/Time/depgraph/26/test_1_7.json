{
    "bug_id": 26,
    "test_id": 1,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW",
    "test_body": "1172: public void testBug2182444_ausNSW() {\n1173: Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n1174: Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n1175: DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n1176: DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n1177: assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n1178: assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n1179: 1180: DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n1181: DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n1182: assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n1183: assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n1184: assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n1185: assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n1186: assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n1187: assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n1188: assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW(TestDateTimeZoneCutover.java:1187)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:months()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField months() {\nreturn iMonths;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekOfWeekyear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekOfWeekyear() {\nreturn iWeekOfWeekyear;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\nreturn iWallOffsets[i];\ni = ~i;\nif (i < transitions.length) {\nif (i > 0) {\nreturn iWallOffsets[i - 1];\nif (iTailZone == null) {\nreturn iTailZone.getOffset(instant);\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.joda.time.field.ScaledDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn getWrappedField().getUnitMillis() * iScalar;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn iField.getUnitMillis();\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:<init>(Lorg/joda/time/DateTimeZone;J)V",
            "method_body": "Info(DateTimeZone zone, long periodStart) {\niPeriodStart = periodStart;\niZoneRef = zone;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iStandardOffset == Integer.MIN_VALUE) {\niStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);\nreturn iStandardOffset;\nreturn iNextInfo.getStandardOffset(millis);\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekyearOfCentury()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekyearOfCentury() {\nreturn iWeekyearOfCentury;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
            "method_body": "public BaseDateTime(\nsuper();\niChronology = checkChronology(chronology);\nlong instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
            "method_body": "protected void assemble(Fields fields) {\nHashMap<Object, Object> converted = new HashMap<Object, Object>();\nfields.eras = convertField(fields.eras, converted);\nfields.centuries = convertField(fields.centuries, converted);\nfields.years = convertField(fields.years, converted);\nfields.months = convertField(fields.months, converted);\nfields.weekyears = convertField(fields.weekyears, converted);\nfields.weeks = convertField(fields.weeks, converted);\nfields.days = convertField(fields.days, converted);\nfields.halfdays = convertField(fields.halfdays, converted);\nfields.hours = convertField(fields.hours, converted);\nfields.minutes = convertField(fields.minutes, converted);\nfields.seconds = convertField(fields.seconds, converted);\nfields.millis = convertField(fields.millis, converted);\nfields.year = convertField(fields.year, converted);\nfields.yearOfEra = convertField(fields.yearOfEra, converted);\nfields.yearOfCentury = convertField(fields.yearOfCentury, converted);\nfields.centuryOfEra = convertField(fields.centuryOfEra, converted);\nfields.era = convertField(fields.era, converted);\nfields.dayOfWeek = convertField(fields.dayOfWeek, converted);\nfields.dayOfMonth = convertField(fields.dayOfMonth, converted);\nfields.dayOfYear = convertField(fields.dayOfYear, converted);\nfields.monthOfYear = convertField(fields.monthOfYear, converted);\nfields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\nfields.weekyear = convertField(fields.weekyear, converted);\nfields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\nfields.millisOfSecond = convertField(fields.millisOfSecond, converted);\nfields.millisOfDay = convertField(fields.millisOfDay, converted);\nfields.secondOfMinute = convertField(fields.secondOfMinute, converted);\nfields.secondOfDay = convertField(fields.secondOfDay, converted);\nfields.minuteOfHour = convertField(fields.minuteOfHour, converted);\nfields.minuteOfDay = convertField(fields.minuteOfDay, converted);\nfields.hourOfDay = convertField(fields.hourOfDay, converted);\nfields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\nfields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\nfields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\nfields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:isSupported(Lorg/joda/time/DurationField;)Z",
            "method_body": "private static boolean isSupported(DurationField field) {\nreturn field == null ? false : field.isSupported();\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:forZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/tz/CachedDateTimeZone;",
            "method_body": "public static CachedDateTimeZone forZone(DateTimeZone zone) {\nif (zone instanceof CachedDateTimeZone) {\nreturn new CachedDateTimeZone(zone);\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfWeek()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfWeek() {\nreturn iDayOfWeek;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:clockhourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField clockhourOfDay() {\nreturn iClockhourOfDay;\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\nreturn info;\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:<init>(Lorg/joda/time/tz/DateTimeZoneBuilder$OfYear;Ljava/lang/String;I)V",
            "method_body": "Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\niOfYear = ofYear;\niNameKey = nameKey;\niSaveMillis = saveMillis;\n}",
            "method_id": 159
        }
    ]
}