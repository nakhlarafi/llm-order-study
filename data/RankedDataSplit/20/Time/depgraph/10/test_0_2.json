{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay",
    "test_body": "123: public void testFactory_daysBetween_RPartial_MonthDay() {\n124: MonthDay start1 = new MonthDay(2, 1);\n125: MonthDay start2 = new MonthDay(2, 28);\n126: MonthDay end1 = new MonthDay(2, 28);\n127: MonthDay end2 = new MonthDay(2, 29);\n128: 129: assertEquals(27, Days.daysBetween(start1, end1).getDays());\n130: assertEquals(28, Days.daysBetween(start1, end2).getDays());\n131: assertEquals(0, Days.daysBetween(start2, end1).getDays());",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\nat org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:104)\nat org.joda.time.Days.daysBetween(Days.java:141)\nat org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay(TestDays.java:130)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:localDateParser()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter localDateParser() {\nif (ldp == null) {\nldp = dateElementParser().withZoneUTC();\nreturn ldp;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMaximumValue(ReadablePartial partial, int[] values) {\nint size = partial.size();\nfor (int i = 0; i < size; i++) {\nif (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\nint month = values[i];\nfor (int j = 0; j < size; j++) {\nif (partial.getFieldType(j) == DateTimeFieldType.year()) {\nreturn iChronology.getDaysInMonthMax(month);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax()I",
            "method_body": "int getDaysInMonthMax() {\nreturn 31;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iChronology.getDaysInMonthMax();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:withZoneUTC()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter withZoneUTC() {\nreturn withZone(DateTimeZone.UTC);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
            "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\nbuilder.appendLiteral(new String(sub));\nbreak;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
            "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter withZone(DateTimeZone zone) {\nif (iZone == zone) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn iName;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeToInt(J)I",
            "method_body": "public static int safeToInt(long value) {\nif (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\nreturn (int) value;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn MIN;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateElementParser()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateElementParser() {\nif (dpe == null) {\nreturn dpe;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iMax;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$StringLiteral:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn iValue.length();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendLiteral(String text) {\nif (text == null) {\nswitch (text.length()) {\nreturn append0(new StringLiteral(text));\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$StringLiteral:<init>(Ljava/lang/String;)V",
            "method_body": "StringLiteral(String value) {\nsuper();\niValue = value;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$StringLiteral:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iValue.length();\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn iParsedLengthEstimate;\n}",
            "method_id": 59
        }
    ]
}