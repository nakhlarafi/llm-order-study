{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay",
    "test_body": "123: public void testFactory_daysBetween_RPartial_MonthDay() {\n124: MonthDay start1 = new MonthDay(2, 1);\n125: MonthDay start2 = new MonthDay(2, 28);\n126: MonthDay end1 = new MonthDay(2, 28);\n127: MonthDay end2 = new MonthDay(2, 29);\n128: 129: assertEquals(27, Days.daysBetween(start1, end1).getDays());\n130: assertEquals(28, Days.daysBetween(start1, end2).getDays());\n131: assertEquals(0, Days.daysBetween(start2, end1).getDays());",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\nat org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:104)\nat org.joda.time.Days.daysBetween(Days.java:141)\nat org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay(TestDays.java:130)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.Days:daysBetween(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;)Lorg/joda/time/Days;",
            "method_body": "public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\nif (start instanceof LocalDate && end instanceof LocalDate)   {\nint amount = BaseSingleFieldPeriod.between(start, end, ZERO);\nreturn Days.days(amount);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.Days:days(I)Lorg/joda/time/Days;",
            "method_body": "public static Days days(int days) {\nswitch (days) {\nreturn new Days(days);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:between(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePeriod;)I",
            "method_body": "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\nif (start == null || end == null) {\nif (start.size() != end.size()) {\nfor (int i = 0, isize = start.size(); i < isize; i++) {\nif (start.getFieldType(i) != end.getFieldType(i)) {\nif (DateTimeUtils.isContiguous(start) == false) {\nChronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\nint[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\nreturn values[0];\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.Days:<init>(I)V",
            "method_body": "private Days(int days) {\nsuper(days);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:isContiguous(Lorg/joda/time/ReadablePartial;)Z",
            "method_body": "public static final boolean isContiguous(ReadablePartial partial) {\nif (partial == null) {\nDurationFieldType lastType = null;\nfor (int i = 0; i < partial.size(); i++) {\nDateTimeField loopField = partial.getField(i);\nif (i > 0) {\nif (loopField.getRangeDurationField().getType() != lastType) {\nlastType = loopField.getDurationField().getType();\nreturn true;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.MonthDay:<init>(II)V",
            "method_body": "public MonthDay(int monthOfYear, int dayOfMonth) {\nthis(monthOfYear, dayOfMonth, null);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.Days:getDays()I",
            "method_body": "public int getDays() {\nreturn getValue();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
            "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
            "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nif (index != 0) {\nreturn getFieldType();\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
            "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
            "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nreturn zone;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:size()I",
            "method_body": "public abstract DurationFieldType getFieldType();\nreturn 1;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:<init>(I)V",
            "method_body": "protected BaseSingleFieldPeriod(int period) {\nsuper();\niPeriod = period;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}",
            "method_id": 19
        }
    ]
}