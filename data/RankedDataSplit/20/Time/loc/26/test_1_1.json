{
    "bug_id": 26,
    "test_id": 1,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW",
    "test_body": "public void testBug2182444_ausNSW() {\nChronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\nChronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\nDateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\nDateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\nassertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\nassertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n1180: DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\nDateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\nassertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\nassertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\nassertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\nassertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\nassertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\nassertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\nassertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW(TestDateTimeZoneCutover.java:1187)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nDateTimePrinter[] elements = iPrinters;\nif (elements == null) {\nif (locale == null) {\nlocale = Locale.getDefault();\nint len = elements.length;\nfor (int i = 0; i < len; i++) {\nelements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n}",
            "method_id": 20,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:convertField(Lorg/joda/time/DurationField;Ljava/util/HashMap;)Lorg/joda/time/DurationField;",
            "method_body": "private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\nif (field == null || !field.isSupported()) {\nreturn field;\nif (converted.containsKey(field)) {\nreturn (DurationField)converted.get(field);\nZonedDurationField zonedField = new ZonedDurationField(field, getZone());\nconverted.put(field, zonedField);\nreturn zonedField;\n}",
            "method_id": 21,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:openResource(Ljava/lang/String;)Ljava/io/InputStream;",
            "method_body": "private InputStream openResource(String name) throws IOException {\nif (iFileDir != null) {\nString path = iResourcePath.concat(name);\nif (iLoader != null) {\nin = iLoader.getResourceAsStream(path);\nif (in == null) {\nreturn in;\n}",
            "method_id": 22,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:<init>(Ljava/lang/String;[J[I[I[Ljava/lang/String;Lorg/joda/time/tz/DateTimeZoneBuilder$DSTZone;)V",
            "method_body": "private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\nsuper(id);\niTransitions = transitions;\niWallOffsets = wallOffsets;\niStandardOffsets = standardOffsets;\niNameKeys = nameKeys;\niTailZone = tailZone;\n}",
            "method_id": 23,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(\nif ((base = getBase()) != null) {\nFieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\nFieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\nreturn getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n}",
            "method_id": 24,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}",
            "method_id": 25,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}",
            "method_id": 26,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:<init>(Lorg/joda/time/DurationField;Lorg/joda/time/DateTimeZone;)V",
            "method_body": "ZonedDurationField(DurationField field, DateTimeZone zone) {\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niTimeField = useTimeArithmetic(field);\niZone = zone;\n}",
            "method_id": 27,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getOffset(J)I",
            "method_body": "public int getOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iOffset == Integer.MIN_VALUE) {\niOffset = iZoneRef.getOffset(iPeriodStart);\nreturn iOffset;\nreturn iNextInfo.getOffset(millis);\n}",
            "method_id": 28,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.field.ScaledDurationField:hashCode()I",
            "method_body": "public int hashCode() {\nlong scalar = iScalar;\nint hash = (int) (scalar ^ (scalar >>> 32));\nhash += getType().hashCode();\nhash += getWrappedField().hashCode();\nreturn hash;\n}",
            "method_id": 29,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:convertField(Lorg/joda/time/DateTimeField;Ljava/util/HashMap;)Lorg/joda/time/DateTimeField;",
            "method_body": "private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\nif (field == null || !field.isSupported()) {\nif (converted.containsKey(field)) {\nZonedDateTimeField zonedField =\nconverted.put(field, zonedField);\nreturn zonedField;\n}",
            "method_id": 30,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iStandardOffset == Integer.MIN_VALUE) {\niStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);\nreturn iStandardOffset;\nreturn iNextInfo.getStandardOffset(millis);\n}",
            "method_id": 31,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}",
            "method_id": 32,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object readableInstant) {\nif (this == readableInstant) {\nreturn true;\nif (readableInstant instanceof ReadableInstant == false) {\nReadableInstant otherInstant = (ReadableInstant) readableInstant;\nreturn\n}",
            "method_id": 33,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
            "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}",
            "method_id": 34,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateMidnightMillis(III)J",
            "method_body": "long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\nFieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\nFieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\nFieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\nreturn getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n}",
            "method_id": 35,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:<init>(Ljava/lang/String;ILorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;)V",
            "method_body": "DSTZone(String id, int standardOffset,\nsuper(id);\niStandardOffset = standardOffset;\niStartRecurrence = startRecurrence;\niEndRecurrence = endRecurrence;\n}",
            "method_id": 36,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
            "method_body": "public BaseDateTime(\nsuper();\niChronology = checkChronology(chronology);\nlong instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 37,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}",
            "method_id": 38,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:convertUTCToLocal(J)J",
            "method_body": "public long convertUTCToLocal(long instantUTC) {\nint offset = getOffset(instantUTC);\nlong instantLocal = instantUTC + offset;\nif ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\nreturn instantLocal;\n}",
            "method_id": 39,
            "loc": 6
        }
    ]
}