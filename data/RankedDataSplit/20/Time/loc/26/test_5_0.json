{
    "bug_id": 26,
    "test_id": 5,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithHourOfDayInDstChange",
    "test_body": "public void testWithHourOfDayInDstChange() {\nDateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\nassertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\nDateTime test = dateTime.withHourOfDay(2);\nassertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.123+0[2]:00> but was:<...10-31T02:30:10.123+0[1]:00>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat org.joda.time.TestDateTimeZoneCutover.testWithHourOfDayInDstChange(TestDateTimeZoneCutover.java:1087)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = text.length() - position;\nif (iZeroOffsetParseText != null) {\nif (iZeroOffsetParseText.length() == 0) {\nif (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif (limit <= 1) {\nchar c = text.charAt(position);\nif (c == '-') {\nnegative = true;\n} else if (c == '+') {\nnegative = false;\nlimit--;\nposition++;\nif (digitCount(text, position, 2) < 2) {\nint hours = FormatUtils.parseTwoDigits(text, position);\nif (hours > 23) {\noffset = hours * DateTimeConstants.MILLIS_PER_HOUR;\nlimit -= 2;\nposition += 2;\nif (limit <= 0) {\nc = text.charAt(position);\nif (c == ':') {\nexpectSeparators = true;\nlimit--;\nposition++;\nint count = digitCount(text, position, 2);\nif (count == 0 && !expectSeparators) {\n} else if (count < 2) {\nint minutes = FormatUtils.parseTwoDigits(text, position);\nif (minutes > 59) {\noffset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nlimit -= 2;\nposition += 2;\nif (limit <= 0) {\nbreak parse;\nbucket.setOffset(negative ? -offset : offset);\nreturn position;\n}",
            "method_id": 0,
            "loc": 38
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$MatchingParser:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeParser[] parsers = iParsers;\nint length = parsers.length;\nfinal Object originalState = bucket.saveState();\nboolean isOptional = false;\nint bestValidPos = position;\nObject bestValidState = null;\nint bestInvalidPos = position;\nfor (int i=0; i<length; i++) {\nDateTimeParser parser = parsers[i];\nif (parser == null) {\nif (bestValidPos <= position) {\nisOptional = true;\nbreak;\nint parsePos = parser.parseInto(bucket, text, position);\nif (parsePos >= position) {\nif (parsePos > bestValidPos) {\nif (parsePos >= text.length() ||\nreturn parsePos;\nbestValidPos = parsePos;\nbestValidState = bucket.saveState();\nif (parsePos < 0) {\nparsePos = ~parsePos;\nif (parsePos > bestInvalidPos) {\nbestInvalidPos = parsePos;\nbucket.restoreState(originalState);\nif (bestValidPos > position || (bestValidPos == position && isOptional)) {\nif (bestValidState != null) {\nbucket.restoreState(bestValidState);\nreturn bestValidPos;\nreturn ~bestInvalidPos;\n}",
            "method_id": 1,
            "loc": 32
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:printTo(Ljava/lang/StringBuffer;Ljava/io/Writer;JLorg/joda/time/Chronology;)V",
            "method_body": "protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\nDateTimeField field = iFieldType.getField(chrono);\nint minDigits = iMinDigits;\nfraction = field.remainder(instant);\n}\nif (fraction == 0) {\nif (buf != null) {\nwhile (--minDigits >= 0) {\nbuf.append('0');\nreturn;\nlong[] fractionData = getFractionData(fraction, field);\nlong scaled = fractionData[0];\nint maxDigits = (int) fractionData[1];\nif ((scaled & 0x7fffffff) == scaled) {\nstr = Integer.toString((int) scaled);\nint length = str.length();\nint digits = maxDigits;\nwhile (length < digits) {\nif (minDigits < digits) {\nwhile (minDigits < digits) {\nif (length <= 1 || str.charAt(length - 1) != '0') {\ndigits--;\nlength--;\nif (length < str.length()) {\nif (buf != null) {\nfor (int i=0; i<length; i++) {\nbuf.append(str.charAt(i));\nreturn;\n}",
            "method_id": 2,
            "loc": 29
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = Math.min(iMaxParsedDigits, text.length() - position);\nboolean negative = false;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (length == 0 && (c == '-' || c == '+') && iSigned) {\nif (c < '0' || c > '9') {\nlength++;\n}\nif (length == 0) {\nif (length >= 9) {\nint i = position;\nif (negative) {\nvalue = text.charAt(i++) - '0';\n}\nposition += length;\nwhile (i < position) {\nvalue = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\nif (negative) {\nbucket.saveField(iFieldType, value);\nreturn position;\n}",
            "method_id": 3,
            "loc": 23
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeField field = iFieldType.getField(bucket.getChronology());\nint limit = Math.min(iMaxDigits, text.length() - position);\nlong value = 0;\nlong n = field.getDurationField().getUnitMillis() * 10;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (c < '0' || c > '9') {\nlength++;\nlong nn = n / 10;\nvalue += (c - '0') * nn;\nn = nn;\n}\nvalue /= 10;\nif (length == 0) {\nif (value > Integer.MAX_VALUE) {\nDateTimeField parseField = new PreciseDateTimeField(\nbucket.saveField(parseField, (int) value);\nreturn position + length;\n}",
            "method_id": 4,
            "loc": 21
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nif (displayZone == null) {\nif (displayOffset == 0 && iZeroOffsetPrintText != null) {\nif (displayOffset >= 0) {\nbuf.append('+');\nbuf.append('-');\ndisplayOffset = -displayOffset;\nint hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\nif (iMaxFields == 1) {\ndisplayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\nif (displayOffset == 0 && iMinFields <= 1) {\nint minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\nif (iShowSeparators) {\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\nif (iMaxFields == 2) {\ndisplayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (displayOffset == 0 && iMinFields <= 2) {\nreturn;\n}",
            "method_id": 5,
            "loc": 21
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
            "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\niSavedFields = savedFields = (SavedField[])iSavedFields.clone();\niSavedFieldsShared = false;\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i=0; i<count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}",
            "method_id": 6,
            "loc": 20
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:next(JII)J",
            "method_body": "public long next(long instant, int standardOffset, int saveMillis) {\nif (iMode == 'w') {\noffset = standardOffset + saveMillis;\n} else if (iMode == 's') {\noffset = 0;\ninstant += offset;\nChronology chrono = ISOChronology.getInstanceUTC();\nlong next = chrono.monthOfYear().set(instant, iMonthOfYear);\nnext = chrono.millisOfDay().set(next, 0);\nnext = chrono.millisOfDay().add(next, iMillisOfDay);\nnext = setDayOfMonthNext(chrono, next);\nif (iDayOfWeek == 0) {\nnext = setDayOfWeek(chrono, next);\nif (next <= instant) {\nnext = chrono.year().add(next, 1);\nnext = chrono.monthOfYear().set(next, iMonthOfYear);\nnext = setDayOfMonthNext(chrono, next);\nnext = setDayOfWeek(chrono, next);\nreturn next - offset;\n}",
            "method_id": 7,
            "loc": 20
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}",
            "method_id": 8,
            "loc": 18
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(JI)J",
            "method_body": "public long add(long instant, int months) {\nif (months == 0) {\nlong timePart = iChronology.getMillisOfDay(instant);\nint thisYear = iChronology.getYear(instant);\nint thisMonth = iChronology.getMonthOfYear(instant, thisYear);\nint monthToUse = thisMonth - 1 + months;\nif (monthToUse >= 0) {\nyearToUse = thisYear + (monthToUse / iMax);\nmonthToUse = (monthToUse % iMax) + 1;\nint dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\nint maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\nif (dayToUse > maxDay) {\nlong datePart =\nreturn datePart + timePart;\n}",
            "method_id": 9,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nif (position >= text.length()) {\nchar a = text.charAt(position);\nchar b = iValue;\nif (a != b) {\na = Character.toUpperCase(a);\nb = Character.toUpperCase(b);\nif (a != b) {\na = Character.toLowerCase(a);\nb = Character.toLowerCase(b);\nif (a != b) {\nreturn ~position;\nreturn position + 1;\n}",
            "method_id": 10,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:createInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info createInfo(long millis) {\nlong periodStart = millis & (0xffffffffL << 32);\nInfo info = new Info(iZone, periodStart);\nlong end = periodStart | 0xffffffffL;\nInfo chain = info;\nlong next = iZone.nextTransition(periodStart);\nif (next == periodStart || next > end) {\nbreak;\nperiodStart = next;\nchain = (chain.iNextInfo = new Info(iZone, periodStart));\n}\nreturn info;\n}",
            "method_id": 11,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nswitch (iOrdinal) {\nreturn chronology.year();\nreturn chronology.dayOfYear();\nreturn chronology.monthOfYear();\nreturn chronology.dayOfMonth();\nreturn chronology.weekyear();\nreturn chronology.hourOfDay();\nreturn chronology.minuteOfHour();\nreturn chronology.secondOfDay();\nreturn chronology.secondOfMinute();\n}",
            "method_id": 12,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:setYear(JI)J",
            "method_body": "long setYear(long instant, int year) {\nint thisYear = getYear(instant);\nint dayOfYear = getDayOfYear(instant, thisYear);\nint millisOfDay = getMillisOfDay(instant);\nif (dayOfYear > (31 + 28)) { // after Feb 28\nif (isLeapYear(thisYear)) {\nif (!isLeapYear(year)) {\ndayOfYear--;\nif (isLeapYear(year)) {\ninstant = getYearMonthDayMillis(year, 1, dayOfYear);\ninstant += millisOfDay;\nreturn instant;\n}",
            "method_id": 13,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:nextTransition(J)J",
            "method_body": "public long nextTransition(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\nstart = startRecurrence.next\nif (instant > 0 && start < 0) {\n}\nend = endRecurrence.next\nif (instant > 0 && end < 0) {\n}\nreturn (start > end) ? end : start;\n}",
            "method_id": 14,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\nreturn iWallOffsets[i];\ni = ~i;\nif (i < transitions.length) {\nif (i > 0) {\nreturn iWallOffsets[i - 1];\nif (iTailZone == null) {\nreturn iTailZone.getOffset(instant);\n}",
            "method_id": 15,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
            "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\nSavedField[] newArray = new SavedField\nSystem.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\niSavedFields = savedFields = newArray;\niSavedFieldsShared = false;\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}",
            "method_id": 16,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\nint year = (int) (i2 / unitMillis);\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\nif (diff < 0) {\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\nreturn year;\n}",
            "method_id": 17,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfWeek(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfWeek(Chronology chrono, long instant) {\nint dayOfWeek = chrono.dayOfWeek().get(instant);\nint daysToAdd = iDayOfWeek - dayOfWeek;\nif (daysToAdd != 0) {\nif (iAdvance) {\nif (daysToAdd < 0) {\nif (daysToAdd > 0) {\ndaysToAdd -= 7;\ninstant = chrono.dayOfWeek().add(instant, daysToAdd);\nreturn instant;\n}",
            "method_id": 18,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
            "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 19,
            "loc": 11
        }
    ]
}