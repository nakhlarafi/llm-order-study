{
    "bug_id": 26,
    "test_id": 5,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithHourOfDayInDstChange",
    "test_body": "public void testWithHourOfDayInDstChange() {\nDateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\nassertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\nDateTime test = dateTime.withHourOfDay(2);\nassertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.123+0[2]:00> but was:<...10-31T02:30:10.123+0[1]:00>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat org.joda.time.TestDateTimeZoneCutover.testWithHourOfDayInDstChange(TestDateTimeZoneCutover.java:1087)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedState:restoreState(Lorg/joda/time/format/DateTimeParserBucket;)Z",
            "method_body": "boolean restoreState(DateTimeParserBucket enclosing) {\nif (enclosing != DateTimeParserBucket.this) {\nenclosing.iZone = this.iZone;\nenclosing.iOffset = this.iOffset;\nenclosing.iSavedFields = this.iSavedFields;\nif (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\nenclosing.iSavedFieldsShared = true;\nenclosing.iSavedFieldsCount = this.iSavedFieldsCount;\nreturn true;\n}",
            "method_id": 20,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
            "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\nsetZone(chrono.getZone());\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 21,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:findMatchingRecurrence(J)Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;",
            "method_body": "private Recurrence findMatchingRecurrence(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\nstart = startRecurrence.next\n}\nend = endRecurrence.next\n}\nreturn (start > end) ? startRecurrence : endRecurrence;\n}",
            "method_id": 22,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\nreturn info;\n}",
            "method_id": 23,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseMillis(Ljava/lang/String;)J",
            "method_body": "public long parseMillis(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(iChrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn bucket.computeMillis(true, text);\n}",
            "method_id": 24,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:getFractionData(JLorg/joda/time/DateTimeField;)[J",
            "method_body": "private long[] getFractionData(long fraction, DateTimeField field) {\nlong rangeMillis = field.getDurationField().getUnitMillis();\nint maxDigits = iMaxDigits;\nswitch (maxDigits) {\ncase 9:  scalar = 1000000000L; break;\nif (((rangeMillis * scalar) / scalar) == rangeMillis) {\nbreak;\nreturn new long[] {fraction * scalar / rangeMillis, maxDigits};\n}",
            "method_id": 25,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
            "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}",
            "method_id": 26,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nDateTimePrinter[] elements = iPrinters;\nif (elements == null) {\nif (locale == null) {\nlocale = Locale.getDefault();\nint len = elements.length;\nfor (int i = 0; i < len; i++) {\nelements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n}",
            "method_id": 27,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:digitCount(Ljava/lang/String;II)I",
            "method_body": "private int digitCount(String text, int position, int amount) {\nint limit = Math.min(text.length() - position, amount);\namount = 0;\nfor (; limit > 0; limit--) {\nchar c = text.charAt(position + amount);\nif (c < '0' || c > '9') {\namount++;\nreturn amount;\n}",
            "method_id": 28,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeParser[] elements = iParsers;\nif (elements == null) {\nint len = elements.length;\nfor (int i=0; i<len && position >= 0; i++) {\nposition = elements[i].parseInto(bucket, text, position);\nreturn position;\n}",
            "method_id": 29,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}",
            "method_id": 30,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:<init>(Lorg/joda/time/DateTimeFieldType;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
            "method_body": "public PreciseDateTimeField(DateTimeFieldType type,\nsuper(type, unit);\nif (!range.isPrecise()) {\nlong rangeMillis = range.getUnitMillis();\niRange = (int)(rangeMillis / getUnitMillis());\nif (iRange < 2) {\niRangeField = range;\n}",
            "method_id": 31,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.convert.ConverterSet:select(Ljava/lang/Class;)Lorg/joda/time/convert/Converter;",
            "method_body": "Converter select(Class<?> type) throws IllegalStateException {\nEntry[] entries = iSelectEntries;\nint length = entries.length;\nint index = type == null ? 0 : type.hashCode() & (length - 1);\nwhile ((e = entries[index]) != null) {\nif (e.iType == type) {\nreturn e.iConverter;\n}",
            "method_id": 32,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}",
            "method_id": 33,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
            "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}",
            "method_id": 34,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
            "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}",
            "method_id": 35,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getOffset(J)I",
            "method_body": "public int getOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iOffset == Integer.MIN_VALUE) {\niOffset = iZoneRef.getOffset(iPeriodStart);\nreturn iOffset;\nreturn iNextInfo.getOffset(millis);\n}",
            "method_id": 36,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public BaseDateTime(Object instant, DateTimeZone zone) {\nsuper();\nInstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\nChronology chrono = checkChronology(converter.getChronology(instant, zone));\niChronology = chrono;\niMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);\n}",
            "method_id": 37,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:compareTo(Lorg/joda/time/DurationField;)I",
            "method_body": "public int compareTo(DurationField otherField) {\nlong otherMillis = otherField.getUnitMillis();\nlong thisMillis = getUnitMillis();\nif (thisMillis == otherMillis) {\nif (thisMillis < otherMillis) {\nreturn 1;\n}",
            "method_id": 38,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:<init>(Lorg/joda/time/DateTimeFieldType;Lorg/joda/time/DurationField;)V",
            "method_body": "public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\nsuper(type);\nif (!unit.isPrecise()) {\niUnitMillis = unit.getUnitMillis();\nif (iUnitMillis < 1) {\niUnitField = unit;\n}",
            "method_id": 39,
            "loc": 7
        }
    ]
}