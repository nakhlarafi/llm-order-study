{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek",
    "test_body": "public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\nDateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n.appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\nDateTimeFormatter f = bld.toFormatter();\n260: DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\nassertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\nassertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"\nat org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866)\nat org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:copyFieldsFrom(Lorg/joda/time/Chronology;)V",
            "method_body": "public void copyFieldsFrom(Chronology chrono) {\nif (isSupported(f = chrono.millis())) {\nmillis = f;\nif (isSupported(f = chrono.seconds())) {\nseconds = f;\nif (isSupported(f = chrono.minutes())) {\nminutes = f;\nif (isSupported(f = chrono.hours())) {\nhours = f;\nif (isSupported(f = chrono.halfdays())) {\nhalfdays = f;\nif (isSupported(f = chrono.days())) {\ndays = f;\nif (isSupported(f = chrono.weeks())) {\nweeks = f;\nif (isSupported(f = chrono.weekyears())) {\nweekyears = f;\nif (isSupported(f = chrono.months())) {\nmonths = f;\nif (isSupported(f = chrono.years())) {\nyears = f;\nif (isSupported(f = chrono.centuries())) {\ncenturies = f;\nif (isSupported(f = chrono.eras())) {\nif (isSupported(f = chrono.millisOfSecond())) {\nmillisOfSecond = f;\nif (isSupported(f = chrono.millisOfDay())) {\nmillisOfDay = f;\nif (isSupported(f = chrono.secondOfMinute())) {\nsecondOfMinute = f;\nif (isSupported(f = chrono.secondOfDay())) {\nsecondOfDay = f;\nif (isSupported(f = chrono.minuteOfHour())) {\nminuteOfHour = f;\nif (isSupported(f = chrono.minuteOfDay())) {\nminuteOfDay = f;\nif (isSupported(f = chrono.hourOfDay())) {\nhourOfDay = f;\nif (isSupported(f = chrono.clockhourOfDay())) {\nclockhourOfDay = f;\nif (isSupported(f = chrono.hourOfHalfday())) {\nhourOfHalfday = f;\nif (isSupported(f = chrono.clockhourOfHalfday())) {\nclockhourOfHalfday = f;\nif (isSupported(f = chrono.halfdayOfDay())) {\nhalfdayOfDay = f;\nif (isSupported(f = chrono.dayOfWeek())) {\ndayOfWeek = f;\nif (isSupported(f = chrono.dayOfMonth())) {\ndayOfMonth = f;\nif (isSupported(f = chrono.dayOfYear())) {\ndayOfYear = f;\nif (isSupported(f = chrono.weekOfWeekyear())) {\nweekOfWeekyear = f;\nif (isSupported(f = chrono.weekyear())) {\nweekyear = f;\nif (isSupported(f = chrono.weekyearOfCentury())) {\nweekyearOfCentury = f;\nif (isSupported(f = chrono.monthOfYear())) {\nmonthOfYear = f;\nif (isSupported(f = chrono.year())) {\nyear = f;\nif (isSupported(f = chrono.yearOfEra())) {\nyearOfEra = f;\nif (isSupported(f = chrono.yearOfCentury())) {\nyearOfCentury = f;\nif (isSupported(f = chrono.centuryOfEra())) {\ncenturyOfEra = f;\nif (isSupported(f = chrono.era())) {\nera = f;\n}",
            "method_id": 0,
            "loc": 71
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:setFields()V",
            "method_body": "private void setFields() {\nFields fields = new Fields();\nif (iBase != null) {\nfields.copyFieldsFrom(iBase);\nassemble(fields);\niMillis    = (f = fields.millis)    != null ? f : super.millis();\niSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\niMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\niHours     = (f = fields.hours)     != null ? f : super.hours();\niHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\niDays      = (f = fields.days)      != null ? f : super.days();\niWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\niWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\niMonths    = (f = fields.months)    != null ? f : super.months();\niYears     = (f = fields.years)     != null ? f : super.years();\niCenturies = (f = fields.centuries) != null ? f : super.centuries();\niEras      = (f = fields.eras)      != null ? f : super.eras();\niMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\niMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\niSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\niSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\niMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\niMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\niHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\niClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\niHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\niClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\niHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\niDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\niDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\niDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\niWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\niWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\niWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\niMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\niYear               = (f = fields.year)               != null ? f : super.year();\niYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\niYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\niCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\niEra                = (f = fields.era)                != null ? f : super.era();\nif (iBase == null) {\nflags =\niBaseFlags = flags;\n}",
            "method_id": 1,
            "loc": 44
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
            "method_body": "protected void assemble(Fields fields) {\nHashMap<Object, Object> converted = new HashMap<Object, Object>();\nfields.eras = convertField(fields.eras, converted);\nfields.centuries = convertField(fields.centuries, converted);\nfields.years = convertField(fields.years, converted);\nfields.months = convertField(fields.months, converted);\nfields.weekyears = convertField(fields.weekyears, converted);\nfields.weeks = convertField(fields.weeks, converted);\nfields.days = convertField(fields.days, converted);\nfields.halfdays = convertField(fields.halfdays, converted);\nfields.hours = convertField(fields.hours, converted);\nfields.minutes = convertField(fields.minutes, converted);\nfields.seconds = convertField(fields.seconds, converted);\nfields.millis = convertField(fields.millis, converted);\nfields.year = convertField(fields.year, converted);\nfields.yearOfEra = convertField(fields.yearOfEra, converted);\nfields.yearOfCentury = convertField(fields.yearOfCentury, converted);\nfields.centuryOfEra = convertField(fields.centuryOfEra, converted);\nfields.era = convertField(fields.era, converted);\nfields.dayOfWeek = convertField(fields.dayOfWeek, converted);\nfields.dayOfMonth = convertField(fields.dayOfMonth, converted);\nfields.dayOfYear = convertField(fields.dayOfYear, converted);\nfields.monthOfYear = convertField(fields.monthOfYear, converted);\nfields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\nfields.weekyear = convertField(fields.weekyear, converted);\nfields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\nfields.millisOfSecond = convertField(fields.millisOfSecond, converted);\nfields.millisOfDay = convertField(fields.millisOfDay, converted);\nfields.secondOfMinute = convertField(fields.secondOfMinute, converted);\nfields.secondOfDay = convertField(fields.secondOfDay, converted);\nfields.minuteOfHour = convertField(fields.minuteOfHour, converted);\nfields.minuteOfDay = convertField(fields.minuteOfDay, converted);\nfields.hourOfDay = convertField(fields.hourOfDay, converted);\nfields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\nfields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\nfields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\nfields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n}",
            "method_id": 2,
            "loc": 38
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
            "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen == 2) {\nint maxDigits = 9;\nif (i + 1 < length) {\nindexRef[0]++;\nif (isNumericToken(parseToken(pattern, indexRef))) {\nindexRef[0]--;\nswitch (c) {\nbuilder.appendYear(tokenLen, maxDigits);\nbreak;\nbreak;\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nbuilder.appendHourOfDay(tokenLen);\nbreak;\nbuilder.appendMinuteOfHour(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}",
            "method_id": 3,
            "loc": 34
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
            "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}",
            "method_id": 4,
            "loc": 25
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
            "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}",
            "method_id": 5,
            "loc": 24
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = Math.min(iMaxParsedDigits, text.length() - position);\nboolean negative = false;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (length == 0 && (c == '-' || c == '+') && iSigned) {\nif (c < '0' || c > '9') {\nlength++;\n}\nif (length == 0) {\nif (length >= 9) {\nint i = position;\nif (negative) {\nvalue = text.charAt(i++) - '0';\n}\nposition += length;\nwhile (i < position) {\nvalue = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\nif (negative) {\nbucket.saveField(iFieldType, value);\nreturn position;\n}",
            "method_id": 6,
            "loc": 23
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:readFrom(Ljava/io/DataInput;Ljava/lang/String;)Lorg/joda/time/tz/DateTimeZoneBuilder$PrecalculatedZone;",
            "method_body": "static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\nint poolSize = in.readUnsignedShort();\nString[] pool = new String[poolSize];\nfor (int i=0; i<poolSize; i++) {\npool[i] = in.readUTF();\nint size = in.readInt();\nlong[] transitions = new long[size];\nint[] wallOffsets = new int[size];\nint[] standardOffsets = new int[size];\nString[] nameKeys = new String[size];\nfor (int i=0; i<size; i++) {\ntransitions[i] = readMillis(in);\nwallOffsets[i] = (int)readMillis(in);\nstandardOffsets[i] = (int)readMillis(in);\nif (poolSize < 256) {\nindex = in.readUnsignedByte();\nnameKeys[i] = pool[index];\n}\nDSTZone tailZone = null;\nif (in.readBoolean()) {\ntailZone = DSTZone.readFrom(in, id);\nreturn new PrecalculatedZone\n}",
            "method_id": 7,
            "loc": 23
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}",
            "method_id": 8,
            "loc": 18
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder:readMillis(Ljava/io/DataInput;)J",
            "method_body": "static long readMillis(DataInput in) throws IOException {\nint v = in.readUnsignedByte();\nswitch (v >> 6) {\nv = (v << (32 - 6)) >> (32 - 6);\nreturn v * (30 * 60000L);\nv = (v << (32 - 6)) >> (32 - 30);\nv |= (in.readUnsignedByte()) << 16;\nv |= (in.readUnsignedByte()) << 8;\nv |= (in.readUnsignedByte());\nreturn v * 60000L;\nlong w = (((long)v) << (64 - 6)) >> (64 - 38);\nw |= (in.readUnsignedByte()) << 24;\nw |= (in.readUnsignedByte()) << 16;\nw |= (in.readUnsignedByte()) << 8;\nw |= (in.readUnsignedByte());\nreturn w * 1000L;\nreturn in.readLong();\n}",
            "method_id": 9,
            "loc": 18
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}",
            "method_id": 10,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:decompose(Ljava/util/List;Ljava/util/List;Ljava/util/List;)V",
            "method_body": "private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\nint size = elementPairs.size();\nfor (int i=0; i<size; i+=2) {\nObject element = elementPairs.get(i);\nif (element instanceof DateTimePrinter) {\nif (element instanceof Composite) {\nprinterList.add(element);\nelement = elementPairs.get(i + 1);\nif (element instanceof DateTimeParser) {\nif (element instanceof Composite) {\nparserList.add(element);\n}",
            "method_id": 11,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}",
            "method_id": 12,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\nint year = (int) (i2 / unitMillis);\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\nif (diff < 0) {\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\nreturn year;\n}",
            "method_id": 13,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}",
            "method_id": 14,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
            "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 15,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:loadZoneData(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "private DateTimeZone loadZoneData(String id) {\nInputStream in = null;\nin = openResource(id);\nDateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\niZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\nreturn tz;\nif (in != null) {\nin.close();\n}\n}",
            "method_id": 16,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:<init>(CIIIZI)V",
            "method_body": "OfYear(char mode,\n{\nif (mode != 'u' && mode != 'w' && mode != 's') {\niMode = mode;\niMonthOfYear = monthOfYear;\niDayOfMonth = dayOfMonth;\niDayOfWeek = dayOfWeek;\niAdvance = advanceDayOfWeek;\niMillisOfDay = millisOfDay;\n}",
            "method_id": 17,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
            "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}",
            "method_id": 18,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\nreturn info;\n}",
            "method_id": 19,
            "loc": 10
        }
    ]
}