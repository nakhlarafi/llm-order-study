{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek",
    "test_body": "public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\nDateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n.appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\nDateTimeFormatter f = bld.toFormatter();\n260: DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\nassertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\nassertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"\nat org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866)\nat org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millis()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField millis() {\nreturn iMillis;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nswitch (iOrdinal) {\nreturn chronology.year();\nreturn chronology.monthOfYear();\nreturn chronology.dayOfMonth();\nreturn chronology.hourOfDay();\nreturn chronology.minuteOfHour();\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
            "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMaxYear()I",
            "method_body": "int getMaxYear() {\nreturn MAX_YEAR;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iField.getDurationField();\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getApproxMillisAtEpochDividedByTwo()J",
            "method_body": "long getApproxMillisAtEpochDividedByTwo() {\nreturn (1970L * MILLIS_PER_YEAR) / 2;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:era()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField era() {\nreturn iEra;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:appendPatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
            "method_body": "static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\nparsePatternTo(builder, pattern);\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
            "method_body": "NumberFormatter(DateTimeFieldType fieldType,\nsuper();\niFieldType = fieldType;\niMaxParsedDigits = maxParsedDigits;\niSigned = signed;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.weekyears();\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:nextTransition(J)J",
            "method_body": "public long nextTransition(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\ni = (i >= 0) ? (i + 1) : ~i;\nif (i < transitions.length) {\nif (iTailZone == null) {\nreturn instant;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfHalfday()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfHalfday() {\nreturn iHourOfHalfday;\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.joda.time.chrono.GJEraDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn null;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iUnitField;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
            "method_body": "boolean isParser() {\nreturn iParsers != null;\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
            "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
            "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeParser[] elements = iParsers;\nif (elements == null) {\nint len = elements.length;\nfor (int i=0; i<len && position >= 0; i++) {\nposition = elements[i].parseInto(bucket, text, position);\nreturn position;\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
            "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}",
            "method_id": 159
        }
    ]
}