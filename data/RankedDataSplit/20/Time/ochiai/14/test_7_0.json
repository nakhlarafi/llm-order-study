{
    "bug_id": 14,
    "test_id": 7,
    "test_name": "org.joda.time.TestMonthDay_Basics.testMinusMonths_int_fromLeap",
    "test_body": "545: public void testMinusMonths_int_fromLeap() {\n546: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n547: MonthDay result = test.minusMonths(1);\n548: MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:218)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(BasicMonthOfYearDateTimeField.java:213)\nat org.joda.time.MonthDay.withFieldAdded(MonthDay.java:519)\nat org.joda.time.MonthDay.minusMonths(MonthDay.java:652)\nat org.joda.time.TestMonthDay_Basics.testMinusMonths_int_fromLeap(TestMonthDay_Basics.java:547)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
            "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:isContiguous(Lorg/joda/time/ReadablePartial;)Z",
            "method_body": "public static final boolean isContiguous(ReadablePartial partial) {\nif (partial == null) {\nDurationFieldType lastType = null;\nfor (int i = 0; i < partial.size(); i++) {\nDateTimeField loopField = partial.getField(i);\nif (i > 0) {\nif (loopField.getRangeDurationField().getType() != lastType) {\nlastType = loopField.getDurationField().getType();\nreturn true;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.MonthDay:minusMonths(I)Lorg/joda/time/MonthDay;",
            "method_body": "public MonthDay minusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInMonthMax(I)I",
            "method_body": "int getDaysInMonthMax(int month) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
            "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:indexOfSupported(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "protected int indexOfSupported(DurationFieldType type) {\nint index = indexOf(type);\nif (index == -1) {\nreturn index;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.MonthDay:getFieldType(I)Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public DateTimeFieldType getFieldType(int index) {\nreturn FIELD_TYPES[index];\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "protected int indexOf(DurationFieldType type) {\nfor (int i = 0, isize = size(); i < isize; i++) {\nif (getFieldType(i).getDurationType() == type) {\nreturn i;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.MonthDay:size()I",
            "method_body": "public int size() {\nreturn 2;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax(J)I",
            "method_body": "int getDaysInMonthMax(long instant) {\nint thisYear = getYear(instant);\nint thisMonth = getMonthOfYear(instant, thisYear);\nreturn getDaysInYearMonth(thisYear, thisMonth);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.base.BasePartial:getValues()[I",
            "method_body": "public int[] getValues() {\nreturn (int[]) iValues.clone();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMaximumValue(ReadablePartial partial, int[] values) {\nint size = partial.size();\nfor (int i = 0; i < size; i++) {\nif (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\nint month = values[i];\nfor (int j = 0; j < size; j++) {\nif (partial.getFieldType(j) == DateTimeFieldType.year()) {\nreturn iChronology.getDaysInMonthMax(month);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
            "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax()I",
            "method_body": "int getDaysInMonthMax() {\nreturn 31;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.IllegalFieldValueException:<init>(Lorg/joda/time/DateTimeFieldType;Ljava/lang/Number;Ljava/lang/Number;Ljava/lang/Number;)V",
            "method_body": "public IllegalFieldValueException(DateTimeFieldType fieldType,\nsuper(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));\niDateTimeFieldType = fieldType;\niDurationFieldType = null;\niFieldName = fieldType.getName();\niNumberValue = value;\niStringValue = null;\niLowerBound = lowerBound;\niUpperBound = upperBound;\niMessage = super.getMessage();\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iChronology.getDaysInMonthMax();\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.IllegalFieldValueException:createMessage(Ljava/lang/String;Ljava/lang/Number;Ljava/lang/Number;Ljava/lang/Number;Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "private static String createMessage(String fieldName, Number value,\nStringBuffer buf = new StringBuffer()\nif (lowerBound == null) {\n} else if (upperBound == null) {\nbuf.append(\"must be in the range [\")\nif (explain != null) {\nreturn buf.toString();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn MIN;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iMax;\n}",
            "method_id": 19
        }
    ]
}