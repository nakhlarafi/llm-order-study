{
    "bug_id": 14,
    "test_id": 0,
    "test_name": "org.joda.time.TestMonthDay_Basics.testMinusMonths_int_endOfMonthAdjust",
    "test_body": "559: public void testMinusMonths_int_endOfMonthAdjust() {\n560: MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n561: MonthDay result = test.minusMonths(1);\n562: MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n563: assertEquals(expected, result);\n564: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<--02-29> but was:<--02-28>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.TestMonthDay_Basics.testMinusMonths_int_endOfMonthAdjust(TestMonthDay_Basics.java:563)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(Lorg/joda/time/ReadablePartial;I[II)[I",
            "method_body": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\nif (valueToAdd == 0) {\nif (DateTimeUtils.isContiguous(partial)) {\nlong instant = 0L;\nfor (int i = 0, isize = partial.size(); i < isize; i++) {\ninstant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\ninstant = add(instant, valueToAdd);\nreturn iChronology.get(partial, instant);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
            "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:isContiguous(Lorg/joda/time/ReadablePartial;)Z",
            "method_body": "public static final boolean isContiguous(ReadablePartial partial) {\nif (partial == null) {\nDurationFieldType lastType = null;\nfor (int i = 0; i < partial.size(); i++) {\nDateTimeField loopField = partial.getField(i);\nif (i > 0) {\nif (loopField.getRangeDurationField().getType() != lastType) {\nlastType = loopField.getDurationField().getType();\nreturn true;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.MonthDay:minusMonths(I)Lorg/joda/time/MonthDay;",
            "method_body": "public MonthDay minusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInMonthMax(I)I",
            "method_body": "int getDaysInMonthMax(int month) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
            "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:indexOfSupported(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "protected int indexOfSupported(DurationFieldType type) {\nint index = indexOf(type);\nif (index == -1) {\nreturn index;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.MonthDay:getFieldType(I)Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public DateTimeFieldType getFieldType(int index) {\nreturn FIELD_TYPES[index];\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "protected int indexOf(DurationFieldType type) {\nfor (int i = 0, isize = size(); i < isize; i++) {\nif (getFieldType(i).getDurationType() == type) {\nreturn i;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.MonthDay:size()I",
            "method_body": "public int size() {\nreturn 2;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.MonthDay:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nList<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>();\nfields.add(DateTimeFieldType.monthOfYear());\nfields.add(DateTimeFieldType.dayOfMonth());\nreturn ISODateTimeFormat.forFields(fields, true, true).print(this);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax(J)I",
            "method_body": "int getDaysInMonthMax(long instant) {\nint thisYear = getYear(instant);\nint thisMonth = getMonthOfYear(instant, thisYear);\nreturn getDaysInYearMonth(thisYear, thisMonth);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.base.BasePartial:getValues()[I",
            "method_body": "public int[] getValues() {\nreturn (int[]) iValues.clone();\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMaximumValue(ReadablePartial partial, int[] values) {\nint size = partial.size();\nfor (int i = 0; i < size; i++) {\nif (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\nint month = values[i];\nfor (int j = 0; j < size; j++) {\nif (partial.getFieldType(j) == DateTimeFieldType.year()) {\nreturn iChronology.getDaysInMonthMax(month);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
            "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax()I",
            "method_body": "int getDaysInMonthMax() {\nreturn 31;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iChronology.getDaysInMonthMax();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn MIN;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iMax;\n}",
            "method_id": 19
        }
    ]
}