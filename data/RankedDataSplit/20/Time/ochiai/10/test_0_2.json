{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay",
    "test_body": "123: public void testFactory_daysBetween_RPartial_MonthDay() {\n124: MonthDay start1 = new MonthDay(2, 1);\n125: MonthDay start2 = new MonthDay(2, 28);\n126: MonthDay end1 = new MonthDay(2, 28);\n127: MonthDay end2 = new MonthDay(2, 29);\n128: 129: assertEquals(27, Days.daysBetween(start1, end1).getDays());\n130: assertEquals(28, Days.daysBetween(start1, end2).getDays());\n131: assertEquals(0, Days.daysBetween(start2, end1).getDays());",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\nat org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:104)\nat org.joda.time.Days.daysBetween(Days.java:141)\nat org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay(TestDays.java:130)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$StringLiteral:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iValue.length();\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn iParsedLengthEstimate;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$MatchingParser:<init>([Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "MatchingParser(DateTimeParser[] parsers) {\nsuper();\niParsers = parsers;\nint est = 0;\nfor (int i=parsers.length; --i>=0 ;) {\nDateTimeParser parser = parsers[i];\nif (parser != null) {\nint len = parser.estimateParsedLength();\nif (len > est) {\nest = len;\n}\niParsedLengthEstimate = est;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$MatchingParser:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn iParsedLengthEstimate;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendOptional(Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\ncheckParser(parser);\nDateTimeParser[] parsers = new DateTimeParser[] {parser, null};\nreturn append0(null, new MatchingParser(parsers));\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:checkParser(Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "private void checkParser(DateTimeParser parser) {\nif (parser == null) {\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.base.BasePartial:getValue(I)I",
            "method_body": "public int getValue(int index) {\nreturn iValues[index];\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.base.BasePartial:<init>([ILorg/joda/time/Chronology;)V",
            "method_body": "protected BasePartial(int[] values, Chronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology);\niChronology = chronology.withUTC();\nchronology.validate(this, values);\niValues = values;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
            "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.base.BasePartial:getChronology()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMaximumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMaximumValue(ReadablePartial instant, int[] values) {\nreturn getMaximumValue(instant);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMaximumValue(Lorg/joda/time/ReadablePartial;)I",
            "method_body": "public int getMaximumValue(ReadablePartial instant) {\nreturn getMaximumValue();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMinimumValue(Lorg/joda/time/ReadablePartial;)I",
            "method_body": "public int getMinimumValue(ReadablePartial instant) {\nreturn getMinimumValue();\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMinimumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMinimumValue(ReadablePartial instant, int[] values) {\nreturn getMinimumValue(instant);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:validate(Lorg/joda/time/ReadablePartial;[I)V",
            "method_body": "public void validate(ReadablePartial partial, int[] values) {\nint size = partial.size();\nfor (int i = 0; i < size; i++) {\nint value = values[i];\nDateTimeField field = partial.getField(i);\nif (value < field.getMinimumValue()) {\nif (value > field.getMaximumValue()) {\nfor (int i = 0; i < size; i++) {\nint value = values[i];\nDateTimeField field = partial.getField(i);\nif (value < field.getMinimumValue(partial, values)) {\nif (value > field.getMaximumValue(partial, values)) {\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:getField(I)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(int index) {\nreturn getField(index, getChronology());\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.DurationFieldType$StandardDurationFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nswitch (iOrdinal) {\nreturn chronology.months();\nreturn chronology.days();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:getDifferenceAsLong(JJ)J",
            "method_body": "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\nlong difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\nreturn difference / iUnitMillis;\n}",
            "method_id": 59
        }
    ]
}