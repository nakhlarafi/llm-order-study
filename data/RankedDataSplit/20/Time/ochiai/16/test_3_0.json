{
    "bug_id": 16,
    "test_id": 3,
    "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29",
    "test_body": "901: public void testParseInto_monthDay_feb29() {\n902: DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n903: MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n904: assertEquals(4, f.parseInto(result, \"2 29\", 0));\n905: assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n906: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2004-02-29T12:20:30.000Z> but was:<2000-02-29T12:20:30.000Z>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29(TestDateTimeFormatter.java:905)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:setChronology(Lorg/joda/time/Chronology;)V",
            "method_body": "protected void setChronology(Chronology chronology) {\niChronology = checkChronology(chronology);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:setChronology(Lorg/joda/time/Chronology;)V",
            "method_body": "public void setChronology(Chronology chronology) {\nsuper.setChronology(chronology);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
            "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTimeNoMillis()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateTimeNoMillis() {\nif (dtx == null) {\nreturn dtx;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn estimatePrintedLength();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
            "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iShort ? 6 : 20;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
            "method_body": "public Locale getLocale() {\nreturn iLocale;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
            "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
            "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
            "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
            "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}",
            "method_id": 19
        }
    ]
}