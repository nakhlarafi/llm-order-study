{
    "bug_id": 32,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldReadBigGid",
    "test_body": "239: public void shouldReadBigGid() throws Exception {\n240: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n241: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n242: tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n243: TarArchiveEntry t = new TarArchiveEntry(\"name\");\n244: t.setGroupId(4294967294l);\n245: t.setSize(1);\n246: tos.putArchiveEntry(t);\n247: tos.write(30);\n248: tos.closeArchiveEntry();\n249: tos.close();\n250: byte[] data = bos.toByteArray();\n251: ByteArrayInputStream bis = new ByteArrayInputStream(data);\n252: TarArchiveInputStream tis =\n253: new TarArchiveInputStream(bis);\n254: t = tis.getNextTarEntry();\n255: assertEquals(4294967294l, t.getLongGroupId());\n256: tis.close();\n257: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:handleLongName(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;BLjava/lang/String;)Z",
            "method_body": "private boolean handleLongName(TarArchiveEntry entry , String name,\nfinal ByteBuffer encodedName = zipEncoding.encode(name);\nfinal int len = encodedName.limit() - encodedName.position();\nif (len >= TarConstants.NAMELEN) {\nreturn false;\n}",
            "method_id": 40,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:transferModTime(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
            "method_body": "private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\nDate fromModTime = from.getModTime();\nlong fromModTimeSeconds = fromModTime.getTime() / 1000;\nif (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\nto.setModTime(fromModTime);\n}",
            "method_id": 41,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
            "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}",
            "method_id": 42,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
            "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}",
            "method_id": 43,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
            "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (byte element : buf) {\nsum += BYTE_MASK & element;\nreturn sum;\n}",
            "method_id": 44,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeRecord([B)V",
            "method_body": "private void writeRecord(byte[] record) throws IOException {\nif (record.length != recordSize) {\nout.write(record);\nrecordsWritten++;\n}",
            "method_id": 45,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
            "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}",
            "method_id": 46,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
            "method_body": "private void paxHeaders() throws IOException{\nMap<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\napplyPaxHeadersToCurrentEntry(headers);\n}",
            "method_id": 47,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
            "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}",
            "method_id": 48,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
            "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}",
            "method_id": 49,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;BZ)V",
            "method_body": "public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\nthis(name, preserveLeadingSlashes);\nthis.linkFlag = linkFlag;\nif (linkFlag == LF_GNUTYPE_LONGNAME) {\n}",
            "method_id": 50,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeaderField(J[BIIZ)I",
            "method_body": "private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\nif (!starMode && (value < 0\nreturn TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\nreturn TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n}",
            "method_id": 51,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(long size) {\nif (size < 0){\nthis.size = size;\n}",
            "method_id": 52,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
            "method_body": "private void writeEOFRecord() throws IOException {\nArrays.fill(recordBuf, (byte) 0);\nwriteRecord(recordBuf);\n}",
            "method_id": 53,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
            "method_body": "public int read() throws IOException {\nint num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}",
            "method_id": 54,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
            "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}",
            "method_id": 55,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:write(I)V",
            "method_body": "public void write(int b) throws IOException {\noneByte[0] = (byte) (b & BYTE_MASK);\nwrite(oneByte, 0, 1);\n}",
            "method_id": 56,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
            "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charsetName));\n}",
            "method_id": 57,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}",
            "method_id": 58,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
            "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}",
            "method_id": 59,
            "loc": 4
        }
    ]
}