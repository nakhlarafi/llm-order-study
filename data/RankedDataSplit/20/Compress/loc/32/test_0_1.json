{
    "bug_id": 32,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldReadBigGid",
    "test_body": "239: public void shouldReadBigGid() throws Exception {\n240: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n241: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n242: tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n243: TarArchiveEntry t = new TarArchiveEntry(\"name\");\n244: t.setGroupId(4294967294l);\n245: t.setSize(1);\n246: tos.putArchiveEntry(t);\n247: tos.write(30);\n248: tos.closeArchiveEntry();\n249: tos.close();\n250: byte[] data = bos.toByteArray();\n251: ByteArrayInputStream bis = new ByteArrayInputStream(data);\n252: TarArchiveInputStream tis =\n253: new TarArchiveInputStream(bis);\n254: t = tis.getNextTarEntry();\n255: assertEquals(4294967294l, t.getLongGroupId());\n256: tis.close();\n257: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;Z)V",
            "method_body": "public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\nthis();\nname = normalizeFileName(name, preserveLeadingSlashes);\nboolean isDir = name.endsWith(\"/\");\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.modTime = new Date().getTime() / MILLIS_PER_SECOND;\nthis.userName = \"\";\n}",
            "method_id": 20,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)I",
            "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset,\nint len = name.length();\nByteBuffer b = encoding.encode(name);\nwhile (b.limit() > length && len > 0) {\nfinal int limit = b.limit() - b.position();\nSystem.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\nfor (int i = limit; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}",
            "method_id": 21,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:applyPaxHeadersToCurrentEntry(Ljava/util/Map;)V",
            "method_body": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\nfor (Entry<String, String> ent : headers.entrySet()){\nString key = ent.getKey();\nString val = ent.getValue();\nif (\"path\".equals(key)){\n} else if (\"linkpath\".equals(key)){\n} else if (\"gid\".equals(key)){\ncurrEntry.setGroupId(Integer.parseInt(val));\n}",
            "method_id": 22,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
            "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}",
            "method_id": 23,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:stripTo7Bits(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "private String stripTo7Bits(String name) {\nfinal int length = name.length();\nStringBuilder result = new StringBuilder(length);\nfor (int i = 0; i < length; i++) {\nchar stripped = (char) (name.charAt(i) & 0x7F);\nif (shouldBeReplaced(stripped)) {\nresult.append(stripped);\nreturn result.toString();\n}",
            "method_id": 24,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif (finished) {\nif (haveUnclosedEntry) {\nwriteEOFRecord();\nwriteEOFRecord();\npadAsNeeded();\nout.flush();\nfinished = true;\n}",
            "method_id": 25,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:addPaxHeadersForBigNumbers(Ljava/util/Map;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
            "method_body": "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\naddPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\naddPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(),\naddPaxHeaderForBigNumber(paxHeaders, \"mtime\",\naddPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getLongUserId(),\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\nfailForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n}",
            "method_id": 26,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
            "method_body": "private static String normalizeFileName(String fileName,\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\nif (osname != null) {\nif (osname.startsWith(\"windows\")) {\n} else if (osname.contains(\"netware\")) {\nfileName = fileName.replace(File.separatorChar, '/');\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nreturn fileName;\n}",
            "method_id": 27,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
            "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}",
            "method_id": 28,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
            "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\nif (length1 == length2){\nreturn true;\n}",
            "method_id": 29,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
            "method_body": "public long skip(final long n) throws IOException {\nif (n <= 0) {\nfinal long available = entrySize - entryOffset;\nfinal long skipped = is.skip(Math.min(n, available));\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}",
            "method_id": 30,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
            "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nif (!closed) {\nout.close();\nclosed = true;\n}",
            "method_id": 31,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
            "method_body": "private void skipRecordPadding() throws IOException {\nif (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nlong numRecords = (this.entrySize / this.recordSize) + 1;\nlong padding = (numRecords * this.recordSize) - this.entrySize;\nlong skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}",
            "method_id": 32,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
            "method_body": "protected byte[] readRecord() throws IOException {\nbyte[] record = new byte[recordSize];\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}",
            "method_id": 33,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
            "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}",
            "method_id": 34,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
            "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\nreturn offset + length;\n}",
            "method_id": 35,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
            "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}",
            "method_id": 36,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}",
            "method_id": 37,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:padAsNeeded()V",
            "method_body": "private void padAsNeeded() throws IOException {\nint start = recordsWritten % recordsPerBlock;\nif (start != 0) {\nfor (int i = start; i < recordsPerBlock; i++) {\nwriteEOFRecord();\n}",
            "method_id": 38,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
            "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}",
            "method_id": 39,
            "loc": 6
        }
    ]
}