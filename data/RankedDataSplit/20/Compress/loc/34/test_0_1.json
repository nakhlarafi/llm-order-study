{
    "bug_id": 34,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.X7875_NewUnixTest.testParseReparse",
    "test_body": "139: public void testParseReparse() throws ZipException {\n140: 141: // Version=1, Len=0, Len=0.\n142: final byte[] ZERO_LEN = {1, 0, 0};\n143: 144: // Version=1, Len=1, zero, Len=1, zero.\n145: final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n146: 147: // Version=1, Len=1, one, Len=1, one\n148: final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n149: 150: // Version=1, Len=2, one thousand, Len=2, one thousand\n151: final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n152: 153: // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n154: // two's complement, and -1 often has a special meaning.\n155: final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n156: 157: // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n158: // Esoteric test:  can we handle 40 bit numbers?\n159: final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n160: 161: // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n162: // Esoteric test:  can we handle 64 bit numbers?\n163: final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n164: 165: final long TWO_TO_32 = 0x100000000L;\n166: final long MAX = TWO_TO_32 - 2;\n167: 168: parseReparse(0, 0, ZERO_LEN, 0, 0);\n169: parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n170: parseReparse(1, 1, ONE_UID_GID, 1, 1);\n171: parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n172: parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n173: parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n174: parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n175: parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n176: 177: // We never emit this, but we should be able to parse it:\n178: final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n179: final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n180: xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n181: 182: assertEquals(255, xf.getUID());\n183: assertEquals(128, xf.getGID());\n184: assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n185: 186: final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n187: final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n188: xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n189: 190: assertEquals(65535, xf.getUID());\n191: assertEquals(513, xf.getGID());\n192: assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n193: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
            "method_body": "public int getValue() {\nreturn value;\n}",
            "method_id": 20,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getUID()J",
            "method_body": "public long getUID() { return ZipUtil.bigToLong(uid); }\npublic long getUID() { return ZipUtil.bigToLong(uid); }",
            "method_id": 21,
            "loc": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getGID()J",
            "method_body": "public long getGID() { return ZipUtil.bigToLong(gid); }\npublic long getGID() { return ZipUtil.bigToLong(gid); }",
            "method_id": 22,
            "loc": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
            "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}",
            "method_id": 23,
            "loc": 2
        }
    ]
}