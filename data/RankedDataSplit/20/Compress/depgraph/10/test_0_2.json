{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive",
    "test_body": "126: public void testReadWinZipArchive() throws IOException, URISyntaxException {\n127: URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n128: File archive = new File(new URI(zip.toString()));\n129: ZipFile zf = null;\n130: try {\n131: zf = new ZipFile(archive, null, true);\n132: assertCanRead(zf, ASCII_TXT);\n133: assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n134: assertCanRead(zf, OIL_BARREL_TXT);",
    "stack_trace": "junit.framework.AssertionFailedError: InputStream is null\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.assertTrue(Assert.java:22)\nat junit.framework.Assert.assertNotNull(Assert.java:256)\nat junit.framework.TestCase.assertNotNull(TestCase.java:426)\nat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.assertCanRead(UTF8ZipFilesTest.java:144)\nat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive(UTF8ZipFilesTest.java:133)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
            "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\nif (origCRC32 == f.getNameCRC32()) {\nreturn ZipEncodingHelper\nreturn null;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
            "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
            "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:<init>()V",
            "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
            "method_body": "public void setCentralDirectoryExtra(byte[] b) {\nZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
            "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
            "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
            "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
            "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
            "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
            "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
            "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
            "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
            "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
            "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (int i = 0; i < f.length; i++) {\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = getExtraField(f[i].getHeaderId());\nif (existing == null) {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nsetExtra();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
            "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\nsetExtra();\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
            "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}",
            "method_id": 59
        }
    ]
}