{
    "bug_id": 28,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldThrowAnExceptionOnTruncatedEntries",
    "test_body": "213: public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n214: File dir = mkdir(\"COMPRESS-279\");\n215: TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n216: FileOutputStream out = null;\n217: try {\n218: TarArchiveEntry entry = is.getNextTarEntry();\n219: int count = 0;\n220: while (entry != null) {\n221: out = new FileOutputStream(new File(dir, String.valueOf(count)));\n222: IOUtils.copy(is, out);\n223: out.close();\n224: out = null;\n225: count++;\n226: entry = is.getNextTarEntry();\n227: }\n228: } finally {\n229: is.close();\n230: if (out != null) {\n231: out.close();\n232: }\n233: }\n234: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: Expected exception: java.io.IOException\nat org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\nat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\nat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\nat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\nat org.apache.tools.ant.Task.perform(Task.java:348)\nat org.apache.tools.ant.Target.execute(Target.java:392)\nat org.apache.tools.ant.Target.performTasks(Target.java:413)\nat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\nat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\nat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\nat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\nat org.apache.tools.ant.Main.runBuild(Main.java:811)\nat org.apache.tools.ant.Main.startAnt(Main.java:217)\nat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\nat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
            "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
            "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nnumToSkip -= skipped;\n}\nwhile (numToSkip > 0) {\nreturn available - numToSkip;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
            "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\nreturn count;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
            "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
            "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, COPY_BUF_SIZE);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
            "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBoolean([BI)Z",
            "method_body": "public static boolean parseBoolean(final byte[] buffer, final int offset) {\nreturn buffer[offset] == 1;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
            "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
            "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
            "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
            "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
            "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
            "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
            "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
            "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nif (length1 == length2){\nreturn true;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
            "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
            "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
            "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
            "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}",
            "method_id": 39
        }
    ]
}