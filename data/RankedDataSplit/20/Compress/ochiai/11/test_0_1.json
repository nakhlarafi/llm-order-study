{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs",
    "test_body": "32: public void shortTextFilesAreNoTARs() throws Exception {\n33: try {\n34: new ArchiveStreamFactory()\n35: .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n36: fail(\"created an input stream for a non-archive\");\n37: } catch (ArchiveException ae) {",
    "stack_trace": "junit.framework.AssertionFailedError: created an input stream for a non-archive\nat org.junit.Assert.fail(Assert.java:88)\nat org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs(ArchiveStreamFactoryTest.java:36)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
            "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\nthis.initialize(blockSize, recordSize);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
            "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nif (allNUL) {\nreturn 0L;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
            "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
            "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name.toString();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn size;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
            "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
            "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
            "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
            "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
            "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
            "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 39
        }
    ]
}