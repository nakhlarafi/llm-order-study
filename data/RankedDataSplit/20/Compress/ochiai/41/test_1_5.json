{
    "bug_id": 41,
    "test_id": 1,
    "test_name": "org.apache.commons.compress.archivers.ZipTestCase.testListAllFilesWithNestedArchive",
    "test_body": "243: public void testListAllFilesWithNestedArchive() throws Exception {\n244: final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n245: 246: final List<String> results = new ArrayList<>();\n247: final List<ZipException> expectedExceptions = new ArrayList<>();\n248: 249: final InputStream is = new FileInputStream(input);\n250: ArchiveInputStream in = null;\n251: try {\n252: in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n253: 254: ZipArchiveEntry entry = null;\n255: while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n256: results.add(entry.getName());\n257: 258: final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n259: try {\n260: ZipArchiveEntry nestedEntry = null;\n261: while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n262: results.add(nestedEntry.getName());\n263: }\n264: } catch (ZipException ex) {\n265: // expected since you cannot create a final ArchiveInputStream from test3.xml\n266: expectedExceptions.add(ex);\n267: }\n268: // nested stream must not be closed here\n269: }\n270: } finally {\n271: if (in != null) {\n272: in.close();\n273: }\n274: }\n275: is.close();\n276: 277: assertTrue(results.contains(\"NestedArchiv.zip\"));\n278: assertTrue(results.contains(\"test1.xml\"));\n279: assertTrue(results.contains(\"test2.xml\"));\n280: assertTrue(results.contains(\"test3.xml\"));\n281: assertEquals(1, expectedExceptions.size());\n282: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:555)\nat org.junit.Assert.assertEquals(Assert.java:542)\nat org.apache.commons.compress.archivers.ZipTestCase.testListAllFilesWithNestedArchive(ZipTestCase.java:281)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getBytesInflated()J",
            "method_body": "private long getBytesInflated() {\nlong inB = inf.getBytesRead();\nif (current.bytesReadFromStream >= TWO_EXP_32) {\nreturn inB;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
            "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skip(J)J",
            "method_body": "public long skip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\nreturn skipped;\nskipped += x;\n}\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:pushback([BII)V",
            "method_body": "private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n((PushbackInputStream) in).unread(buf, offset, length);\npushedBackBytes(length);\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readDeflated([BII)I",
            "method_body": "private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\nfinal int read = readFromInflater(buffer, offset, length);\nif (read <= 0) {\nif (inf.finished()) {\nreturn -1;\nreturn read;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFromInflater([BII)I",
            "method_body": "private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\nint read = 0;\nif (inf.needsInput()) {\nfinal int l = fill();\nif (l > 0) {\ncurrent.bytesReadFromStream += buf.limit();\nread = inf.inflate(buffer, offset, length);\n}\n} while (read == 0 && inf.needsInput());\nreturn read;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:fill()I",
            "method_body": "private int fill() throws IOException {\nif (closed) {\nfinal int length = in.read(buf.array());\nif (length > 0) {\nbuf.limit(length);\ncount(buf.limit());\ninf.setInput(buf.array(), 0, buf.limit());\nreturn length;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skipRemainderOfArchive()V",
            "method_body": "private void skipRemainderOfArchive() throws IOException {\nrealSkip(entriesRead * CFH_LEN - LFH_LEN);\nfindEocdRecord();\nrealSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\nreadFully(SHORT_BUF);\nrealSkip(ZipShort.getValue(SHORT_BUF));\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:findEocdRecord()V",
            "method_body": "private void findEocdRecord() throws IOException {\nint currentByte = -1;\nboolean skipReadCall = false;\nwhile (skipReadCall || (currentByte = readOneByte()) > -1) {\nskipReadCall = false;\nif (!isFirstByteOfEocdSig(currentByte)) {\ncontinue;\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\ncurrentByte = readOneByte();\nif (currentByte == -1\nbreak;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:realSkip(J)V",
            "method_body": "private void realSkip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\ncount(x);\nskipped += x;\n}\nreturn;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readOneByte()I",
            "method_body": "private int readOneByte() throws IOException {\nfinal int b = in.read();\nif (b != -1) {\ncount(1);\nreturn b;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:isFirstByteOfEocdSig(I)Z",
            "method_body": "private boolean isFirstByteOfEocdSig(final int b) {\nreturn b == ZipArchiveOutputStream.EOCD_SIG[0];\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
            "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
            "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
            "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<clinit>()V",
            "method_body": "private static final int TAR_HEADER_SIZE = 512;\nprivate static final ArchiveStreamFactory SINGLETON = new ArchiveStreamFactory();\n* Constant (value {@value}) used to identify the AR archive format.",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
            "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nif (current == null) {\nif (currentEntryHasOutstandingBytes()) {\nskip(Long.MAX_VALUE);\nfinal long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\nfinal int diff = (int) (current.bytesReadFromStream - inB);\nif (diff > 0) {\npushback(buf.array(), buf.limit() - diff, diff);\ncurrent.bytesReadFromStream -= diff;\nif (currentEntryHasOutstandingBytes()) {\nif (lastStoredEntry == null && current.hasDataDescriptor) {\nreadDataDescriptor();\ninf.reset();\nbuf.clear().flip();\ncurrent = null;\nlastStoredEntry = null;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:currentEntryHasOutstandingBytes()Z",
            "method_body": "private boolean currentEntryHasOutstandingBytes() {\nreturn current.bytesReadFromStream <= current.entry.getCompressedSize()\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
            "method_body": "public int read(final byte[] buffer, final int offset, final int length) throws IOException {\nif (closed) {\nif (current == null) {\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\nread = readDeflated(buffer, offset, length);\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\nreturn read;\n}",
            "method_id": 119
        }
    ]
}