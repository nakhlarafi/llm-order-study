{
    "bug_id": 41,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testThrowOnInvalidEntry",
    "test_body": "236: public void testThrowOnInvalidEntry() throws Exception {\n237: final InputStream is = ZipArchiveInputStreamTest.class\n238: .getResourceAsStream(\"/invalid-zip.zip\");\n239: final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n240: 241: try {\n242: zip.getNextZipEntry();\n243: fail(\"IOException expected\");\n244: } catch (ZipException expected) {\n245: assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n246: } finally {\n247: zip.close();\n248: }\n249: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
            "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
            "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
            "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
            "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
            "method_body": "private final ZipEncoding zipEncoding;\nprivate final Inflater inf = new Inflater(true);\nprivate final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\nprivate CurrentEntry current = null;\nprivate boolean closed = false;\nprivate boolean hitCentralDirectory = false;\nprivate ByteArrayInputStream lastStoredEntry = null;\nprivate boolean allowStoredEntriesWithDataDescriptor = false;\nprivate final byte[] LFH_BUF = new byte[LFH_LEN];\nprivate final byte[] SKIP_BUF = new byte[1024];\nprivate final byte[] SHORT_BUF = new byte[SHORT];\nprivate final byte[] WORD_BUF = new byte[WORD];\nprivate final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\nprivate int entriesRead = 0;\nthis(inputStream, ZipEncodingHelper.UTF8);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
            "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\nif (firstEntry) {\nreadFirstLocalFileHeader(LFH_BUF);\nreadFully(LFH_BUF);\n}\nfinal ZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\nint off = WORD;\ncurrent = new CurrentEntry();\nfinal int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\noff += SHORT;\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\noff += 3 * WORD;\nfinal int fileNameLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal byte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\nfinal byte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\nprocessZip64Extra(size, cSize);\nif (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\nentriesRead++;\nreturn current.entry;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
            "method_body": "protected void count(final int read) {\ncount((long) read);\n}",
            "method_id": 29
        }
    ]
}