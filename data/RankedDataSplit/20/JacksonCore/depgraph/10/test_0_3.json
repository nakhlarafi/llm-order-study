{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207",
    "test_body": "102: public void testIssue207() throws Exception\n103: {\n104: ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\n105: Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n106: byteSymbolCanonicalizerField.setAccessible(true);\n107: JsonFactory jsonF = new JsonFactory();\n108: byteSymbolCanonicalizerField.set(jsonF, nc);\n109: 110: StringBuilder stringBuilder = new StringBuilder();\n111: stringBuilder.append(\"{\\n\");\n112: stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n113: for (int i = 0; i < 60; ++i) {\n114: stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n115: }\n116: stringBuilder.append(\"\\n}\");\n117: 118: JsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\n119: while (p.nextToken() != null) { }\n120: p.close();",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 256\nat com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseEscapedName(UTF8StreamJsonParser.java:1980)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.slowParseName(UTF8StreamJsonParser.java:1867)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1651)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:740)\nat com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207(TestByteBasedSymbols.java:119)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:slowParseName()Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 60
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseEscapedName([IIIII)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_matchToken(Ljava/lang/String;I)V",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:findName(II)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 63
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_nextAfterName()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextTokenNotInObject(int i) throws IOException\nif (i == INT_QUOTE) {\nswitch (i) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\nif (t == JsonToken.START_ARRAY) {\n} else if (t == JsonToken.START_OBJECT) {\nreturn (_currToken = t);\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:pad(II)I",
            "method_body": "private final static int pad(int q, int bytes) {\nreturn (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:addName([III)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipColon()I",
            "method_body": "private final int _skipColon() throws IOException\nif ((_inputPtr + 4) >= _inputEnd) {\nint i = _inputBuffer[_inputPtr];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n++_inputPtr;\nreturn i;\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_parseName(I)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipWS()I",
            "method_body": "private final int _skipWS() throws IOException\nwhile (_inputPtr < _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn i;\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n}",
            "method_id": 69
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:setCurrentName(Ljava/lang/String;)V",
            "method_body": "public void setCurrentName(String name) throws JsonProcessingException {\n_currentName = name;\nif (_dups != null) { _checkDup(_dups, name); }\n}",
            "method_id": 70
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public JsonReadContext createChildObjectContext(int lineNr, int colNr) {\nJsonReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new JsonReadContext(this,\nreturn ctxt;\n}",
            "method_id": 71
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:emptyAndGetCurrentSegment()[C",
            "method_body": "public char[] emptyAndGetCurrentSegment()\n_inputStart = -1; // indicates shared buffer not used\n_currentSize = 0;\n_inputLen = 0;\n_inputBuffer = null;\n_resultString = null;\n_resultArray = null;\nif (_hasSegments) {\nchar[] curr = _currentSegment;\nif (curr == null) {\n_currentSegment = curr = buf(0);\nreturn curr;\n}",
            "method_id": 72
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:<clinit>()V",
            "method_body": "final static byte BYTE_LF = (byte) '\\n';\nprivate final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\nprotected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\nprotected int[] _quadBuffer = new int[16];\nprotected boolean _tokenIncomplete = false;\nsuper(ctxt, features);\n_inputStream = in;\n_objectCodec = codec;\n_symbols = sym;\n_inputBuffer = inputBuffer;\n_inputPtr = start;\n_inputEnd = end;\n_currInputRowStart = start;\n_currInputProcessed = -start;\n_bufferRecyclable = bufferRecyclable;\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_nextTokenNotInObject(I)Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextTokenNotInObject(int i) throws IOException\nif (i == INT_QUOTE) {\nswitch (i) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\nif (t == JsonToken.START_ARRAY) {\n} else if (t == JsonToken.START_OBJECT) {\nreturn (_currToken = t);\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipWSOrEnd()I",
            "method_body": "private final int _skipWSOrEnd() throws IOException\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn i;\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nwhile (_inputPtr < _inputEnd) {\ni = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn i;\nif (i != INT_SPACE) {\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeUtf8()[I",
            "method_body": "public static int[] getInputCodeUtf8() { return sInputCodesUTF8; }\npublic static int[] getInputCodeUtf8() { return sInputCodesUTF8; }",
            "method_id": 76
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:buf(I)[C",
            "method_body": "private char[] buf(int needed)\nif (_allocator != null) {\nreturn _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n}",
            "method_id": 77
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonEncoding:<init>(Ljava/lang/String;ILjava/lang/String;ZI)V",
            "method_body": "JsonEncoding(String javaName, boolean bigEndian, int bits)\n{\n_javaName = javaName;\n_bigEndian = bigEndian;\n_bits = bits;\n}",
            "method_id": 78
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:expectComma()Z",
            "method_body": "public boolean expectComma() {\nint ix = ++_index; // starts from -1\nreturn (_type != TYPE_ROOT && ix > 0);\n}",
            "method_id": 79
        }
    ]
}