{
    "bug_id": 14,
    "test_id": 1,
    "test_name": "org.jsoup.parser.ParserTest.handlesUnclosedTitle",
    "test_body": "554: @Test public void handlesUnclosedTitle() {\n555: Document one = Jsoup.parse(\"<title>One <b>Two <b>Three</TITLE><p>Test</p>\"); // has title, so <b> is plain text\n556: assertEquals(\"One <b>Two <b>Three\", one.title());\n557: assertEquals(\"Test\", one.select(\"p\").first().text());\n558: 559: Document two = Jsoup.parse(\"<title>One<b>Two <p>Test</p>\"); // no title, so <b> causes </title> breakout\n560: assertEquals(\"One\", two.title());\n561: assertEquals(\"<b>Two <p>Test</p></b>\", two.body().html());",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<One[]> but was:<One[<b>Two <p>Test</p]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.jsoup.parser.ParserTest.handlesUnclosedTitle(ParserTest.java:560)",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.Tag:preserveWhitespace()Z",
            "method_body": "public boolean preserveWhitespace() {\nreturn preserveWhitespace;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>(Ljava/lang/String;)V",
            "method_body": "Character(String data) {\ntype = TokenType.Character;\nthis.data = data;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitTagPending()V",
            "method_body": "void emitTagPending() {\ntagPending.finaliseTag();\nemit(tagPending);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.parser.Token:asCharacter()Lorg/jsoup/parser/Token$Character;",
            "method_body": "Character asCharacter() {\nreturn (Character) this;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.parser.Token:isDoctype()Z",
            "method_body": "boolean isDoctype() {\nreturn type == TokenType.Doctype;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.parser.Token:isComment()Z",
            "method_body": "boolean isComment() {\nreturn type == TokenType.Comment;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCharacter()Z",
            "method_body": "boolean isCharacter() {\nreturn type == TokenType.Character;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nreturn isEmpty() ? EOF : input.charAt(pos++);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn isEmpty() ? EOF : input.charAt(pos);\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(C)V",
            "method_body": "void appendTagName(char append) {\nappendTagName(String.valueOf(append));\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\nt.advanceTransition(TagOpen);\nbreak;\nt.emit(new Token.EOF());\nbreak;\nString data = r.consumeToAny('&', '<', nullChar);\nt.emit(data);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\nt.advanceTransition(EndTagOpen);\nbreak;\nif (r.matchesLetter()) {\nt.createTagPending(true);\nt.transition(TagName);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$3:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\n} else if (t.isComment()) {\n} else if (t.isDoctype()) {\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\nElement head = tb.insert(t.asStartTag());\ntb.setHeadElement(head);\ntb.transition(InHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n} else if (t.isEndTag()) {\ntb.process(new Token.StartTag(\"head\"));\nreturn tb.process(t);\nreturn true;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeWhitespace()Z",
            "method_body": "public boolean consumeWhitespace() {\nboolean seen = false;\nwhile (matchesWhitespace()) {\nreturn seen;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nchar c = input.charAt(pos);\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$10:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nString tagName = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '>', nullChar).toLowerCase();\nt.tagPending.appendTagName(tagName);\nswitch (r.consume()) {\nt.emitTagPending();\nt.transition(Data);\nbreak;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchChomp(Ljava/lang/String;)Z",
            "method_body": "public boolean matchChomp(String seq) {\nif (matches(seq)) {\nreturn false;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:framesetOk(Z)V",
            "method_body": "void framesetOk(boolean framesetOk) {\nthis.framesetOk = framesetOk;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAny([C)Ljava/lang/String;",
            "method_body": "String consumeToAny(char... seq) {\nint start = pos;\nOUTER: while (!isEmpty()) {\nchar c = input.charAt(pos);\nfor (char seek : seq) {\nif (seek == c)\nbreak OUTER;\npos++;\n}\nreturn pos > start ? input.substring(start, pos) : \"\";\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesAny([Ljava/lang/String;)Z",
            "method_body": "public boolean matchesAny(String... seq) {\nfor (String s : seq) {\nif (matches(s))\nreturn false;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nboolean selfClosing = false;\nAttributes attributes = new Attributes(); // todo: allow nodes to not have attributes\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState:isWhitespace(Lorg/jsoup/parser/Token;)Z",
            "method_body": "abstract boolean process(Token t, TreeBuilder tb);\nif (t.isCharacter()) {\nString data = t.asCharacter().getData();\nfor (int i = 0; i < data.length(); i++) {\nchar c = data.charAt(i);\nif (!Character.isWhitespace(c))\nreturn false;\nreturn false;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? new Token.StartTag() : new Token.EndTag();\nreturn tagPending;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name()Ljava/lang/String;",
            "method_body": "String name() {\nValidate.isFalse(tagName.isEmpty());\nreturn tagName;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeElementSelector()Ljava/lang/String;",
            "method_body": "public String consumeElementSelector() {\nint start = pos;\nwhile (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\npos++;\nreturn queue.substring(start, pos);\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>(Ljava/lang/String;)V",
            "method_body": "StartTag(String name) {\nthis();\nthis.tagName = name;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>(Ljava/lang/String;)V",
            "method_body": "EndTag(String name) {\nthis();\nthis.tagName = name;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>()V",
            "method_body": "EndTag() {\nsuper();\ntype = TokenType.EndTag;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\ntype = TokenType.StartTag;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:originalState()Lorg/jsoup/parser/TreeBuilderState;",
            "method_body": "TreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$2:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (t.isDoctype()) {\n} else if (t.isComment()) {\n} else if (isWhitespace(t)) {\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n} else if (t.isEndTag()) {\nreturn anythingElse(t, tb);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:reconstructFormattingElements()V",
            "method_body": "void reconstructFormattingElements() {\nint size = formattingElements.size();\nif (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\nreturn;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWhitespace()Z",
            "method_body": "public boolean matchesWhitespace() {\nreturn !isEmpty() && Character.isWhitespace(queue.charAt(pos));\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWord()Z",
            "method_body": "public boolean matchesWord() {\nreturn !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn remainingLength() == 0;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:remainingLength()I",
            "method_body": "private int remainingLength() {\nreturn queue.length() - pos;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:inScope(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName, String[] extras) {\nreturn inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.jsoup.parser.Token:isStartTag()Z",
            "method_body": "boolean isStartTag() {\nreturn type == TokenType.StartTag;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEndTag()Z",
            "method_body": "boolean isEndTag() {\nreturn type == TokenType.EndTag;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.jsoup.parser.Token:asEndTag()Lorg/jsoup/parser/Token$EndTag;",
            "method_body": "EndTag asEndTag() {\nreturn (EndTag) this;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState:<init>(Ljava/lang/String;I)V",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\nswitch (t.type) {\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n} else if (name.equals(\"meta\")) {\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\n} else if (name.equals(\"noscript\")) {\n} else if (name.equals(\"script\")) {\n} else if (name.equals(\"head\")) {\nreturn anythingElse(t, tb);\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\nreturn anythingElse(t, tb);\nreturn true;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:currentElement()Lorg/jsoup/nodes/Element;",
            "method_body": "Element currentElement() {\nreturn stack.getLast();\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "boolean isEmpty() {\nreturn pos >= length;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:setHeadElement(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void setHeadElement(Element headElement) {\nthis.headElement = headElement;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:finaliseTag()V",
            "method_body": "void finaliseTag() {\nif (pendingAttributeName != null) {\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:popStackToClose(Ljava/lang/String;)V",
            "method_body": "void popStackToClose(String elName) {\nIterator<Element> it = stack.descendingIterator();\nwhile (it.hasNext()) {\nElement next = it.next();\nif (next.nodeName().equals(elName)) {\nit.remove();\nbreak;\n}",
            "method_id": 99
        }
    ]
}