{
    "bug_id": 6,
    "test_id": 26,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testDiffPow",
    "test_body": "public void testDiffPow() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new DiffPow(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 10, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testDiffPow(CMAESOptimizerTest.java:288)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:triu(Lorg/apache/commons/math3/linear/RealMatrix;I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix triu(final RealMatrix m, int k) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:unbounded(I)Lorg/apache/commons/math3/optim/SimpleBounds;",
            "method_body": "public static SimpleBounds unbounded(int dim) {\nfinal double[] lB = new double[dim];\nArrays.fill(lB, Double.NEGATIVE_INFINITY);\nfinal double[] uB = new double[dim];\nArrays.fill(uB, Double.POSITIVE_INFINITY);\nreturn new SimpleBounds(lB, uB);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x == Double.POSITIVE_INFINITY) {\nint exp = (int)(bits >> 52)-1023;\nif ((bits & 0x7ff0000000000000L) == 0) {\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nreturn ya + yb;\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\nif (hiPrec != null) {\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\nif (hiPrec != null) {\nreturn a + b;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:compareTo(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer$DoubleIndex;)I",
            "method_body": "public int compareTo(DoubleIndex o) {\nreturn Double.compare(value, o.value);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:<init>(D)V",
            "method_body": "CodyWaite(double xa) {\nint k = (int)(xa * 0.6366197723675814);\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\nif (remA > 0) {\nbreak;\nthis.finalK = k;\nthis.finalRemA = remA;\nthis.finalRemB = remB;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkAdditionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(final double[][] subMatrix, final int row,\nif (data == null) {\nif (row > 0) {\nif (column > 0) {\nMathUtils.checkNotNull(subMatrix);\nfinal int nRows = subMatrix.length;\nif (nRows == 0) {\nfinal int nCols = subMatrix[0].length;\nif (nCols == 0) {\ndata = new double[subMatrix.length][nCols];\nfor (int i = 0; i < data.length; ++i) {\nif (subMatrix[i].length != nCols) {\nSystem.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n} else {\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:<init>(IDZIILorg/apache/commons/math3/random/RandomGenerator;ZLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public CMAESOptimizer(int maxIterations,\nsuper(checker);\nthis.maxIterations = maxIterations;\nthis.stopFitness = stopFitness;\nthis.isActiveCMA = isActiveCMA;\nthis.diagonalOnly = diagonalOnly;\nthis.checkFeasableCount = checkFeasableCount;\nthis.random = random;\nthis.generateStatistics = generateStatistics;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\ndouble a = 0;\ndouble b = 0;\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nb = b + sintA * cosEpsB + costA * sinEpsB;\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nresult = a + b;\nreturn result;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:transform()V",
            "method_body": "private void transform() {\nfinal int m = householderVectors.length;\nfinal double[] z = new double[m];\nfor (int k = 0; k < m - 1; k++) {\nfinal double[] hK = householderVectors[k];\nmain[k] = hK[k];\ndouble xNormSqr = 0;\nfor (int j = k + 1; j < m; ++j) {\nfinal double c = hK[j];\nxNormSqr += c * c;\nfinal double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\nsecondary[k] = a;\nif (a != 0.0) {\nhK[k + 1] -= a;\nfinal double beta = -1 / (a * hK[k + 1]);\nArrays.fill(z, k + 1, m, 0);\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfinal double hKI = hK[i];\ndouble zI = hI[i] * hKI;\nfor (int j = i + 1; j < m; ++j) {\nfinal double hIJ = hI[j];\nzI   += hIJ * hK[j];\nz[j] += hIJ * hKI;\nz[i] = beta * (z[i] + zI);\ndouble gamma = 0;\nfor (int i = k + 1; i < m; ++i) {\ngamma += z[i] * hK[i];\ngamma *= beta / 2;\nfor (int i = k + 1; i < m; ++i) {\nz[i] -= gamma * hK[i];\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfor (int j = i; j < m; ++j) {\nhI[j] -= hK[i] * z[j] + z[i] * hK[j];\nmain[m - 1] = householderVectors[m - 1][m - 1];\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\ndouble xa = x;\nif (x < 0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\ndouble xb = 0;\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nswitch (quadrant) {\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\nreturn sinQ(xa, xb);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:eye(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix eye(int n, int m) {\nfinal double[][] d = new double[n][m];\nfor (int r = 0; r < n; r++) {\nif (r < m) {\nd[r][r] = 1;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:reverse([I)[I",
            "method_body": "private static int[] reverse(final int[] indices) {\nfinal int[] reverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\nreverse[i] = indices[indices.length - i - 1];\nreturn reverse;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:transformToTridiagonal(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void transformToTridiagonal(final RealMatrix matrix) {\ntransformer = new TriDiagonalTransformer(matrix);\nmain = transformer.getMainDiagonalRef();\nsecondary = transformer.getSecondaryDiagonalRef();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nNullArgumentException {\nif (copyArray) {\nif (d == null) {\nfinal int nRows = d.length;\nif (nRows == 0) {\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\ndata = d;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:<init>([D[D)V",
            "method_body": "public SimpleBounds(double[] lB,\ndouble[] uB) {\nlower = lB.clone();\nupper = uB.clone();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getSecondaryDiagonalRef()[D",
            "method_body": "double[] getSecondaryDiagonalRef() {\nreturn secondary;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof GoalType) {\ngoal = (GoalType) data;\ncontinue;\nif (data instanceof ObjectiveFunction) {\nfunction = ((ObjectiveFunction) data).getObjectiveFunction();\ncontinue;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:nextGaussian()D",
            "method_body": "public double nextGaussian() {\nif (Double.isNaN(nextGaussian)) {\nfinal double x = nextDouble();\nfinal double y = nextDouble();\nfinal double alpha = 2 * FastMath.PI * x;\nfinal double r      = FastMath.sqrt(-2 * FastMath.log(y));\nrandom       = r * FastMath.cos(alpha);\nnextGaussian = r * FastMath.sin(alpha);\n} else {\nrandom = nextGaussian;\nnextGaussian = Double.NaN;\nreturn random;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:findEigenVectors([[D)V",
            "method_body": "private void findEigenVectors(final double[][] householderMatrix) {\nfinal double[][]z = householderMatrix.clone();\nfinal int n = main.length;\nrealEigenvalues = new double[n];\nimagEigenvalues = new double[n];\nfinal double[] e = new double[n];\nfor (int i = 0; i < n - 1; i++) {\nrealEigenvalues[i] = main[i];\ne[i] = secondary[i];\nrealEigenvalues[n - 1] = main[n - 1];\ne[n - 1] = 0;\ndouble maxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\nif (FastMath.abs(e[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(e[i]);\nif (maxAbsoluteValue != 0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\nif (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\ne[i]=0;\nfor (int j = 0; j < n; j++) {\nint its = 0;\nfor (m = j; m < n - 1; m++) {\ndouble delta = FastMath.abs(realEigenvalues[m]) +\nif (FastMath.abs(e[m]) + delta == delta) {\nbreak;\nif (m != j) {\nif (its == maxIter) {\nits++;\ndouble q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\ndouble t = FastMath.sqrt(1 + q * q);\nif (q < 0.0) {\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\ndouble u = 0.0;\ndouble s = 1.0;\ndouble c = 1.0;\nfor (i = m - 1; i >= j; i--) {\ndouble p = s * e[i];\ndouble h = c * e[i];\nif (FastMath.abs(p) >= FastMath.abs(q)) {\nc = q / p;\nt = FastMath.sqrt(c * c + 1.0);\ne[i + 1] = p * t;\ns = 1.0 / t;\nc = c * s;\ns = p / q;\nt = FastMath.sqrt(s * s + 1.0);\ne[i + 1] = q * t;\nc = 1.0 / t;\ns = s * c;\nif (e[i + 1] == 0.0) {\nq = realEigenvalues[i + 1] - u;\nt = (realEigenvalues[i] - q) * s + 2.0 * c * h;\nu = s * t;\nrealEigenvalues[i + 1] = q + u;\nq = c * t - h;\nfor (int ia = 0; ia < n; ia++) {\np = z[ia][i + 1];\nz[ia][i + 1] = s * z[ia][i] + c * p;\nz[ia][i] = c * z[ia][i] - s * p;\nif (t == 0.0 && i >= j) {\nrealEigenvalues[j] -= u;\ne[j] = q;\ne[m] = 0.0;\n} while (m != j);\nfor (int i = 0; i < n; i++) {\nint k = i;\ndouble p = realEigenvalues[i];\nfor (int j = i + 1; j < n; j++) {\nif (realEigenvalues[j] > p) {\nk = j;\np = realEigenvalues[j];\nif (k != i) {\nrealEigenvalues[k] = realEigenvalues[i];\nrealEigenvalues[i] = p;\nfor (int j = 0; j < n; j++) {\np = z[j][i];\nz[j][i] = z[j][k];\nz[j][k] = p;\nmaxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\nif (maxAbsoluteValue != 0.0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\neigenvectors = new ArrayRealVector[n];\nfinal double[] tmp = new double[n];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[j] = z[j][i];\neigenvectors[i] = new ArrayRealVector(tmp);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:square(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix square(final RealMatrix m) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nd[r][c] = e * e;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDD)Z",
            "method_body": "public static boolean equals(double x, double y, double eps) {\nreturn equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarAdd(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarAdd(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) + d);\nreturn out;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQ()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQ() {\nif (cachedQ == null) {\ncachedQ = getQT().transpose();\nreturn cachedQ;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$Sigma:<init>([D)V",
            "method_body": "public Sigma(double[] s)\nthrows NotPositiveException {\nfor (int i = 0; i < s.length; i++) {\nif (s[i] < 0) {\nsigma = s.clone();\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sqrt(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sqrt(final RealMatrix m) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = Math.sqrt(m.getEntry(r, c));\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:push([DD)V",
            "method_body": "private static void push(double[] vals, double val) {\nfor (int i = vals.length-1; i > 0; i--) {\nvals[i] = vals[i-1];\nvals[0] = val;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumn(I)[D",
            "method_body": "public double[] getColumn(final int column) throws OutOfRangeException {\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal double[] out = new double[nRows];\nfor (int i = 0; i < nRows; ++i) {\nout[i] = getEntry(i, column);\nreturn out;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nfinal double[] hK = householderVectors[k - 1];\nqta[k][k] = 1;\nif (hK[k] != 0.0) {\nfinal double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = 1.0 / secondary[k - 1];\nqta[k][k] = 1 + beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[k][i] = beta * hK[i];\nfor (int j = k + 1; j < m; ++j) {\nbeta = 0;\nfor (int i = k + 1; i < m; ++i) {\nbeta += qta[j][i] * hK[i];\nbeta *= inv;\nqta[j][k] = beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[j][i] += beta * hK[i];\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemB()D",
            "method_body": "double getRemB() {\nreturn finalRemB;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkSubtractionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumnVector(ILorg/apache/commons/math3/linear/RealVector;)V",
            "method_body": "public void setColumnVector(final int column, final RealVector vector)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (vector.getDimension() != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, vector.getEntry(i));\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nparseOptimizationData(optData);\nevaluations.resetCount();\niterations.resetCount();\nreturn doOptimize();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:updateCovariance(ZLorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;[ILorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\ndouble negccov = 0;\nif (ccov1 + ccovmu > 0) {\nfinal RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\nfinal RealMatrix roneu = pc.multiply(pc.transpose())\ndouble oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\noldFac += 1 - ccov1 - ccovmu;\nif (isActiveCMA) {\nnegccov = (1 - ccovmu) * 0.25 * mueff /\nfinal double negminresidualvariance = 0.66;\nfinal double negalphaold = 0.5;\nfinal int[] arReverseIndex = reverse(arindex);\nRealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\nRealMatrix arnorms = sqrt(sumRows(square(arzneg)));\nfinal int[] idxnorms = sortedIndices(arnorms.getRow(0));\nfinal RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\nfinal int[] idxReverse = reverse(idxnorms);\nfinal RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\narnorms = divide(arnormsReverse, arnormsSorted);\nfinal int[] idxInv = inverse(idxnorms);\nfinal RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\nfinal double negcovMax = (1 - negminresidualvariance) /\nif (negccov > negcovMax) {\narzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\nfinal RealMatrix artmp = BD.multiply(arzneg);\nfinal RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\noldFac += negalphaold * negccov;\nC = C.scalarMultiply(oldFac)\n} else {\nupdateBD(negccov);\n}",
            "method_id": 49
        }
    ]
}