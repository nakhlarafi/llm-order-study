{
    "bug_id": 6,
    "test_id": 26,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testDiffPow",
    "test_body": "public void testDiffPow() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new DiffPow(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 10, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testDiffPow(CMAESOptimizerTest.java:288)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DD)V",
            "method_body": "public PointValuePair(final double[] point,\nthis(point, value, true);\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof InitialGuess) {\nstart = ((InitialGuess) data).getInitialGuess();\ncontinue;\nif (data instanceof SimpleBounds) {\nfinal SimpleBounds bounds = (SimpleBounds) data;\nlowerBound = bounds.getLower();\nupperBound = bounds.getUpper();\ncontinue;\ncheckParameters();\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:<init>(I)V",
            "method_body": "public PopulationSize(int size)\nthrows NotStrictlyPositiveException {\nif (size <= 0) {\nlambda = size;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getRow(I)[D",
            "method_body": "public double[] getRow(final int row) throws OutOfRangeException {\nMatrixUtils.checkRowIndex(this, row);\nfinal int nCols = getColumnDimension();\nfinal double[] out = new double[nCols];\nfor (int i = 0; i < nCols; ++i) {\nout[i] = getEntry(row, i);\nreturn out;\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math3/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetricInternal(Lorg/apache/commons/math3/linear/RealMatrix;DZ)Z",
            "method_body": "private static boolean isSymmetricInternal(RealMatrix matrix,\nfinal int rows = matrix.getRowDimension();\nif (rows != matrix.getColumnDimension()) {\nfor (int i = 0; i < rows; i++) {\nfor (int j = i + 1; j < rows; j++) {\nfinal double mij = matrix.getEntry(i, j);\nfinal double mji = matrix.getEntry(j, i);\nif (FastMath.abs(mij - mji) >\nreturn true;\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealDiagonalMatrix([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\nfinal RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\nfor (int i = 0; i < diagonal.length; ++i) {\nm.setEntry(i, i, diagonal[i]);\nreturn m;\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getFrobeniusNorm()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemA()D",
            "method_body": "double getRemA() {\nreturn finalRemA;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:zeros(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix zeros(int n, int m) {\nreturn new Array2DRowRealMatrix(n, m);\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:getPopulationSize()I",
            "method_body": "public int getPopulationSize() {\nreturn lambda;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:next(I)I",
            "method_body": "protected int next(int bits) {\nif (mti >= N) { // generate N words at one time\nint mtNext = mt[0];\nfor (int k = 0; k < N - M; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\nfor (int k = N - M; k < N - 1; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\ny = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\nmt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\nmti = 0;\ny = mt[mti++];\ny ^=  y >>> 11;\ny ^= (y <<   7) & 0x9d2c5680;\ny ^= (y <<  15) & 0xefc60000;\ny ^=  y >>> 18;\nreturn y >>> (32 - bits);\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:<init>(DI)V",
            "method_body": "DoubleIndex(double value, int index) {\nthis.value = value;\nthis.index = index;\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(I)V",
            "method_body": "public void setSeed(int seed) {\nlong longMT = seed;\nmt[0]= (int) longMT;\nfor (mti = 1; mti < N; ++mti) {\nlongMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\nmt[mti]= (int) longMT;\nclear(); // Clear normal deviate cache\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer;)V",
            "method_body": "public FitnessFunction() {\nvalueRange = 1;\nisRepairMode = true;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:randn1(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix randn1(int size, int popSize) {\nfinal double[][] d = new double[size][popSize];\nfor (int r = 0; r < size; r++) {\nfor (int c = 0; c < popSize; c++) {\nd[r][c] = random.nextGaussian();\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\nout.setEntry(row, col, sum);\nreturn out;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof Sigma) {\ninputSigma = ((Sigma) data).getSigma();\ncontinue;\nif (data instanceof PopulationSize) {\nlambda = ((PopulationSize) data).getPopulationSize();\ncontinue;\ncheckParameters();\n}",
            "method_id": 174
        }
    ]
}