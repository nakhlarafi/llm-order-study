{
    "bug_id": 6,
    "test_id": 3,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSphere",
    "test_body": "public void testSphere() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new Sphere(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSphere(CMAESOptimizerTest.java:258)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:<init>([D[D)V",
            "method_body": "public SimpleBounds(double[] lB,\ndouble[] uB) {\nlower = lB.clone();\nupper = uB.clone();\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nparseOptimizationData(optData);\nevaluations.resetCount();\niterations.resetCount();\nreturn doOptimize();\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getV()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getV() {\nif (cachedV == null) {\nfinal int m = eigenvectors.length;\ncachedV = MatrixUtils.createRealMatrix(m, m);\nfor (int k = 0; k < m; ++k) {\ncachedV.setColumnVector(k, eigenvectors[k]);\nreturn cachedV;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:randn1(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix randn1(int size, int popSize) {\nfinal double[][] d = new double[size][popSize];\nfor (int r = 0; r < size; r++) {\nfor (int c = 0; c < popSize; c++) {\nd[r][c] = random.nextGaussian();\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:selectColumns(Lorg/apache/commons/math3/linear/RealMatrix;[I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\nfinal double[][] d = new double[m.getRowDimension()][cols.length];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < cols.length; c++) {\nd[r][c] = m.getEntry(r, cols[c]);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getFrobeniusNorm()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(J)V",
            "method_body": "public void setSeed(long seed) {\nsetSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:getUpper()[D",
            "method_body": "public double[] getUpper() {\nreturn upper.clone();\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:<init>(D)V",
            "method_body": "CodyWaite(double xa) {\nint k = (int)(xa * 0.6366197723675814);\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\nif (remA > 0) {\nbreak;\nthis.finalK = k;\nthis.finalRemA = remA;\nthis.finalRemB = remB;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:value([D)D",
            "method_body": "public double value(final double[] point) {\nif (isRepairMode) {\ndouble[] repaired = repair(point);\nvalue = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n} else {\nreturn isMinimize ? value : -value;\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumnMatrix(I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getColumnMatrix(final int column)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal RealMatrix out = createMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nout.setEntry(i, 0, getEntry(i, column));\nreturn out;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:findEigenVectors([[D)V",
            "method_body": "private void findEigenVectors(final double[][] householderMatrix) {\nfinal double[][]z = householderMatrix.clone();\nfinal int n = main.length;\nrealEigenvalues = new double[n];\nimagEigenvalues = new double[n];\nfinal double[] e = new double[n];\nfor (int i = 0; i < n - 1; i++) {\nrealEigenvalues[i] = main[i];\ne[i] = secondary[i];\nrealEigenvalues[n - 1] = main[n - 1];\ne[n - 1] = 0;\ndouble maxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\nif (FastMath.abs(e[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(e[i]);\nif (maxAbsoluteValue != 0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\nif (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\ne[i]=0;\nfor (int j = 0; j < n; j++) {\nint its = 0;\nfor (m = j; m < n - 1; m++) {\ndouble delta = FastMath.abs(realEigenvalues[m]) +\nif (FastMath.abs(e[m]) + delta == delta) {\nbreak;\nif (m != j) {\nif (its == maxIter) {\nits++;\ndouble q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\ndouble t = FastMath.sqrt(1 + q * q);\nif (q < 0.0) {\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\ndouble u = 0.0;\ndouble s = 1.0;\ndouble c = 1.0;\nfor (i = m - 1; i >= j; i--) {\ndouble p = s * e[i];\ndouble h = c * e[i];\nif (FastMath.abs(p) >= FastMath.abs(q)) {\nc = q / p;\nt = FastMath.sqrt(c * c + 1.0);\ne[i + 1] = p * t;\ns = 1.0 / t;\nc = c * s;\ns = p / q;\nt = FastMath.sqrt(s * s + 1.0);\ne[i + 1] = q * t;\nc = 1.0 / t;\ns = s * c;\nif (e[i + 1] == 0.0) {\nq = realEigenvalues[i + 1] - u;\nt = (realEigenvalues[i] - q) * s + 2.0 * c * h;\nu = s * t;\nrealEigenvalues[i + 1] = q + u;\nq = c * t - h;\nfor (int ia = 0; ia < n; ia++) {\np = z[ia][i + 1];\nz[ia][i + 1] = s * z[ia][i] + c * p;\nz[ia][i] = c * z[ia][i] - s * p;\nif (t == 0.0 && i >= j) {\nrealEigenvalues[j] -= u;\ne[j] = q;\ne[m] = 0.0;\n} while (m != j);\nfor (int i = 0; i < n; i++) {\nint k = i;\ndouble p = realEigenvalues[i];\nfor (int j = i + 1; j < n; j++) {\nif (realEigenvalues[j] > p) {\nk = j;\np = realEigenvalues[j];\nif (k != i) {\nrealEigenvalues[k] = realEigenvalues[i];\nrealEigenvalues[i] = p;\nfor (int j = 0; j < n; j++) {\np = z[j][i];\nz[j][i] = z[j][k];\nz[j][k] = p;\nmaxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\nif (maxAbsoluteValue != 0.0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\neigenvectors = new ArrayRealVector[n];\nfinal double[] tmp = new double[n];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[j] = z[j][i];\neigenvectors[i] = new ArrayRealVector(tmp);\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:nextGaussian()D",
            "method_body": "public double nextGaussian() {\nif (Double.isNaN(nextGaussian)) {\nfinal double x = nextDouble();\nfinal double y = nextDouble();\nfinal double alpha = 2 * FastMath.PI * x;\nfinal double r      = FastMath.sqrt(-2 * FastMath.log(y));\nrandom       = r * FastMath.cos(alpha);\nnextGaussian = r * FastMath.sin(alpha);\n} else {\nrandom = nextGaussian;\nnextGaussian = Double.NaN;\nreturn random;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:<init>(DI)V",
            "method_body": "DoubleIndex(double value, int index) {\nthis.value = value;\nthis.index = index;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 174
        }
    ]
}