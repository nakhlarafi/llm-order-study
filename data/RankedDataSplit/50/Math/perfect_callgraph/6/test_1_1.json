{
    "bug_id": 6,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column)\nif (column < 0 || column >= m.getColumnDimension()) {\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn data.length;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:<init>([D)V",
            "method_body": "public DiagonalMatrix(final double[] d) {\nthis(d, true);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qrDecomposition(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\nweightedJacobian = jacobian.scalarMultiply(-1).getData();\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\nfor (int k = 0; k < nC; ++k) {\npermutation[k] = k;\ndouble norm2 = 0;\nfor (int i = 0; i < nR; ++i) {\ndouble akk = weightedJacobian[i][k];\nnorm2 += akk * akk;\njacNorm[k] = FastMath.sqrt(norm2);\nfor (int k = 0; k < nC; ++k) {\nint nextColumn = -1;\ndouble ak2 = Double.NEGATIVE_INFINITY;\nfor (int i = k; i < nC; ++i) {\ndouble norm2 = 0;\nfor (int j = k; j < nR; ++j) {\ndouble aki = weightedJacobian[j][permutation[i]];\nnorm2 += aki * aki;\nif (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\nif (norm2 > ak2) {\nnextColumn = i;\nak2        = norm2;\nif (ak2 <= qrRankingThreshold) {\nint pk                  = permutation[nextColumn];\npermutation[nextColumn] = permutation[k];\npermutation[k]          = pk;\ndouble akk   = weightedJacobian[k][pk];\ndouble alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\ndouble betak = 1.0 / (ak2 - akk * alpha);\nbeta[pk]     = betak;\ndiagR[pk]        = alpha;\nweightedJacobian[k][pk] -= alpha;\nfor (int dk = nC - 1 - k; dk > 0; --dk) {\nrank = solvedCols;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction:<init>(Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;)V",
            "method_body": "public ModelFunction(MultivariateVectorFunction m) {\nmodel = m;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\nreturn super.optimize(optData);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn row == column ? data[row] : 0;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:getWeightSquareRoot()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeightSquareRoot() {\nreturn weightMatrixSqrt.copy();\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight:<init>([D)V",
            "method_body": "public Weight(double[] weight) {\nweightMatrix = new DiagonalMatrix(weight);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nmaxEval = max;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:checkVectorDimensions(I)V",
            "method_body": "protected void checkVectorDimensions(int n)\nif (data.length != n) {\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:computeObjectiveValue([D)[D",
            "method_body": "protected double[] computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn model.value(params);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDataRef()[D",
            "method_body": "public double[] getDataRef() {\nreturn data;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof ModelFunctionJacobian) {\njacobian = ((ModelFunctionJacobian) data).getModelFunctionJacobian();\nbreak;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Target:getTarget()[D",
            "method_body": "public double[] getTarget() {\nreturn target.clone();\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getDataRef()[D",
            "method_body": "public double[] getDataRef() {\nreturn data;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:getWeight()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeight() {\nreturn weightMatrix.copy();\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data)\nif (data == null ||\nreturn (data.length * data[0].length <= 4096) ?\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:operate(Lorg/apache/commons/math3/linear/RealVector;)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector operate(final RealVector v)\nreturn new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn data.length;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:squareRoot(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix squareRoot(RealMatrix m) {\nif (m instanceof DiagonalMatrix) {\nfinal int dim = m.getRowDimension();\nfinal RealMatrix sqrtM = new DiagonalMatrix(dim);\nfor (int i = 0; i < dim; i++) {\nsqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\nreturn sqrtM;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian:getModelFunctionJacobian()Lorg/apache/commons/math3/analysis/MultivariateMatrixFunction;",
            "method_body": "public MultivariateMatrixFunction getModelFunctionJacobian() {\nreturn jacobian;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math3/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeResiduals([D)[D",
            "method_body": "protected double[] computeResiduals(double[] objectiveValue) {\nfinal double[] target = getTarget();\nif (objectiveValue.length != target.length) {\nfinal double[] residuals = new double[target.length];\nfor (int i = 0; i < target.length; i++) {\nresiduals[i] = target[i] - objectiveValue[i];\nreturn residuals;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nparseOptimizationData(optData);\nevaluations.resetCount();\niterations.resetCount();\nreturn doOptimize();\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[DZ)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nsuper(copyArray ?\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarMultiply(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarMultiply(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) * d);\nreturn out;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nif (m instanceof DiagonalMatrix) {\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = m.getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal double[][] product = new double[nRows][nCols];\nfor (int r = 0; r < nRows; r++) {\nfor (int c = 0; c < nCols; c++) {\nproduct[r][c] = data[r] * m.getEntry(r, c);\nreturn new Array2DRowRealMatrix(product, false);\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:multiply(Lorg/apache/commons/math3/linear/DiagonalMatrix;)Lorg/apache/commons/math3/linear/DiagonalMatrix;",
            "method_body": "public DiagonalMatrix multiply(final DiagonalMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int dim = getRowDimension();\nfinal double[] outData = new double[dim];\nfor (int i = 0; i < dim; i++) {\noutData[i] = data[i] * m.data[i];\nreturn new DiagonalMatrix(outData, false);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMParameter([DD[D[D[D[D)V",
            "method_body": "private void determineLMParameter(double[] qy, double delta, double[] diag,\nfinal int nC = weightedJacobian[0].length;\nfor (int j = 0; j < rank; ++j) {\nlmDir[permutation[j]] = qy[j];\nfor (int j = rank; j < nC; ++j) {\nfor (int k = rank - 1; k >= 0; --k) {\nint pk = permutation[k];\ndouble ypk = lmDir[pk] / diagR[pk];\nfor (int i = 0; i < k; ++i) {\nlmDir[pk] = ypk;\ndouble dxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork1[pj] = s;\ndxNorm += s * s;\ndxNorm = FastMath.sqrt(dxNorm);\ndouble fp = dxNorm - delta;\nif (fp <= 0.1 * delta) {\nlmPar = 0;\nreturn;\ndouble parl = 0;\nif (rank == solvedCols) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] *= diag[pj] / dxNorm;\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i < j; ++i) {\ndouble s = (work1[pj] - sum) / diagR[pj];\nwork1[pj] = s;\nsum2 += s * s;\nparl = fp / (delta * sum2);\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qy[i];\nsum /= diag[pj];\nsum2 += sum * sum;\ndouble gNorm = FastMath.sqrt(sum2);\ndouble paru = gNorm / delta;\nif (paru == 0) {\nlmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\nif (lmPar == 0) {\nfor (int countdown = 10; countdown >= 0; --countdown) {\nif (lmPar == 0) {\ndouble sPar = FastMath.sqrt(lmPar);\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = sPar * diag[pj];\ndetermineLMDirection(qy, work1, work2, work3);\ndxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork3[pj] = s;\ndxNorm += s * s;\ndxNorm = FastMath.sqrt(dxNorm);\ndouble previousFP = fp;\nfp = dxNorm - delta;\nif ((FastMath.abs(fp) <= 0.1 * delta) ||\nreturn;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = work3[pj] * diag[pj] / dxNorm;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] /= work2[j];\ndouble tmp = work1[pj];\nfor (int i = j + 1; i < solvedCols; ++i) {\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ndouble s = work1[permutation[j]];\nsum2 += s * s;\ndouble correction = fp / (delta * sum2);\nif (fp > 0) {\n} else if (fp < 0) {\nparu = FastMath.min(paru, lmPar);\nlmPar = FastMath.max(parl, lmPar + correction);\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMDirection([D[D[D[D)V",
            "method_body": "private void determineLMDirection(double[] qy, double[] diag,\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nfor (int i = j + 1; i < solvedCols; ++i) {\nlmDir[j] = diagR[pj];\nwork[j]  = qy[j];\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dpj = diag[pj];\nif (dpj != 0) {\nArrays.fill(lmDiag, j + 1, lmDiag.length, 0);\nlmDiag[j] = dpj;\ndouble qtbpj = 0;\nfor (int k = j; k < solvedCols; ++k) {\nint pk = permutation[k];\nif (lmDiag[k] != 0) {\ndouble rkk = weightedJacobian[k][pk];\nif (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\nfinal double cotan = rkk / lmDiag[k];\nsin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\ncos   = sin * cotan;\n} else {\nweightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\nfinal double temp = cos * work[k] + sin * qtbpj;\nqtbpj = -sin * work[k] + cos * qtbpj;\nwork[k] = temp;\nfor (int i = k + 1; i < solvedCols; ++i) {\nlmDiag[j] = weightedJacobian[j][permutation[j]];\nweightedJacobian[j][permutation[j]] = lmDir[j];\nint nSing = solvedCols;\nfor (int j = 0; j < solvedCols; ++j) {\nif ((lmDiag[j] == 0) && (nSing == solvedCols)) {\nif (nSing < solvedCols) {\nif (nSing > 0) {\nfor (int j = nSing - 1; j >= 0; --j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = j + 1; i < nSing; ++i) {\nwork[j] = (work[j] - sum) / lmDiag[j];\nfor (int j = 0; j < lmDir.length; ++j) {\nlmDir[permutation[j]] = work[j];\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>()V",
            "method_body": "public LevenbergMarquardtOptimizer() {\nthis(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math3/linear/RealVector;)D",
            "method_body": "public double dotProduct(RealVector v) throws DimensionMismatchException {\nif (v instanceof ArrayRealVector) {\nfinal double[] vData = ((ArrayRealVector) v).data;\ncheckVectorDimensions(vData.length);\ndouble dot = 0;\nfor (int i = 0; i < data.length; i++) {\ndot += data[i] * vData[i];\nreturn dot;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:operate([D)[D",
            "method_body": "public double[] operate(final double[] v)\nreturn multiply(new DiagonalMatrix(v, false)).getDataRef();\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:computeJacobian([D)[[D",
            "method_body": "protected double[][] computeJacobian(final double[] params) {\nreturn jacobian.value(params);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 99
        }
    ]
}