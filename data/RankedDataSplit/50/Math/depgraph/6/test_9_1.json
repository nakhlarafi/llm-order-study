{
    "bug_id": 6,
    "test_id": 9,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest.testMaximize2",
    "test_body": "112: public void testMaximize2() {\n113: SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\n114: final FourExtrema fourExtrema = new FourExtrema();\n115: 116: final PointValuePair optimum\n117: = optimizer.optimize(new MaxEval(200),\n118: new ObjectiveFunction(fourExtrema),\n119: GoalType.MAXIMIZE,\n120: new InitialGuess(new double[] { 1, 0 }),\n121: new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n122: Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n123: Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n124: Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\n125: Assert.assertTrue(optimizer.getEvaluations() > 180);\n126: Assert.assertTrue(optimizer.getEvaluations() < 220);\n127: 128: // Check that the number of iterations is updated (MATH-949).\n129: Assert.assertTrue(optimizer.getIterations() > 0);\n130: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest.testMaximize2(SimplexOptimizerMultiDirectionalTest.java:129)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex:evaluateNewSimplex(Lorg/apache/commons/math3/analysis/MultivariateFunction;[Lorg/apache/commons/math3/optim/PointValuePair;DLjava/util/Comparator;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "private PointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\nfinal double[] xSmallest = original[0].getPointRef();\nsetPoint(0, original[0]);\nfinal int dim = getDimension();\nfor (int i = 1; i < getSize(); i++) {\nfinal double[] xOriginal = original[i].getPointRef();\nfinal double[] xTransformed = new double[dim];\nfor (int j = 0; j < dim; j++) {\nxTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\nsetPoint(i, new PointValuePair(xTransformed, Double.NaN, false));\nevaluate(evaluationFunction, comparator);\nreturn getPoint(0);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPointRef()[D",
            "method_body": "public double[] getPointRef() {\nreturn getKey();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:converged(ILorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)Z",
            "method_body": "public boolean converged(final int iteration,\nif (maxIterationCount != ITERATION_CHECK_DISABLED) {\nfinal double p = previous.getValue();\nfinal double c = current.getValue();\nfinal double difference = FastMath.abs(p - c);\nfinal double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\nreturn difference <= size * getRelativeThreshold() ||\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(D)D",
            "method_body": "public static double atan(double x) {\nreturn atan(x, 0.0, false);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getAbsoluteThreshold()D",
            "method_body": "public double getAbsoluteThreshold() {\nreturn absoluteThreshold;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getRelativeThreshold()D",
            "method_body": "public double getRelativeThreshold() {\nreturn relativeThreshold;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:setPoint(ILorg/apache/commons/math3/optim/PointValuePair;)V",
            "method_body": "protected void setPoint(int index, PointValuePair point) {\nif (index < 0 ||\nsimplex[index] = point;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:<init>(DD)V",
            "method_body": "public AbstractConvergenceChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nthis.relativeThreshold = relativeThreshold;\nthis.absoluteThreshold = absoluteThreshold;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nreturn Double.NaN;\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(DDZ)D",
            "method_body": "private static double atan(double xa, double xb, boolean leftPlane) {\nboolean negate = false;\nif (xa == 0.0) { // Matches +/- 0.0; return correct sign\nif (xa < 0) {\nxa = -xa;\nxb = -xb;\nnegate = true;\nif (xa > 1.633123935319537E16) { // Very large input\nif (xa < 1) {\nidx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\nfinal double oneOverXa = 1 / xa;\nidx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\ndouble epsA = xa - TANGENT_TABLE_A[idx];\ndouble epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\nepsB += xb - TANGENT_TABLE_B[idx];\ndouble temp = epsA + epsB;\nepsB = -(temp - epsA - epsB);\nepsA = temp;\ntemp = xa * HEX_40000000;\ndouble ya = xa + temp - temp;\ndouble yb = xb + xa - ya;\nxa = ya;\nxb += yb;\nif (idx == 0) {\nfinal double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\nya = epsA * denom;\nyb = epsB * denom;\n} else {\ndouble temp2 = xa * TANGENT_TABLE_A[idx];\ndouble za = 1d + temp2;\ndouble zb = -(za - 1d - temp2);\ntemp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\ntemp = za + temp2;\nzb += -(temp - za - temp2);\nza = temp;\nzb += xb * TANGENT_TABLE_B[idx];\nya = epsA / za;\ntemp = ya * HEX_40000000;\nfinal double yaa = (ya + temp) - temp;\nfinal double yab = ya - yaa;\ntemp = za * HEX_40000000;\nfinal double zaa = (za + temp) - temp;\nfinal double zab = za - zaa;\nyb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\nyb += -epsA * zb / za / za;\nyb += epsB / za;\nepsA = ya;\nepsB = yb;\nfinal double epsA2 = epsA * epsA;\nyb = 0.07490822288864472;\nyb = yb * epsA2 + -0.09088450866185192;\nyb = yb * epsA2 + 0.11111095942313305;\nyb = yb * epsA2 + -0.1428571423679182;\nyb = yb * epsA2 + 0.19999999999923582;\nyb = yb * epsA2 + -0.33333333333333287;\nyb = yb * epsA2 * epsA;\nya = epsA;\ntemp = ya + yb;\nyb = -(temp - ya - yb);\nya = temp;\nyb += epsB / (1d + epsA * epsA);\ndouble za = EIGHTHS[idx] + ya;\ndouble zb = -(za - EIGHTHS[idx] - ya);\ntemp = za + yb;\nzb += -(temp - za - yb);\nza = temp;\ndouble result = za + zb;\ndouble resultb = -(result - za - zb);\nif (leftPlane) {\nif (negate ^ leftPlane) {\nresult = -result;\nreturn result;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 64
        }
    ]
}