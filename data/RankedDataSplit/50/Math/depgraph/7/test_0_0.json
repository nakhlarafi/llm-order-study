{
    "bug_id": 7,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling",
    "test_body": "337: public void testEventsScheduling() {\n338: 339: FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n340: 341: public int getDimension() {\n342: return 2;\n343: }\n344: 345: public void computeDerivatives(double t, double[] y, double[] yDot) {\n346: yDot[0] =  y[1];\n347: yDot[1] = -y[0];\n348: }\n349: 350: };\n351: 352: SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n353: SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n354: 355: FirstOrderIntegrator integ =\n356: new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n357: integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n358: integ.addStepHandler(sinChecker);\n359: integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n360: integ.addStepHandler(cosChecker);\n361: double   t0 = 0.5;\n362: double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n363: double   t  = 10.0;\n364: double[] y  = new double[2];\n365: integ.integrate(sincos, t0, y0, t, y);\n366: 367: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest$SchedulingChecker.g(DormandPrince853IntegratorTest.java:389)\nat org.apache.commons.math3.ode.events.EventState.evaluateStep(EventState.java:224)\nat org.apache.commons.math3.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:323)\nat org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:303)\nat org.apache.commons.math3.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:228)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling(DormandPrince853IntegratorTest.java:365)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:acceptStep(Lorg/apache/commons/math3/ode/sampling/AbstractStepInterpolator;[D[DD)D",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\nstatesInitialized = true;\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\noccuringEvents.add(state);\nwhile (!occuringEvents.isEmpty()) {\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState().clone();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\nfor (final StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\nif (isLastStep) {\nboolean needReset = currentEvent.reset(eventT, eventY);\nif (needReset) {\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nfor (final EventState remaining : occuringEvents) {\nreturn eventT;\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\nreturn currentT;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\ndouble a = 0;\ndouble b = 0;\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nb = b + sintA * cosEpsB + costA * sinEpsB;\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nresult = a + b;\nreturn result;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nif (negative) {\nswitch (quadrant) {\nreturn sinQ(xa, xb);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\ndouble xa = x;\nif (x < 0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\ndouble xb = 0;\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nswitch (quadrant) {\nreturn cosQ(xa, xb);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\nreturn sinQ(a, b);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\ndouble x2 = x*x;\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\np = p * x2 * x;\nreturn p;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:integrate(Lorg/apache/commons/math3/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nif (y0.length != equations.getDimension()) {\nif (y.length != equations.getDimension()) {\nfinal ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\nexpandableODE.setTime(t0);\nexpandableODE.setPrimaryState(y0);\nintegrate(expandableODE, t);\nSystem.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\nreturn expandableODE.getTime();\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:sanityChecks(Lorg/apache/commons/math3/ode/ExpandableStatefulODE;D)V",
            "method_body": "protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\nfinal double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\nfinal double dt = FastMath.abs(equations.getTime() - t);\nif (dt <= threshold) {\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsStates = new ArrayList<EventState>();\nstatesInitialized = false;\nevaluations = new Incrementor();\nsetMaxEvaluations(-1);\nevaluations.resetCount();\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public abstract void integrate(ExpandableStatefulODE equations, double t)\nevaluations.incrementCount();\nexpandable.computeDerivatives(t, y, yDot);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nevaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math3/ode/ExpandableStatefulODE;)V",
            "method_body": "protected void setEquations(final ExpandableStatefulODE equations) {\nthis.expandable = equations;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:setStateInitialized(Z)V",
            "method_body": "protected void setStateInitialized(final boolean stateInitialized) {\nthis.statesInitialized = stateInitialized;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:addStepHandler(Lorg/apache/commons/math3/ode/sampling/StepHandler;)V",
            "method_body": "public void addStepHandler(final StepHandler handler) {\nstepHandlers.add(handler);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:initIntegration(D[DD)V",
            "method_body": "protected void initIntegration(final double t0, final double[] y0, final double t) {\nevaluations.resetCount();\nfor (final EventState state : eventsStates) {\nstate.getEventHandler().init(t0, y0, t);\nfor (StepHandler handler : stepHandlers) {\nhandler.init(t0, y0, t);\nsetStateInitialized(false);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math3/ode/events/EventHandler;DDILorg/apache/commons/math3/analysis/solvers/UnivariateSolver;)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\neventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math3/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\naddEventHandler(handler, maxCheckInterval, convergence,\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y) {\nif (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\nif (nextAction == EventHandler.Action.RESET_STATE) {\nhandler.resetState(t, y);\npendingEvent      = false;\npendingEventTime  = Double.NaN;\nreturn (nextAction == EventHandler.Action.RESET_STATE) ||\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:setSoftPreviousTime(D)V",
            "method_body": "public void setSoftPreviousTime(final double softPreviousTime) {\nthis.softPreviousTime = softPreviousTime;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEvent ?\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateFunction f = new UnivariateFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateSolver<?>) {\nBracketedUnivariateSolver<UnivariateFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDLorg/apache/commons/math3/analysis/solvers/AllowedSolution;)D",
            "method_body": "public double solve(int maxEval, UnivariateFunction f, double min,\nthis.allowed = allowedSolution;\nreturn super.solve(maxEval, f, min, max);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:getEventHandler()Lorg/apache/commons/math3/ode/events/EventHandler;",
            "method_body": "public EventHandler getEventHandler() {\nreturn handler;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:stop()Z",
            "method_body": "public boolean stop() {\nreturn nextAction == EventHandler.Action.STOP;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:<init>(Lorg/apache/commons/math3/ode/events/EventHandler;DDILorg/apache/commons/math3/analysis/solvers/UnivariateSolver;)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal UnivariateSolver solver) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = FastMath.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\nthis.solver            = solver;\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.Action.CONTINUE;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:reinitializeBegin(Lorg/apache/commons/math3/ode/sampling/StepInterpolator;)V",
            "method_body": "public void reinitializeBegin(final StepInterpolator interpolator)\nt0 = interpolator.getPreviousTime();\ninterpolator.setInterpolatedTime(t0);\ng0 = handler.g(t0, interpolator.getInterpolatedState());\nif (g0 == 0) {\ng0Positive = g0 >= 0;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:evaluateStep(Lorg/apache/commons/math3/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateFunction f = new UnivariateFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateSolver<?>) {\nBracketedUnivariateSolver<UnivariateFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y) {\nt0 = t;\ng0 = handler.g(t, y);\nif (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\ng0Positive = g0 >= 0;\nnextAction = EventHandler.Action.CONTINUE;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:guessX(D[D[DII)D",
            "method_body": "private double guessX(final double targetY, final double[] x, final double[] y,\nfor (int i = start; i < end - 1; ++i) {\nfinal int delta = i + 1 - start;\nfor (int j = end - 1; j > i; --j) {\nx[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\ndouble x0 = 0;\nfor (int j = end - 1; j >= start; --j) {\nx0 = x[j] + x0 * (targetY - y[j]);\nreturn x0;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta,\nif (! vectorsInitialized) {\nif (v == null) {\nfinalizeStep();\nfor (int i = 0; i < interpolatedState.length; ++i) {\nfinal double yDot1  = yDotK[0][i];\nfinal double yDot6  = yDotK[5][i];\nfinal double yDot7  = yDotK[6][i];\nfinal double yDot8  = yDotK[7][i];\nfinal double yDot9  = yDotK[8][i];\nfinal double yDot10 = yDotK[9][i];\nfinal double yDot11 = yDotK[10][i];\nfinal double yDot12 = yDotK[11][i];\nfinal double yDot13 = yDotK[12][i];\nfinal double yDot14 = yDotKLast[0][i];\nfinal double yDot15 = yDotKLast[1][i];\nfinal double yDot16 = yDotKLast[2][i];\nv[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\nv[1][i] = yDot1 - v[0][i];\nv[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\nfor (int k = 0; k < D.length; ++k) {\nv[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\nvectorsInitialized = true;\nfinal double eta      = 1 - theta;\nfinal double twoTheta = 2 * theta;\nfinal double theta2   = theta * theta;\nfinal double dot1 = 1 - twoTheta;\nfinal double dot2 = theta * (2 - 3 * theta);\nfinal double dot3 = twoTheta * (1 + theta * (twoTheta -3));\nfinal double dot4 = theta2 * (3 + theta * (5 * theta - 8));\nfinal double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\nfinal double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\nif ((previousState != null) && (theta <= 0.5)) {\nfor (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = previousState[i] +\ninterpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\nfor (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = currentState[i] -\ninterpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:<init>(DI)V",
            "method_body": "public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\nsuper(absoluteAccuracy);\nif (maximalOrder < 2) {\nthis.maximalOrder = maximalOrder;\nthis.allowed = AllowedSolution.ANY_SIDE;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:doSolve()D",
            "method_body": "protected double doSolve()\nfinal double[] x = new double[maximalOrder + 1];\nfinal double[] y = new double[maximalOrder + 1];\nx[0] = getMin();\nx[1] = getStartValue();\nx[2] = getMax();\nverifySequence(x[0], x[1], x[2]);\ny[1] = computeObjectiveValue(x[1]);\nif (Precision.equals(y[1], 0.0, 1)) {\ny[0] = computeObjectiveValue(x[0]);\nif (Precision.equals(y[0], 0.0, 1)) {\nif (y[0] * y[1] < 0) {\ny[2] = computeObjectiveValue(x[2]);\nif (Precision.equals(y[2], 0.0, 1)) {\nif (y[1] * y[2] < 0) {\nnbPoints        = 3;\nsignChangeIndex = 2;\nfinal double[] tmpX = new double[x.length];\ndouble xA    = x[signChangeIndex - 1];\ndouble yA    = y[signChangeIndex - 1];\ndouble absYA = FastMath.abs(yA);\nint agingA   = 0;\ndouble xB    = x[signChangeIndex];\ndouble yB    = y[signChangeIndex];\ndouble absYB = FastMath.abs(yB);\nint agingB   = 0;\nfinal double xTol = getAbsoluteAccuracy() +\nif (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\nswitch (allowed) {\nreturn xB;\nif (agingA >= MAXIMAL_AGING) {\nfinal int p = agingA - MAXIMAL_AGING;\nfinal double weightA = (1 << p) - 1;\nfinal double weightB = p + 1;\ntargetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n} else if (agingB >= MAXIMAL_AGING) {\ntargetY = 0;\nint start = 0;\nint end   = nbPoints;\nSystem.arraycopy(x, start, tmpX, start, end - start);\nnextX = guessX(targetY, tmpX, y, start, end);\nif (!((nextX > xA) && (nextX < xB))) {\n} while (Double.isNaN(nextX) && (end - start > 1));\nif (Double.isNaN(nextX)) {\nfinal double nextY = computeObjectiveValue(nextX);\nif (Precision.equals(nextY, 0.0, 1)) {\nif ((nbPoints > 2) && (end - start != nbPoints)) {\n} else  if (nbPoints == x.length) {\nSystem.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\nx[signChangeIndex] = nextX;\nSystem.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\ny[signChangeIndex] = nextY;\n++nbPoints;\nif (nextY * yA <= 0) {\nxB = nextX;\nyB = nextY;\nabsYB = FastMath.abs(yB);\n++agingA;\nagingB = 0;\nxA = nextX;\nyA = nextY;\nabsYA = FastMath.abs(yA);\nagingA = 0;\n++agingB;\nsignChangeIndex++;\n}\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator:estimateError([[D[D[DD)D",
            "method_body": "protected double estimateError(final double[][] yDotK,\ndouble error1 = 0;\ndouble error2 = 0;\nfor (int j = 0; j < mainSetDimension; ++j) {\nfinal double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\nfinal double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\nfinal double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\nfinal double ratio1  = errSum1 / tol;\nerror1        += ratio1 * ratio1;\nfinal double ratio2  = errSum2 / tol;\nerror2        += ratio2 * ratio2;\ndouble den = error1 + 0.01 * error2;\nif (den <= 0.0) {\nreturn FastMath.abs(h) * error1 / FastMath.sqrt(mainSetDimension * den);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:<init>(Lorg/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator;)V",
            "method_body": "public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\nsuper(interpolator);\nif (interpolator.currentState == null) {\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math3/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:reinitialize(Lorg/apache/commons/math3/ode/AbstractIntegrator;[D[[DZLorg/apache/commons/math3/ode/EquationsMapper;[Lorg/apache/commons/math3/ode/EquationsMapper;)V",
            "method_body": "public void reinitialize(final AbstractIntegrator integrator,\nsuper.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\nfinal int dimension = currentState.length;\nyDotKLast = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k]  = new double[dimension];\nvectorsInitialized = false;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\nsuper.storeTime(t);\nvectorsInitialized = false;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize() throws MaxCountExceededException {\nif (currentState == null) {\nreturn;\nfinal double[] yTmp = new double[currentState.length];\nfinal double pT = getGlobalPreviousTime();\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator:getOrder()I",
            "method_body": "public int getOrder() {\nreturn 8;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:<init>(Ljava/lang/String;Z[D[[D[DLorg/apache/commons/math3/ode/nonstiff/RungeKuttaStepInterpolator;DDDD)V",
            "method_body": "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nthis.fsal      = fsal;\nthis.c         = c;\nthis.a         = a;\nthis.b         = b;\nthis.prototype = prototype;\nexp = -1.0 / getOrder();\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(10.0);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math3/ode/ExpandableStatefulODE;D)V",
            "method_body": "public void integrate(final ExpandableStatefulODE equations, final double t)\nsanityChecks(equations, t);\nsetEquations(equations);\nfinal boolean forward = t > equations.getTime();\nfinal double[] y0  = equations.getCompleteState();\nfinal double[] y = y0.clone();\nfinal int stages = c.length + 1;\nfinal double[][] yDotK = new double[stages][y.length];\nfinal double[] yTmp    = y0.clone();\nfinal double[] yDotTmp = new double[y.length];\nfinal RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\ninterpolator.reinitialize(this, yTmp, yDotK, forward,\ninterpolator.storeTime(equations.getTime());\nstepStart         = equations.getTime();\ndouble  hNew      = 0;\nboolean firstTime = true;\ninitIntegration(equations.getTime(), y0, t);\nisLastStep = false;\ninterpolator.shift();\ndouble error = 10;\nwhile (error >= 1.0) {\nif (firstTime || !fsal) {\ncomputeDerivatives(stepStart, y, yDotK[0]);\nif (firstTime) {\nfinal double[] scale = new double[mainSetDimension];\nif (vecAbsoluteTolerance == null) {\nfor (int i = 0; i < scale.length; ++i) {\nscale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\nhNew = initializeStep(forward, getOrder(), scale,\nfirstTime = false;\nstepSize = hNew;\nif (forward) {\nif (stepStart + stepSize >= t) {\nfor (int k = 1; k < stages; ++k) {\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error >= 1.0) {\ninterpolator.storeTime(stepStart + stepSize);\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nSystem.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\nstepStart = acceptStep(interpolator, y, yDotTmp, t);\nSystem.arraycopy(y, 0, yTmp, 0, y.length);\nif (!isLastStep) {\ninterpolator.storeTime(stepStart);\nif (fsal) {\nSystem.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\nfinal double factor =\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\nfinal double  filteredNextT      = stepStart + hNew;\nfinal boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\nif (filteredNextIsLast) {\n} while (!isLastStep);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator:<init>(Ljava/lang/String;DDDD)V",
            "method_body": "public AdaptiveStepsizeIntegrator(final String name,\nsuper(name);\nsetStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nresetInternalState();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator:setStepSizeControl(DDDD)V",
            "method_body": "public void setStepSizeControl(final double minimalStep, final double maximalStep,\nminStep     = FastMath.abs(minimalStep);\nmaxStep     = FastMath.abs(maximalStep);\ninitialStep = -1;\nscalAbsoluteTolerance = absoluteTolerance;\nscalRelativeTolerance = relativeTolerance;\nvecAbsoluteTolerance  = null;\nvecRelativeTolerance  = null;\n}",
            "method_id": 49
        }
    ]
}