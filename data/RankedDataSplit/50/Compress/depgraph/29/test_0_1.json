{
    "bug_id": 29,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStream",
    "test_body": "307: public void testEncodingInputStream() throws Exception {\n308: int failed = 0;\n309: for(int i = 1; i <= TESTS.length; i++) {\n310: TestData test = TESTS[i-1];\n311: ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n312: final String field = getField(ais,test.fieldName);\n313: if (!eq(test.expectedEncoding,field)) {\n314: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n315: failed++;\n316: }\n317: }\n318: if (failed > 0) {\n319: fail(\"Tests failed: \" + failed);\n320: }",
    "stack_trace": "junit.framework.AssertionFailedError: Tests failed: 20\nat org.junit.Assert.fail(Assert.java:88)\nat org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStream(ArchiveStreamFactoryTest.java:319)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
            "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
            "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\nint m = DumpArchiveUtil.convert16(buffer, 32);\nentry.setType(TYPE.find((m >> 12) & 0x0F));\nentry.setMode(m);\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\nentry.ctime = t;\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\nheader.holes = 0;\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\nentry.volume = header.getVolume();\nreturn entry;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
            "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(long size) {\nthis.size = size;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
            "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
            "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
            "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
            "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
            "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\nreturn type;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
            "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
            "method_body": "public int getVolume() {\nreturn volume;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
            "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
            "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
            "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
            "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
            "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
            "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\nreturn i;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
            "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
            "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\nprivate int currBlkIdx = -1;\nprivate int blockSize = DumpArchiveConstants.TP_SIZE;\nprivate int readOffset = DumpArchiveConstants.TP_SIZE;\nprivate boolean isCompressed = false;\nprivate long bytesRead = 0;\nsuper(in);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
            "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nint bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) && !readBlock(true)) {\nint n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\nreturn bytes;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
            "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\nif (-1 == read(result, 0, result.length)) {\nreturn result;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
            "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\nif (in == null) {\nif (!isCompressed || (currBlkIdx == -1)) {\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\ncurrBlkIdx++;\nreadOffset = 0;\nreturn success;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
            "method_body": "private boolean readFully(byte[] b, int off, int len)\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nreturn true;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
            "method_body": "private TYPE(int code) {\nthis.code = code;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:<init>()V",
            "method_body": "private DumpArchiveConstants.SEGMENT_TYPE type;\nprivate final byte[] cdata = new byte[512]; // map of any 'holes'\nreturn type;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
            "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nreturn this.charset.newDecoder()\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
            "method_body": "protected void count(int read) {\ncount((long) read);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
            "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
            "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
            "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
            "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>(Ljava/lang/String;Ljava/lang/String;ILorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
            "method_body": "private String name;\nprivate TYPE type = TYPE.UNKNOWN;\nprivate Set<PERMISSION> permissions = Collections.emptySet();\nprivate final DumpArchiveSummary summary = null;\nprivate final TapeSegmentHeader header = new TapeSegmentHeader();\npublic DumpArchiveEntry() {\n}",
            "method_id": 88
        }
    ]
}