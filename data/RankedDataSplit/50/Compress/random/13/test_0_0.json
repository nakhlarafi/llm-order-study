{
    "bug_id": 13,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.winzipBackSlashWorkaround",
    "test_body": "35: public void winzipBackSlashWorkaround() throws Exception {\n36: URL zip = getClass().getResource(\"/test-winzip.zip\");\n37: ZipArchiveInputStream in = null;\n38: try {\n39: in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n40: ZipArchiveEntry zae = in.getNextZipEntry();\n41: zae = in.getNextZipEntry();\n42: zae = in.getNextZipEntry();\n43: assertEquals(\"\\u00e4/\", zae.getName());\n44: } finally {\n45: if (in != null) {\n46: in.close();\n47: }\n48: }\n49: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry:<init>()V",
            "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate static final class Buffer {\nprivate final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\nprivate int offsetInBuffer = 0;\nprivate int lengthOfLastRead = 0;\noffsetInBuffer = lengthOfLastRead = 0;\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
            "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
            "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
            "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
            "method_body": "protected void count(int read) {\ncount((long) read);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
            "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
            "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}.",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
            "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
            "method_body": "private static final int WORD = 4;\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length < 5) {\nint version = buffer[offset];\nif (version != 0x01) {\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
            "method_body": "public ZipShort (int value) {\nthis.value = value;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
            "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\nif (origCRC32 == f.getNameCRC32()) {\nreturn ZipEncodingHelper\nreturn null;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
            "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
            "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\nif (commentBytes != null && commentBytes.length > 0) {\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
            "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.buf.length);\nthis.allowStoredEntriesWithDataDescriptor =\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
            "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
            "method_body": "public long getValue() {\nreturn value;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:reset()V",
            "method_body": "private void reset() {\noffsetInBuffer = lengthOfLastRead = 0;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
            "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
            "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
            "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8, true);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
            "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\nreturn b;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
            "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
            "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
            "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
            "method_body": "public int hashCode() {\nreturn value;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
            "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
            "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}",
            "method_id": 49
        }
    ]
}