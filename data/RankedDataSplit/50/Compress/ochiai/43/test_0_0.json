{
    "bug_id": 43,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries",
    "test_body": "135: public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n136: ByteArrayOutputStream init = new ByteArrayOutputStream();\n137: try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n138: zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n139: zos.write(\"foo\".getBytes(\"UTF-8\"));\n140: zos.closeArchiveEntry();\n141: }\n142: 143: File f = new File(dir, \"test.zip\");\n144: try (FileOutputStream fos = new FileOutputStream(f)) {\n145: fos.write(init.toByteArray());\n146: }\n147: 148: ByteArrayOutputStream o = new ByteArrayOutputStream();\n149: ZipArchiveEntry zae;\n150: try (ZipFile zf = new ZipFile(f);\n151: ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n152: zae = zf.getEntry(\"test1.txt\");\n153: zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n154: }\n155: 156: byte[] data = o.toByteArray();\n157: byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n158: // still 2.0 because of Deflate\n159: assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n160: byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n161: // no DD but EFS flag\n162: assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n163: 164: int cdhStart = findCentralDirectory(data);\n165: byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n166: assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n167: byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n168: assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n169: 170: int ddStart = cdhStart - 16;\n171: assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n172: long crcFromLFH = ZipLong.getValue(data, 14);\n173: long cSizeFromLFH = ZipLong.getValue(data, 18);\n174: long sizeFromLFH = ZipLong.getValue(data, 22);\n175: assertEquals(3, sizeFromLFH);\n176: 177: long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n178: assertEquals(crcFromLFH, crcFromCDH);\n179: long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n180: assertEquals(cSizeFromLFH, cSizeFromCDH);\n181: long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n182: assertEquals(sizeFromLFH, sizeFromCDH);\n183: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\nat org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\nat org.junit.Assert.internalArrayEquals(Assert.java:473)\nat org.junit.Assert.assertArrayEquals(Assert.java:294)\nat org.junit.Assert.assertArrayEquals(Assert.java:305)\nat org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries(DataDescriptorTest.java:162)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getRawInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
            "method_body": "public InputStream getRawInputStream(final ZipArchiveEntry ze) {\nif (!(ze instanceof Entry)) {\nfinal long start = ze.getDataOffset();\nreturn createBoundedInputStream(start, ze.getCompressedSize());\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeCopiedEntry(Z)V",
            "method_body": "private void closeCopiedEntry(final boolean phased) throws IOException {\npreClose();\nentry.bytesRead = entry.entry.getSize();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\ncloseEntry(actuallyNeedsZip64, phased);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:addRawArchiveEntry(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/io/InputStream;)V",
            "method_body": "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\nfinal ZipArchiveEntry ae = new ZipArchiveEntry(entry);\nif (hasZip64Extra(ae)) {\nfinal boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\nputArchiveEntry(ae, is2PhaseSource);\ncopyFromZipInputStream(rawStream);\ncloseCopiedEntry(is2PhaseSource);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:copyFromZipInputStream(Ljava/io/InputStream;)V",
            "method_body": "private void copyFromZipInputStream(final InputStream src) throws IOException {\nif (entry == null) {\nZipUtil.checkRequestedFeatures(entry.entry);\nentry.hasWritten = true;\nwhile ((length = src.read(copyBuffer)) >= 0 )\nstreamCompressor.writeCounted(copyBuffer, 0, length);\ncount( length );\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read([BII)I",
            "method_body": "public synchronized int read(final byte[] b, final int off, int len) throws IOException {\nif (len <= 0) {\nif (len > end-loc) {\nif (loc >= end) {\nif (loc == end && addDummy) {\nreturn -1;\nlen = (int)(end-loc);\nbuf = ByteBuffer.wrap(b, off, len);\nint ret = read(loc, buf);\nif (ret > 0) {\nloc += ret;\nreturn ret;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
            "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate int alignment = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nprivate long localHeaderOffset = OFFSET_UNKNOWN;\nprivate long dataOffset = OFFSET_UNKNOWN;\nprivate boolean isStreamContiguous = false;\nsuper(name);\nsetName(name);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\nthis((java.util.zip.ZipEntry) entry);\nsetInternalAttributes(entry.getInternalAttributes());\nsetExternalAttributes(entry.getExternalAttributes());\nsetExtraFields(getAllExtraFieldsNoCopy());\nsetPlatform(entry.getPlatform());\nfinal GeneralPurposeBit other = entry.getGeneralPurposeBit();\nsetGeneralPurposeBit(other == null ? null :\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:read(JLjava/nio/ByteBuffer;)I",
            "method_body": "protected int read(long pos, ByteBuffer buf) throws IOException {\nint read = archive.read(buf, pos);\nbuf.flip();\nreturn read;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:clone()Ljava/lang/Object;",
            "method_body": "public Object clone() {\nreturn super.clone();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedFileChannelInputStream(final long start, final long remaining) {\nsuper(start, remaining);\narchive = (FileChannel)ZipFile.this.archive;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:createBoundedInputStream(JJ)Lorg/apache/commons/compress/archivers/zip/ZipFile$BoundedInputStream;",
            "method_body": "private BoundedInputStream createBoundedInputStream(long start, long remaining) {\nreturn archive instanceof FileChannel ?\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedInputStream(final long start, final long remaining) {\nthis.end = start+remaining;\nif (this.end < start) {\nloc = start;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getDataOffset()J",
            "method_body": "public long getDataOffset() {\nreturn dataOffset;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
            "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
            "method_body": "protected void count(final int written) {\ncount((long) written);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
            "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
            "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnparseableOnly()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "private ZipExtraField[] getUnparseableOnly() {\nreturn unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
            "method_body": "private void positionAtCentralDirectory32()\nskipBytes(CFD_LOCATOR_OFFSET);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\narchive.position(ZipLong.getValue(wordBuf));\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:writeOut([BII)V",
            "method_body": "protected final void writeOut(final byte[] data, final int offset, final int length)\nos.write(data, offset, length);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
            "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
            "method_body": "static StreamCompressor create(final OutputStream os, final Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:<init>(Ljava/util/zip/Deflater;Ljava/io/OutputStream;)V",
            "method_body": "public OutputStreamCompressor(final Deflater deflater, final OutputStream os) {\nsuper(deflater);\nthis.os = os;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionMadeBy(I)V",
            "method_body": "public void setVersionMadeBy(final int versionMadeBy) {\nthis.versionMadeBy = versionMadeBy;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionRequired(I)V",
            "method_body": "public void setVersionRequired(final int versionRequired) {\nthis.versionRequired = versionRequired;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setRawFlag(I)V",
            "method_body": "public void setRawFlag(final int rawFlag) {\nthis.rawFlag = rawFlag;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
            "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
            "method_body": "private void\ncfhBbuf.rewind();\nIOUtils.readFully(archive, cfhBbuf);\nint off = 0;\nfinal Entry ze = new Entry();\nfinal int versionMadeBy = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setVersionMadeBy(versionMadeBy);\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\nze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\noff += SHORT; // version required\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\nze.setRawFlag(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal int fileNameLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int commentLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int diskStart = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal byte[] fileName = new byte[fileNameLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(fileName));\nze.setName(entryEncoding.decode(fileName), fileName);\nze.setLocalHeaderOffset(ZipLong.getValue(cfhBuf, off));\nentries.add(ze);\nfinal byte[] cdExtraData = new byte[extraLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, diskStart);\nfinal byte[] comment = new byte[commentLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(comment));\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;I)V",
            "method_body": "private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\nfinal Zip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
            "method_body": "private void skipBytes(final int count) throws IOException {\nlong currentPosition = archive.position();\nlong newPosition = currentPosition + count;\nif (newPosition > archive.size()) {\narchive.position(newPosition);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
            "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal long offset = ze.getLocalHeaderOffset();\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\nze.setDataOffset(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nze.setStreamContiguous(true);\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\nentriesOfThatName.addLast(ze);\n}\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>()V",
            "method_body": "Entry() {\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
            "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
            "method_body": "public void setCentralDirectoryExtra(final byte[] b) {\nfinal ZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalHeaderOffset()J",
            "method_body": "protected long getLocalHeaderOffset() {\nreturn this.localHeaderOffset;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
            "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nprivate volatile boolean closed = true;\nprivate final byte[] dwordBuf = new byte[DWORD];\nprivate final byte[] wordBuf = new byte[WORD];\nprivate final byte[] cfhBuf = new byte[CFH_LEN];\nprivate final byte[] shortBuf = new byte[SHORT];\nprivate final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\nprivate final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\nprivate final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\nthis(f, ZipEncodingHelper.UTF8);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
            "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
            "method_body": "private void positionAtCentralDirectory()\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nfinal boolean searchedForZip64EOCD =\nif (searchedForZip64EOCD) {\narchive.position(archive.position() - ZIP64_EOCDL_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nif (!found) {\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\npositionAtCentralDirectory32();\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
            "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nfinal boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
            "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.position(off);\nreturn found;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
            "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflateUntilInputIsNeeded()V",
            "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
            "method_body": "public void setInternalAttributes(final int value) {\ninternalAttributes = value;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
            "method_body": "public void setExternalAttributes(final long value) {\nexternalAttributes = value;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:flushDeflater()V",
            "method_body": "void flushDeflater() throws IOException {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeDeflated([BII)V",
            "method_body": "private void writeDeflated(final byte[] b, final int offset, final int length)\nif (length > 0 && !def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflate()V",
            "method_body": "void deflate() throws IOException {\nfinal int len = def.deflate(outputBuffer, 0, outputBuffer.length);\nif (len > 0) {\nwriteCounted(outputBuffer, 0, len);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isTooLageForZip32(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry){\nreturn zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
            "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 49
        }
    ]
}