{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207",
    "test_body": "public void testIssue207() throws Exception\n{\nByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\nField byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\nbyteSymbolCanonicalizerField.setAccessible(true);\nJsonFactory jsonF = new JsonFactory();\nbyteSymbolCanonicalizerField.set(jsonF, nc);\n110: StringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"{\\n\");\nstringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\nfor (int i = 0; i < 60; ++i) {\nstringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n}\nstringBuilder.append(\"\\n}\");\n118: JsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\nwhile (p.nextToken() != null) { }\np.close();",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 256\nat com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseEscapedName(UTF8StreamJsonParser.java:1980)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.slowParseName(UTF8StreamJsonParser.java:1867)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1651)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:740)\nat com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207(TestByteBasedSymbols.java:119)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:<clinit>()V",
            "method_body": "final static int[] sInputCodes;\nfinal int[] table = new int[256];\nfor (int i = 0; i < 32; ++i) {\ntable[i] = -1;\ntable['\"'] = 1;\ntable['\\\\'] = 1;\nsInputCodes = table;\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;)V",
            "method_body": "public TextBuffer(BufferRecycler allocator) {\n_allocator = allocator;\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:getMask()I",
            "method_body": "public int getMask() { return (1 << ordinal()); }\npublic int getMask() { return (1 << ordinal()); }",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;Ljava/lang/Object;Z)V",
            "method_body": "protected final Object _sourceRef;\nprotected byte[] _readIOBuffer = null;\nprotected byte[] _writeEncodingBuffer = null;\nprotected byte[] _base64Buffer = null;\nprotected char[] _tokenCBuffer = null;\nprotected char[] _concatCBuffer = null;\nprotected char[] _nameCopyBuffer = null;\n{\n_bufferRecycler = br;\n_sourceRef = sourceRef;\n_managedResource = managedResource;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1;\npublic final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\nreturn flags;\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:calcHash(I)I",
            "method_body": "public int calcHash(int q1)\nint hash = q1 ^ _seed;\nhash += (hash >>> 16); // to xor hi- and low- 16-bits\nhash ^= (hash >>> 12);\nreturn hash;\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:pad(II)I",
            "method_body": "private final static int pad(int q, int bytes) {\nreturn (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createParser([BIILcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\nreturn new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:inObject()Z",
            "method_body": "public final boolean inObject() { return _type == TYPE_OBJECT; }\npublic final boolean inObject() { return _type == TYPE_OBJECT; }",
            "method_id": 9
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<init>()V",
            "method_body": "private CharsToNameCanonicalizer() {\n_canonicalize = true;\n_flags = -1;\n_dirty = true;\n_hashSeed = 0;\n_longestCollisionList = 0;\ninitTables(DEFAULT_T_SIZE);\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:ensureLoaded(I)Z",
            "method_body": "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\nswitch (quad) {\nint msw = quad >>> 16;\nif (msw == 0xFEFF) { // UTF-16, BE\nif (msw == 0xFFFE) { // UTF-16, LE\nif ((quad >>> 8) == 0xEFBBBF) { // UTF-8\nreturn false;\nif ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n} else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n} else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\n} else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\nreturn false;\nif ((i16 & 0xFF00) == 0) { // UTF-16BE\n} else if ((i16 & 0x00FF) == 0) { // UTF-16LE\nreturn false;\nint gotten = (_inputEnd - _inputPtr);\nwhile (gotten < minimum) {\nreturn true;\n}",
            "method_id": 11
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipWSOrEnd()I",
            "method_body": "private final int _skipWSOrEnd() throws IOException\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn i;\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nwhile (_inputPtr < _inputEnd) {\ni = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn i;\nif (i != INT_SPACE) {\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonEncoding:<init>(Ljava/lang/String;ILjava/lang/String;ZI)V",
            "method_body": "JsonEncoding(String javaName, boolean bigEndian, int bits)\n{\n_javaName = javaName;\n_bigEndian = bigEndian;\n_bits = bits;\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeLatin1()[I",
            "method_body": "public static int[] getInputCodeLatin1() { return sInputCodes; }\npublic static int[] getInputCodeLatin1() { return sInputCodes; }",
            "method_id": 14
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\nreturn flags;\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseEscapedName([IIIII)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:setCurrentName(Ljava/lang/String;)V",
            "method_body": "public void setCurrentName(String name) throws JsonProcessingException {\n_currentName = name;\nif (_dups != null) { _checkDup(_dups, name); }\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:addName([III)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 18
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\npublic boolean enabledIn(int flags) { return (flags & _mask) != 0; }",
            "method_id": 19
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:nukeSymbols(Z)V",
            "method_body": "private void nukeSymbols(boolean fill) {\n_count = 0;\n_spilloverEnd = _spilloverStart();\n_longNameOffset = _hashSize << 3;\nif (fill) {\n}",
            "method_id": 20
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}",
            "method_id": 21
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:makeChild(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "public ByteQuadsCanonicalizer makeChild(int flags) {\nreturn new ByteQuadsCanonicalizer(this,\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:findName([II)Ljava/lang/String;",
            "method_body": "public String findName(int[] q, int qlen)\nif (qlen < 4) { // another sanity check\nif (qlen == 3) {\nif (qlen == 2) {\nreturn findName(q[0]);\nfinal int hash = calcHash(q, qlen);\nint offset = _calcOffset(hash);\nfinal int[] hashArea = _hashArea;\nfinal int len = hashArea[offset+3];\nif ((hash == hashArea[offset]) && (len == qlen)) {\nif (len == 0) { // empty slot; unlikely but avoid further lookups if so\nreturn null;\n}",
            "method_id": 23
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>()V",
            "method_body": "public JsonFactory() { this(null); }\npublic JsonFactory() { this(null); }",
            "method_id": 24
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_spilloverStart()I",
            "method_body": "private final int _spilloverStart() {\nint offset = _hashSize;\nreturn (offset << 3) - offset;\n}",
            "method_id": 25
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_findOffsetForAdd(I)I",
            "method_body": "private int _findOffsetForAdd(int hash)\nint offset = _calcOffset(hash);\nfinal int[] hashArea = _hashArea;\nif (hashArea[offset+3] == 0) {\nreturn offset;\nint offset2 = _secondaryStart + ((offset >> 3) << 2);\nif (hashArea[offset2+3] == 0) {\nreturn offset2;\noffset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\nfinal int bucketSize = (1 << _tertiaryShift);\nfor (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\nif (hashArea[offset2+3] == 0) {\nreturn offset2;\noffset = _spilloverEnd;\n_spilloverEnd += 4;\nif (_spilloverEnd >= hashArea.length) {\nif (_failOnDoS) {\n_reportTooManyCollisions();\n_needRehash = true;\nreturn offset;\n}",
            "method_id": 26
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeUtf8()[I",
            "method_body": "public static int[] getInputCodeUtf8() { return sInputCodesUTF8; }\npublic static int[] getInputCodeUtf8() { return sInputCodesUTF8; }",
            "method_id": 27
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:isEnabled(Lcom/fasterxml/jackson/core/JsonFactory$Feature;)Z",
            "method_body": "public final boolean isEnabled(JsonFactory.Feature f) {\nreturn (_factoryFeatures & f.getMask()) != 0;\n}",
            "method_id": 28
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:constructParser(ILcom/fasterxml/jackson/core/ObjectCodec;Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;I)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\nJsonEncoding enc = detectEncoding();\nif (enc == JsonEncoding.UTF8) {\nif (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\nByteQuadsCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\nreturn new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n}",
            "method_id": 29
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:findName(II)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 30
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_nextTokenNotInObject(I)Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextTokenNotInObject(int i) throws IOException\nif (i == INT_QUOTE) {\nswitch (i) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\nif (t == JsonToken.START_ARRAY) {\n} else if (t == JsonToken.START_OBJECT) {\nreturn (_currToken = t);\n}",
            "method_id": 31
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "protected static ByteQuadsCanonicalizer createRoot(int seed) {\nreturn new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n}",
            "method_id": 32
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<clinit>()V",
            "method_body": "public final static int HASH_MULT = 33;\nfinal static CharsToNameCanonicalizer sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n* Method called to create root canonicalizer for a {@link com.fasterxml.jackson.core.JsonFactory}",
            "method_id": 33
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseMediumName(I)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\nif (i != INT_QUOTE) {\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint q = input[_inputPtr++] & 0xFF;\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseMediumName2(i, q2);\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nreturn parseLongName(i, q2, q3);\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (qlen >= _quadBuffer.length) {\n_quadBuffer[qlen++] = q;\nq = i;\n}\nif (_inputPtr >= _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\nfinal int[] codes = _icLatin1;\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\nif (_inputPtr >= _inputEnd) {\nch = _inputBuffer[_inputPtr++] & 0xFF;\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\nquads[qlen++] = pad(currQuad, currQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\nq1 = pad(q1, lastQuadBytes);\nString name = _symbols.findName(q1);\nif (name != null) {\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\nif (qlen >= quads.length) {\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\nif (ch > 127) { // multi-byte\nif (cix >= cbuf.length) {\ncbuf[cix++] = (char) ch;\n}\nString baseName = new String(cbuf, 0, cix);\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\nreturn _symbols.addName(baseName, quads, qlen);\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n++_inputPtr;\n} while (++i < len);\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n}",
            "method_id": 34
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "public JsonFactory(ObjectCodec oc) { _objectCodec = oc; }\npublic JsonFactory(ObjectCodec oc) { _objectCodec = oc; }",
            "method_id": 35
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer$TableInfo:createInitial(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer$TableInfo;",
            "method_body": "public static TableInfo createInitial(int sz) {\nint hashAreaSize = sz << 3;\nint tertShift = _calcTertiaryShift(sz);\nreturn new TableInfo(sz, // hashSize\n}",
            "method_id": 36
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:<clinit>()V",
            "method_body": "protected byte[] _binaryValue;\nfinal static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\nfinal static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\nfinal static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\nfinal static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\nfinal static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\nfinal static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\nfinal static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\nfinal static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\nprotected int _numTypesValid = NR_UNKNOWN;\nsuper(features);\n_ioContext = ctxt;\n_textBuffer = ctxt.constructTextBuffer();\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n_parsingContext = JsonReadContext.createRootContext(dups);\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\npublic boolean enabledIn(int flags) { return (flags & getMask()) != 0; }",
            "method_id": 38
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 39
        }
    ]
}