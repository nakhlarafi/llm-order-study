{
    "bug_id": 6,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "protected PointVectorValuePair doOptimize() {\ncheckParameters();\nfinal int nR = getTarget().length; // Number of observed data.\nfinal double[] currentPoint = getStartPoint();\nfinal int nC = currentPoint.length; // Number of parameters.\nsolvedCols  = FastMath.min(nR, nC);\ndiagR       = new double[nC];\njacNorm     = new double[nC];\nbeta        = new double[nC];\npermutation = new int[nC];\nlmDir       = new double[nC];\ndouble   delta   = 0;\ndouble   xNorm   = 0;\ndouble[] diag    = new double[nC];\ndouble[] oldX    = new double[nC];\ndouble[] oldRes  = new double[nR];\ndouble[] oldObj  = new double[nR];\ndouble[] qtf     = new double[nR];\ndouble[] work1   = new double[nC];\ndouble[] work2   = new double[nC];\ndouble[] work3   = new double[nC];\nfinal RealMatrix weightMatrixSqrt = getWeightSquareRoot();\ndouble[] currentObjective = computeObjectiveValue(currentPoint);\ndouble[] currentResiduals = computeResiduals(currentObjective);\nPointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\ndouble currentCost = computeCost(currentResiduals);\nlmPar = 0;\nboolean firstIteration = true;\nint iter = 0;\nfinal ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n++iter;\nfinal PointVectorValuePair previous = current;\nqrDecomposition(computeWeightedJacobian(currentPoint));\nweightedResidual = weightMatrixSqrt.operate(currentResiduals);\nfor (int i = 0; i < nR; i++) {\nqtf[i] = weightedResidual[i];\nqTy(qtf);\nfor (int k = 0; k < solvedCols; ++k) {\nint pk = permutation[k];\nweightedJacobian[k][pk] = diagR[pk];\nif (firstIteration) {\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble dk = jacNorm[k];\nif (dk == 0) {\ndouble xk = dk * currentPoint[k];\nxNorm  += xk * xk;\ndiag[k] = dk;\nxNorm = FastMath.sqrt(xNorm);\ndelta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\ndouble maxCosine = 0;\nif (currentCost != 0) {\nfor (int j = 0; j < solvedCols; ++j) {\nint    pj = permutation[j];\ndouble s  = jacNorm[pj];\nif (s != 0) {\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qtf[i];\nmaxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\nif (maxCosine <= orthoTolerance) {\nfor (int j = 0; j < nC; ++j) {\ndiag[j] = FastMath.max(diag[j], jacNorm[j]);\nfor (double ratio = 0; ratio < 1.0e-4;) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\noldX[pj] = currentPoint[pj];\nfinal double previousCost = currentCost;\ndouble[] tmpVec = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\ndetermineLMParameter(qtf, delta, diag, work1, work2, work3);\ndouble lmNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nlmDir[pj] = -lmDir[pj];\ncurrentPoint[pj] = oldX[pj] + lmDir[pj];\ndouble s = diag[pj] * lmDir[pj];\nlmNorm  += s * s;\nlmNorm = FastMath.sqrt(lmNorm);\nif (firstIteration) {\ndelta = FastMath.min(delta, lmNorm);\ncurrentObjective = computeObjectiveValue(currentPoint);\ncurrentResiduals = computeResiduals(currentObjective);\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\ncurrentCost = computeCost(currentResiduals);\ndouble actRed = -1.0;\nif (0.1 * currentCost < previousCost) {\ndouble r = currentCost / previousCost;\nactRed = 1.0 - r * r;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dirJ = lmDir[pj];\nwork1[j] = 0;\nfor (int i = 0; i <= j; ++i) {\nwork1[i] += weightedJacobian[i][pj] * dirJ;\ndouble coeff1 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ncoeff1 += work1[j] * work1[j];\ndouble pc2 = previousCost * previousCost;\ncoeff1 = coeff1 / pc2;\ndouble coeff2 = lmPar * lmNorm * lmNorm / pc2;\ndouble preRed = coeff1 + 2 * coeff2;\ndouble dirDer = -(coeff1 + coeff2);\nratio = (preRed == 0) ? 0 : (actRed / preRed);\nif (ratio <= 0.25) {\ndouble tmp =\nif ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\ntmp = 0.1;\ndelta = tmp * FastMath.min(delta, 10.0 * lmNorm);\nlmPar /= tmp;\n} else if ((lmPar == 0) || (ratio >= 0.75)) {\ndelta = 2 * lmNorm;\nlmPar *= 0.5;\nif (ratio >= 1.0e-4) {\nfirstIteration = false;\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble xK = diag[k] * currentPoint[k];\nxNorm += xK * xK;\nxNorm = FastMath.sqrt(xNorm);\nif (checker != null) {\ncurrentCost = previousCost;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ncurrentPoint[pj] = oldX[pj];\ntmpVec    = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\nif ((FastMath.abs(actRed) <= costRelativeTolerance &&\nsetCost(currentCost);\nreturn current;\nif ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n} else if (delta <= 2.2204e-16 * xNorm) {\n} else if (maxCosine <= 2.2204e-16)  {\n}\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:getTarget()[D",
            "method_body": "public double[] getTarget() {\nreturn target.clone();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:setCost(D)V",
            "method_body": "protected void setCost(double cost) {\nthis.cost = cost;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qTy([D)V",
            "method_body": "private void qTy(double[] y) {\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\nfor (int k = 0; k < nC; ++k) {\nint pk = permutation[k];\ndouble gamma = 0;\nfor (int i = k; i < nR; ++i) {\ngamma += weightedJacobian[i][pk] * y[i];\ngamma *= beta[pk];\nfor (int i = k; i < nR; ++i) {\ny[i] -= gamma * weightedJacobian[i][pk];\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nif (upperBound != null) {\nif (upperBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension,\nthrows NotStrictlyPositiveException {\nif (rowDimension < 1) {\nif (columnDimension < 1) {\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nif (left.getColumnDimension() != right.getRowDimension()) {\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>(DDDDD)V",
            "method_body": "public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\nsuper(null); // No custom convergence criterion.\nthis.initialStepBoundFactor = initialStepBoundFactor;\nthis.costRelativeTolerance = costRelativeTolerance;\nthis.parRelativeTolerance = parRelativeTolerance;\nthis.orthoTolerance = orthoTolerance;\nthis.qrRankingThreshold = threshold;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (getLowerBound() != null ||\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction:getModelFunction()Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;",
            "method_body": "public MultivariateVectorFunction getModelFunction() {\nreturn model;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([DZ)V",
            "method_body": "public ArrayRealVector(double[] d, boolean copyArray)\nthrows NullArgumentException {\nif (d == null) {\ndata = copyArray ? d.clone() :  d;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian:<init>(Lorg/apache/commons/math3/analysis/MultivariateMatrixFunction;)V",
            "method_body": "public ModelFunctionJacobian(MultivariateMatrixFunction j) {\njacobian = j;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:<init>([DZ)V",
            "method_body": "public DiagonalMatrix(final double[] d, final boolean copyArray)\nthrows NullArgumentException {\nMathUtils.checkNotNull(d);\ndata = copyArray ? d.clone() : d;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\nif (a < b) {\nreturn a;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\nif (data instanceof MaxIter) {\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected JacobianMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[D)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nthis(point, value, true);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:pow(DI)D",
            "method_body": "public static double pow(double d, int e) {\nif (e == 0) {\n} else if (e < 0) {\nfinal int splitFactor = 0x8000001;\nfinal double cd       = splitFactor * d;\nfinal double d1High   = cd - (cd - d);\nfinal double d1Low    = d - d1High;\ndouble resultHigh = 1;\ndouble resultLow  = 0;\ndouble d2p     = d;\ndouble d2pHigh = d1High;\ndouble d2pLow  = d1Low;\nwhile (e != 0) {\nif ((e & 0x1) != 0) {\nfinal double tmpHigh = resultHigh * d2p;\nfinal double cRH     = splitFactor * resultHigh;\nfinal double rHH     = cRH - (cRH - resultHigh);\nfinal double rHL     = resultHigh - rHH;\nfinal double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\nresultHigh = tmpHigh;\nresultLow  = resultLow * d2p + tmpLow;\nfinal double tmpHigh = d2pHigh * d2p;\nfinal double cD2pH   = splitFactor * d2pHigh;\nfinal double d2pHH   = cD2pH - (cD2pH - d2pHigh);\nfinal double d2pHL   = d2pHigh - d2pHH;\nfinal double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\nfinal double cTmpH   = splitFactor * tmpHigh;\nd2pHigh = cTmpH - (cTmpH - tmpHigh);\nd2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\nd2p     = d2pHigh + d2pLow;\ne = e >> 1;\n}\nreturn resultHigh + resultLow;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeWeightedJacobian([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "protected RealMatrix computeWeightedJacobian(double[] params) {\nreturn weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof Weight) {\nweightMatrixSqrt = squareRoot(((Weight) data).getWeight());\nbreak;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof ModelFunction) {\nmodel = ((ModelFunction) data).getModelFunction();\ncontinue;\nif (data instanceof Target) {\ntarget = ((Target) data).getTarget();\ncontinue;\nif (data instanceof Weight) {\nweightMatrix = ((Weight) data).getWeight();\ncontinue;\ncheckParameters();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:copy()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix copy() {\nreturn new DiagonalMatrix(data);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nreturn Double.NaN;\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (target.length != weightMatrix.getColumnDimension()) {\n}",
            "method_id": 39
        }
    ]
}