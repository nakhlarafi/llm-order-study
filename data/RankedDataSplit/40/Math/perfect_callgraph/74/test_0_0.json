{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\nfinal int stages = c.length + 1;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, y0.length);\nfinal double[][] yDotK = new double[stages][y0.length];\nfinal double[] yTmp = new double[y0.length];\nif (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\nfinal RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\nrki.reinitialize(this, yTmp, yDotK, forward);\ninterpolator = rki;\n} else {\ninterpolator.storeTime(t0);\nstepStart         = t0;\ndouble  hNew      = 0;\nboolean firstTime = true;\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nboolean lastStep = false;\nwhile (!lastStep) {\ninterpolator.shift();\ndouble error = 0;\nfor (boolean loop = true; loop;) {\nif (firstTime || !fsal) {\ncomputeDerivatives(stepStart, y, yDotK[0]);\nif (firstTime) {\nif (vecAbsoluteTolerance == null) {\nscale = new double[y0.length];\njava.util.Arrays.fill(scale, scalAbsoluteTolerance);\nhNew = initializeStep(equations, forward, getOrder(), scale,\nfirstTime = false;\nstepSize = hNew;\nfor (int k = 1; k < stages; ++k) {\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error <= 1.0) {\ninterpolator.storeTime(stepStart + stepSize);\nif (manager.evaluateStep(interpolator)) {\nloop = false;\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\ninterpolator.storeTime(nextStep);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, lastStep);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:<init>(IDDDD)V",
            "method_body": "public AdamsMoultonIntegrator(final int nSteps,\nsuper(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:<init>(Ljava/lang/String;IIDDDD)V",
            "method_body": "public AdamsIntegrator(final String name, final int nSteps, final int order,\nsuper(name, nSteps, order, minStep, maxStep,\ntransformer = AdamsNordsieckTransformer.getInstance(nSteps);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:<init>(Ljava/lang/String;IIDDDD)V",
            "method_body": "protected MultistepIntegrator(final String name, final int nSteps,\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nif (nSteps <= 0) {\nstarter = new DormandPrince853Integrator(minStep, maxStep,\nthis.nSteps = nSteps;\nexp = -1.0 / order;\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(Math.pow(2.0, -exp));\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:<init>(Ljava/lang/String;DDDD)V",
            "method_body": "public AdaptiveStepsizeIntegrator(final String name,\nsuper(name);\nthis.minStep     = Math.abs(minStep);\nthis.maxStep     = Math.abs(maxStep);\nthis.initialStep = -1.0;\nthis.scalAbsoluteTolerance = scalAbsoluteTolerance;\nthis.scalRelativeTolerance = scalRelativeTolerance;\nthis.vecAbsoluteTolerance  = null;\nthis.vecRelativeTolerance  = null;\nresetInternalState();\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsHandlersManager = new CombinedEventsManager();\nsetMaxEvaluations(-1);\nresetEvaluations();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:resetInternalState()V",
            "method_body": "protected void resetInternalState() {\nstepStart = Double.NaN;\nstepSize  = Math.sqrt(minStep * maxStep);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:getInstance(I)Lorg/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer;",
            "method_body": "public static AdamsNordsieckTransformer getInstance(final int nSteps) {\nsynchronized(CACHE) {\nAdamsNordsieckTransformer t = CACHE.get(nSteps);\nif (t == null) {\nreturn t;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>()V",
            "method_body": "protected AbstractStepInterpolator() {\npreviousTime            = Double.NaN;\ncurrentTime             = Double.NaN;\nh                       = Double.NaN;\ninterpolatedTime        = Double.NaN;\ncurrentState            = null;\ninterpolatedState       = null;\ninterpolatedDerivatives = null;\nfinalized               = false;\nthis.forward            = true;\nthis.dirtyState         = true;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:rescale(D)V",
            "method_body": "public void rescale(final double stepSize) {\nfinal double ratio = stepSize / scalingH;\nfor (int i = 0; i < scaled.length; ++i) {\nscaled[i] *= ratio;\nfinal double[][] nData = nordsieck.getDataRef();\ndouble power = ratio;\nfor (int i = 0; i < nData.length; ++i) {\npower *= ratio;\nfinal double[] nDataI = nData[i];\nfor (int j = 0; j < nDataI.length; ++j) {\nnDataI[j] *= power;\nscalingH = stepSize;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reinitializeBegin(D[D)V",
            "method_body": "public void reinitializeBegin(final double tStart, final double[] yStart)\nt0 = tStart;\ng0 = handler.g(tStart, yStart);\ng0Positive = g0 >= 0;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nsuper(100, 1E-6);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:<init>(ID)V",
            "method_body": "protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\nsuper(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\nthis.defaultFunctionValueAccuracy = 1.0e-15;\nthis.functionValueAccuracy = defaultFunctionValueAccuracy;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage()Ljava/lang/String;",
            "method_body": "public String getMessage() {\nreturn getMessage(Locale.US);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn (first == null) ? Double.NaN : first.getEventTime();\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nfor (EventState state : states) {\nstate.stepAccepted(t, y);\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nt0 = t;\ng0 = handler.g(t, y);\nif (pendingEvent) {\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\ng0Positive = g0 >= 0;\nnextAction = EventHandler.CONTINUE;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stop()Z",
            "method_body": "public boolean stop() {\nfor (EventState state : states) {\nif (state.stop()) {\nreturn true;\nreturn false;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nboolean resetDerivatives = false;\nfor (EventState state : states) {\nif (state.reset(t, y)) {\nreturn resetDerivatives;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nif (! pendingEvent) {\nreturn false;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getMaxStep()D",
            "method_body": "public double getMaxStep() {\nreturn maxStep;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:initializeHighOrderDerivatives([D[[D)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\nreturn transformer.initializeHighOrderDerivatives(first, multistep);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedDerivatives()[D",
            "method_body": "public double[] getInterpolatedDerivatives() throws DerivativeException {\nif (dirtyState) {\nfinal double oneMinusThetaH = currentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\nreturn interpolatedDerivatives;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:updateHighOrderDerivativesPhase1(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\nreturn transformer.updateHighOrderDerivativesPhase1(highOrder);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEndTimeChecker(DDLorg/apache/commons/math/ode/events/CombinedEventsManager;)Lorg/apache/commons/math/ode/events/CombinedEventsManager;",
            "method_body": "protected CombinedEventsManager addEndTimeChecker(final double startTime,\nCombinedEventsManager newManager = new CombinedEventsManager();\nfor (final EventState state : manager.getEventsStates()) {\nnewManager.addEventHandler(new EndTimeChecker(endTime),\nreturn newManager;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\ncurrentTime = t;\nh           = currentTime - previousTime;\nsetInterpolatedTime(t);\nfinalized  = false;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:copy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "public StepInterpolator copy() throws DerivativeException {\nfinalizeStep();\nreturn doCopy();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getPreviousTime()D",
            "method_body": "public double getPreviousTime() {\nreturn previousTime;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:sanityChecks(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)V",
            "method_body": "protected void sanityChecks(final FirstOrderDifferentialEquations equations,\nsuper.sanityChecks(equations, t0, y0, t, y);\nif ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\nif ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:shift()V",
            "method_body": "public void shift() {\npreviousTime = currentTime;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(final double t, final double[] y, final double[] yDot)\nif (++evaluations > maxEvaluations) {\nequations.computeDerivatives(t, y, yDot);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setAbsoluteAccuracy(D)V",
            "method_body": "public void setAbsoluteAccuracy(double accuracy) {\nabsoluteAccuracy = accuracy;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.DerivativeException:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public DerivativeException(final Throwable cause) {\nsuper(cause);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:getOrder()I",
            "method_body": "public int getOrder() {\nreturn 8;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 39
        }
    ]
}