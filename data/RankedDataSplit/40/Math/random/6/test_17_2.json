{
    "bug_id": 6,
    "test_id": 17,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigarWithBoundaries",
    "test_body": "public void testCigarWithBoundaries() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new Cigar(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigarWithBoundaries(CMAESOptimizerTest.java:213)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public EigenDecomposition(final RealMatrix matrix)\nthrows MathArithmeticException {\nfinal double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\nisSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\nif (isSymmetric) {\ntransformToTridiagonal(matrix);\nfindEigenVectors(transformer.getQ().getData());\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:min(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double min(final RealMatrix m) {\ndouble min = Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (min > e) {\nmin = e;\nreturn min;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:updateEvolutionPaths(Lorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)Z",
            "method_body": "private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\nps = ps.scalarMultiply(1 - cs).add(\nnormps = ps.getFrobeniusNorm();\nfinal boolean hsig = normps /\npc = pc.scalarMultiply(1 - cc);\nif (hsig) {\npc = pc.add(xmean.subtract(xold).scalarMultiply(Math.sqrt(cc * (2 - cc) * mueff) / sigma));\nreturn hsig;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\nreturn sinQ(a, b);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:findEigenVectors([[D)V",
            "method_body": "private void findEigenVectors(final double[][] householderMatrix) {\nfinal double[][]z = householderMatrix.clone();\nfinal int n = main.length;\nrealEigenvalues = new double[n];\nimagEigenvalues = new double[n];\nfinal double[] e = new double[n];\nfor (int i = 0; i < n - 1; i++) {\nrealEigenvalues[i] = main[i];\ne[i] = secondary[i];\nrealEigenvalues[n - 1] = main[n - 1];\ne[n - 1] = 0;\ndouble maxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\nif (FastMath.abs(e[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue = FastMath.abs(e[i]);\nif (maxAbsoluteValue != 0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\nif (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\ne[i]=0;\nfor (int j = 0; j < n; j++) {\nint its = 0;\nfor (m = j; m < n - 1; m++) {\ndouble delta = FastMath.abs(realEigenvalues[m]) +\nif (FastMath.abs(e[m]) + delta == delta) {\nbreak;\nif (m != j) {\nif (its == maxIter) {\nits++;\ndouble q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\ndouble t = FastMath.sqrt(1 + q * q);\nif (q < 0.0) {\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\nq = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\ndouble u = 0.0;\ndouble s = 1.0;\ndouble c = 1.0;\nfor (i = m - 1; i >= j; i--) {\ndouble p = s * e[i];\ndouble h = c * e[i];\nif (FastMath.abs(p) >= FastMath.abs(q)) {\nc = q / p;\nt = FastMath.sqrt(c * c + 1.0);\ne[i + 1] = p * t;\ns = 1.0 / t;\nc = c * s;\ns = p / q;\nt = FastMath.sqrt(s * s + 1.0);\ne[i + 1] = q * t;\nc = 1.0 / t;\ns = s * c;\nif (e[i + 1] == 0.0) {\nq = realEigenvalues[i + 1] - u;\nt = (realEigenvalues[i] - q) * s + 2.0 * c * h;\nu = s * t;\nrealEigenvalues[i + 1] = q + u;\nq = c * t - h;\nfor (int ia = 0; ia < n; ia++) {\np = z[ia][i + 1];\nz[ia][i + 1] = s * z[ia][i] + c * p;\nz[ia][i] = c * z[ia][i] - s * p;\nif (t == 0.0 && i >= j) {\nrealEigenvalues[j] -= u;\ne[j] = q;\ne[m] = 0.0;\n} while (m != j);\nfor (int i = 0; i < n; i++) {\nint k = i;\ndouble p = realEigenvalues[i];\nfor (int j = i + 1; j < n; j++) {\nif (realEigenvalues[j] > p) {\nk = j;\np = realEigenvalues[j];\nif (k != i) {\nrealEigenvalues[k] = realEigenvalues[i];\nrealEigenvalues[i] = p;\nfor (int j = 0; j < n; j++) {\np = z[j][i];\nz[j][i] = z[j][k];\nz[j][k] = p;\nmaxAbsoluteValue = 0;\nfor (int i = 0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\nmaxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\nif (maxAbsoluteValue != 0.0) {\nfor (int i=0; i < n; i++) {\nif (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\neigenvectors = new ArrayRealVector[n];\nfinal double[] tmp = new double[n];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[j] = z[j][i];\neigenvectors[i] = new ArrayRealVector(tmp);\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkAdditionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:getPopulationSize()I",
            "method_body": "public int getPopulationSize() {\nreturn lambda;\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumnVector(ILorg/apache/commons/math3/linear/RealVector;)V",
            "method_body": "public void setColumnVector(final int column, final RealVector vector)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (vector.getDimension() != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, vector.getEntry(i));\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:diag(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix diag(final RealMatrix m) {\nif (m.getColumnDimension() == 1) {\nfinal double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\nfor (int i = 0; i < m.getRowDimension(); i++) {\nd[i][i] = m.getEntry(i, 0);\nreturn new Array2DRowRealMatrix(d, false);\nfinal double[][] d = new double[m.getRowDimension()][1];\nfor (int i = 0; i < m.getColumnDimension(); i++) {\nd[i][0] = m.getEntry(i, i);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetricInternal(Lorg/apache/commons/math3/linear/RealMatrix;DZ)Z",
            "method_body": "private static boolean isSymmetricInternal(RealMatrix matrix,\nfinal int rows = matrix.getRowDimension();\nif (rows != matrix.getColumnDimension()) {\nfor (int i = 0; i < rows; i++) {\nfor (int j = i + 1; j < rows; j++) {\nfinal double mij = matrix.getEntry(i, j);\nfinal double mji = matrix.getEntry(j, i);\nif (FastMath.abs(mij - mji) >\nreturn true;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(I)V",
            "method_body": "public void setSeed(int seed) {\nlong longMT = seed;\nmt[0]= (int) longMT;\nfor (mti = 1; mti < N; ++mti) {\nlongMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\nmt[mti]= (int) longMT;\nclear(); // Clear normal deviate cache\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:times(Lorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DDZ)V",
            "method_body": "public PointValuePair(final double[] point,\nsuper(copyArray ? ((point == null) ? null :\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sequence(DDD)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sequence(double start, double end, double step) {\nfinal int size = (int) ((end - start) / step + 1);\nfinal double[][] d = new double[size][1];\ndouble value = start;\nfor (int r = 0; r < size; r++) {\nd[r][0] = value;\nvalue += step;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:getUpper()[D",
            "method_body": "public double[] getUpper() {\nreturn upper.clone();\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x == Double.POSITIVE_INFINITY) {\nint exp = (int)(bits >> 52)-1023;\nif ((bits & 0x7ff0000000000000L) == 0) {\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nreturn ya + yb;\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\nif (hiPrec != null) {\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\nif (hiPrec != null) {\nreturn a + b;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof Sigma) {\ninputSigma = ((Sigma) data).getSigma();\ncontinue;\nif (data instanceof PopulationSize) {\nlambda = ((PopulationSize) data).getPopulationSize();\ncontinue;\ncheckParameters();\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:<init>([D[D)V",
            "method_body": "public SimpleBounds(double[] lB,\ndouble[] uB) {\nlower = lB.clone();\nupper = uB.clone();\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemA()D",
            "method_body": "double getRemA() {\nreturn finalRemA;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumnMatrix(I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getColumnMatrix(final int column)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal RealMatrix out = createMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nout.setEntry(i, 0, getEntry(i, column));\nreturn out;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(final int rows, final int columns) {\nreturn (rows * columns <= 4096) ?\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:selectColumns(Lorg/apache/commons/math3/linear/RealMatrix;[I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\nfinal double[][] d = new double[m.getRowDimension()][cols.length];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < cols.length; c++) {\nd[r][c] = m.getEntry(r, cols[c]);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nNullArgumentException {\nif (copyArray) {\nif (d == null) {\nfinal int nRows = d.length;\nif (nRows == 0) {\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\ndata = d;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 119
        }
    ]
}