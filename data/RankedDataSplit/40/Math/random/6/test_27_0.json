{
    "bug_id": 6,
    "test_id": 27,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.testSumSinc",
    "test_body": "public void testSumSinc() {\nfinal MultivariateFunction func = new SumSincFunction(-1);\n54: int dim = 2;\nfinal double[] minPoint = new double[dim];\nfor (int i = 0; i < dim; i++) {\nminPoint[i] = 0;\n}\n60: double[] init = new double[dim];\n62: // Initial is minimum.\nfor (int i = 0; i < dim; i++) {\ninit[i] = minPoint[i];\n}\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);\n68: // Initial is far from minimum.\nfor (int i = 0; i < dim; i++) {\ninit[i] = minPoint[i] + 3;\n}\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);\n// More stringent line search tolerance enhances the precision\n// of the result.\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.doTest(PowellOptimizerTest.java:266)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.testSumSinc(PowellOptimizerTest.java:75)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair:getValue()D",
            "method_body": "public double getValue() {\nreturn value;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BracketFinder:eval(Lorg/apache/commons/math3/analysis/UnivariateFunction;D)D",
            "method_body": "private double eval(UnivariateFunction f, double x) {\nevaluations.incrementCount();\n}\nreturn f.value(x);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:<init>(DD)V",
            "method_body": "public AbstractConvergenceChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nthis.relativeThreshold = relativeThreshold;\nthis.absoluteThreshold = absoluteThreshold;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer:newPointAndDirection([D[DD)[[D",
            "method_body": "private double[][] newPointAndDirection(double[] p,\nfinal int n = p.length;\nfinal double[] nP = new double[n];\nfinal double[] nD = new double[n];\nfor (int i = 0; i < n; i++) {\nnD[i] = d[i] * optimum;\nnP[i] = p[i] + nD[i];\nfinal double[][] result = new double[2][];\nresult[0] = nP;\nresult[1] = nD;\nreturn result;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected UnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer:<init>(DDLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public BrentOptimizer(double rel,\nsuper(checker);\nif (rel < MIN_RELATIVE_TOLERANCE) {\nif (abs <= 0) {\nrelativeThreshold = rel;\nabsoluteThreshold = abs;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:getObjectiveFunction()Lorg/apache/commons/math3/analysis/MultivariateFunction;",
            "method_body": "public MultivariateFunction getObjectiveFunction() {\nreturn function;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\nif (data instanceof MaxIter) {\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getAbsoluteThreshold()D",
            "method_body": "public double getAbsoluteThreshold() {\nreturn absoluteThreshold;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.SearchInterval:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn start;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BracketFinder:getHi()D",
            "method_body": "public double getHi() {\nreturn hi;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.function.Sinc:value(D)D",
            "method_body": "public double value(final double x) {\nfinal double scaledX = normalized ? FastMath.PI * x : x;\nif (FastMath.abs(scaledX) <= SHORTCUT) {\nfinal double scaledX2 = scaledX * scaledX;\nreturn ((scaledX2 - 20) * scaledX2 + 120) / 120;\nreturn FastMath.sin(scaledX) / scaledX;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer:getMax()D",
            "method_body": "public double getMax() {\nreturn max;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair:getPoint()D",
            "method_body": "public double getPoint() {\nreturn point;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\nevaluations.incrementCount();\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer:computeObjectiveValue(D)D",
            "method_body": "protected double computeObjectiveValue(double x) {\nsuper.incrementEvaluationCount();\nreturn function.value(x);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction:getObjectiveFunction()Lorg/apache/commons/math3/analysis/UnivariateFunction;",
            "method_body": "public UnivariateFunction getObjectiveFunction() {\nreturn function;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer:getMin()D",
            "method_body": "public double getMin() {\nreturn min;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BracketFinder:getMid()D",
            "method_body": "public double getMid() {\nreturn mid;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getK()I",
            "method_body": "int getK() {\nreturn finalK;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\ndouble a = 0;\ndouble b = 0;\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nb = b + sintA * cosEpsB + costA * sinEpsB;\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nresult = a + b;\nreturn result;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BracketFinder:<init>(DI)V",
            "method_body": "public BracketFinder(double growLimit,\nint maxEvaluations) {\nif (growLimit <= 0) {\nif (maxEvaluations <= 0) {\nthis.growLimit = growLimit;\nevaluations.setMaximalCount(maxEvaluations);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer:doOptimize()Lorg/apache/commons/math3/optim/univariate/UnivariatePointValuePair;",
            "method_body": "protected UnivariatePointValuePair doOptimize() {\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal double lo = getMin();\nfinal double mid = getStartValue();\nfinal double hi = getMax();\nfinal ConvergenceChecker<UnivariatePointValuePair> checker\nif (lo < hi) {\na = lo;\nb = hi;\ndouble x = mid;\ndouble v = x;\ndouble w = x;\ndouble d = 0;\ndouble e = 0;\ndouble fx = computeObjectiveValue(x);\nif (!isMinim) {\ndouble fv = fx;\ndouble fw = fx;\nUnivariatePointValuePair previous = null;\nUnivariatePointValuePair current\nUnivariatePointValuePair best = current;\nint iter = 0;\nfinal double m = 0.5 * (a + b);\nfinal double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\nfinal double tol2 = 2 * tol1;\nfinal boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\nif (!stop) {\ndouble p = 0;\ndouble q = 0;\ndouble r = 0;\ndouble u = 0;\nif (FastMath.abs(e) > tol1) { // Fit parabola.\nr = (x - w) * (fx - fv);\nq = (x - v) * (fx - fw);\np = (x - v) * q - (x - w) * r;\nq = 2 * (q - r);\nif (q > 0) {\np = -p;\nq = -q;\nr = e;\ne = d;\nif (p > q * (a - x) &&\nd = p / q;\nu = x + d;\nif (u - a < tol2 || b - u < tol2) {\nif (x < m) {\ne = b - x;\ne = a - x;\nd = GOLDEN_SECTION * e;\nif (x < m) {\ne = b - x;\ne = a - x;\nd = GOLDEN_SECTION * e;\nif (FastMath.abs(d) < tol1) {\nu = x + d;\ndouble fu = computeObjectiveValue(u);\nif (!isMinim) {\nprevious = current;\ncurrent = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\nbest = best(best,\nif (checker != null) {\nif (checker.converged(iter, previous, current)) {\nreturn best;\nif (fu <= fx) {\nif (u < x) {\nb = x;\na = x;\nv = w;\nfv = fw;\nw = x;\nfw = fx;\nx = u;\nfx = fu;\nif (u < x) {\na = u;\nb = u;\nif (fu <= fw ||\nv = w;\nfv = fw;\nw = u;\nfw = fu;\n} else { // Default termination (Brent's criterion).\n++iter;\n}\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.SearchInterval:<init>(DDD)V",
            "method_body": "public SearchInterval(double lo,\ndouble init) {\nif (lo >= hi) {\nif (init < lo ||\nlower = lo;\nupper = hi;\nstart = init;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 39
        }
    ]
}