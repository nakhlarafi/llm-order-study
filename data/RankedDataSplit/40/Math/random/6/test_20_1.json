{
    "bug_id": 6,
    "test_id": 20,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testTwoAxes",
    "test_body": "public void testTwoAxes() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new TwoAxes(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testTwoAxes(CMAESOptimizerTest.java:228)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:updateCovariance(ZLorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;[ILorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\ndouble negccov = 0;\nif (ccov1 + ccovmu > 0) {\nfinal RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\nfinal RealMatrix roneu = pc.multiply(pc.transpose())\ndouble oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\noldFac += 1 - ccov1 - ccovmu;\nif (isActiveCMA) {\nnegccov = (1 - ccovmu) * 0.25 * mueff /\nfinal double negminresidualvariance = 0.66;\nfinal double negalphaold = 0.5;\nfinal int[] arReverseIndex = reverse(arindex);\nRealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\nRealMatrix arnorms = sqrt(sumRows(square(arzneg)));\nfinal int[] idxnorms = sortedIndices(arnorms.getRow(0));\nfinal RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\nfinal int[] idxReverse = reverse(idxnorms);\nfinal RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\narnorms = divide(arnormsReverse, arnormsSorted);\nfinal int[] idxInv = inverse(idxnorms);\nfinal RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\nfinal double negcovMax = (1 - negminresidualvariance) /\nif (negccov > negcovMax) {\narzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\nfinal RealMatrix artmp = BD.multiply(arzneg);\nfinal RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\noldFac += negalphaold * negccov;\nC = C.scalarMultiply(oldFac)\n} else {\nupdateBD(negccov);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DDZ)V",
            "method_body": "public PointValuePair(final double[] point,\nsuper(copyArray ? ((point == null) ? null :\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\nreturn p;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:<init>()V",
            "method_body": "public MersenneTwister() {\nmt = new int[N];\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row)\nif (row < 0 ||\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:divide(Lorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumn(I)[D",
            "method_body": "public double[] getColumn(final int column) throws OutOfRangeException {\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal double[] out = new double[nRows];\nfor (int i = 0; i < nRows; ++i) {\nout[i] = getEntry(i, column);\nreturn out;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumnMatrix(I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getColumnMatrix(final int column)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal RealMatrix out = createMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nout.setEntry(i, 0, getEntry(i, column));\nreturn out;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:updateBD(D)V",
            "method_body": "private void updateBD(double negccov) {\nif (ccov1 + ccovmu + negccov > 0 &&\nC = triu(C, 0).add(triu(C, 1).transpose());\nfinal EigenDecomposition eig = new EigenDecomposition(C);\nB = eig.getV(); // eigen decomposition, B==normalized eigenvectors\nD = eig.getD();\ndiagD = diag(D);\nif (min(diagD) <= 0) {\nif (max(diagD) > 1e14 * min(diagD)) {\nfinal double tfac = max(diagD) / 1e14 - min(diagD);\nC = C.add(eye(dimension, dimension).scalarMultiply(tfac));\ndiagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\ndiagC = diag(C);\ndiagD = sqrt(diagD); // D contains standard deviations now\nBD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:selectColumns(Lorg/apache/commons/math3/linear/RealMatrix;[I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\nfinal double[][] d = new double[m.getRowDimension()][cols.length];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < cols.length; c++) {\nd[r][c] = m.getEntry(r, cols[c]);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sumRows(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sumRows(final RealMatrix m) {\nfinal double[][] d = new double[1][m.getColumnDimension()];\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble sum = 0;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nsum += m.getEntry(r, c);\nd[0][c] = sum;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:max(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double max(final RealMatrix m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (max < e) {\nmax = e;\nreturn max;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createColumnRealMatrix([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createColumnRealMatrix(double[] columnData)\nif (columnData == null) {\nfinal int nRows = columnData.length;\nfinal RealMatrix m = createRealMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nm.setEntry(i, 0, columnData[i]);\nreturn m;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getRow(I)[D",
            "method_body": "public double[] getRow(final int row) throws OutOfRangeException {\nMatrixUtils.checkRowIndex(this, row);\nfinal int nCols = getColumnDimension();\nfinal double[] out = new double[nCols];\nfor (int i = 0; i < nCols; ++i) {\nout[i] = getEntry(row, i);\nreturn out;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nparseOptimizationData(optData);\nevaluations.resetCount();\niterations.resetCount();\nreturn doOptimize();\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:max([D)D",
            "method_body": "private static double max(final double[] m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.length; r++) {\nif (max < m[r]) {\nmax = m[r];\nreturn max;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getSecondaryDiagonalRef()[D",
            "method_body": "double[] getSecondaryDiagonalRef() {\nreturn secondary;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:<init>(IDZIILorg/apache/commons/math3/random/RandomGenerator;ZLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public CMAESOptimizer(int maxIterations,\nsuper(checker);\nthis.maxIterations = maxIterations;\nthis.stopFitness = stopFitness;\nthis.isActiveCMA = isActiveCMA;\nthis.diagonalOnly = diagonalOnly;\nthis.checkFeasableCount = checkFeasableCount;\nthis.random = random;\nthis.generateStatistics = generateStatistics;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:<init>(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public TriDiagonalTransformer(RealMatrix matrix) {\nif (!matrix.isSquare()) {\nfinal int m = matrix.getRowDimension();\nhouseholderVectors = matrix.getData();\nmain      = new double[m];\nsecondary = new double[m - 1];\ncachedQ   = null;\ncachedQt  = null;\ncachedT   = null;\ntransform();\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:push([DD)V",
            "method_body": "private static void push(double[] vals, double val) {\nfor (int i = vals.length-1; i > 0; i--) {\nvals[i] = vals[i-1];\nvals[0] = val;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nmaxEval = max;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:nextDouble()D",
            "method_body": "public double nextDouble() {\nfinal long high = ((long) next(26)) << 26;\nfinal int  low  = next(26);\nreturn (high | low) * 0x1.0p-52d;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:<init>(Lorg/apache/commons/math3/analysis/MultivariateFunction;)V",
            "method_body": "public ObjectiveFunction(MultivariateFunction f) {\nfunction = f;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:getGoalType()Lorg/apache/commons/math3/optim/nonlinear/scalar/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(I)V",
            "method_body": "public void setSeed(int seed) {\nlong longMT = seed;\nmt[0]= (int) longMT;\nfor (mti = 1; mti < N; ++mti) {\nlongMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\nmt[mti]= (int) longMT;\nclear(); // Clear normal deviate cache\n}",
            "method_id": 79
        }
    ]
}