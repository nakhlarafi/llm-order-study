{
    "bug_id": 6,
    "test_id": 25,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSsDiffPow",
    "test_body": "public void testSsDiffPow() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new SsDiffPow(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 10, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSsDiffPow(CMAESOptimizerTest.java:303)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:ones(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix ones(int n, int m) {\nfinal double[][] d = new double[n][m];\nfor (int r = 0; r < n; r++) {\nArrays.fill(d[r], 1);\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\nevaluations.incrementCount();\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\nreturn super.optimize(optData);\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getMainDiagonalRef()[D",
            "method_body": "double[] getMainDiagonalRef() {\nreturn main;\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:reverse([I)[I",
            "method_body": "private static int[] reverse(final int[] indices) {\nfinal int[] reverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\nreverse[i] = indices[indices.length - i - 1];\nreturn reverse;\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkAdditionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:inverse([I)[I",
            "method_body": "private static int[] inverse(final int[] indices) {\nfinal int[] inverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\ninverse[indices[i]] = i;\nreturn inverse;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D)D",
            "method_body": "public static double log(final double x) {\nreturn log(x, null);\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:getObjectiveFunction()Lorg/apache/commons/math3/analysis/MultivariateFunction;",
            "method_body": "public MultivariateFunction getObjectiveFunction() {\nreturn function;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQ()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQ() {\nif (cachedQ == null) {\ncachedQ = getQT().transpose();\nreturn cachedQ;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getSecondaryDiagonalRef()[D",
            "method_body": "double[] getSecondaryDiagonalRef() {\nreturn secondary;\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:<init>()V",
            "method_body": "public MersenneTwister() {\nmt = new int[N];\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:initializeCMA([D)V",
            "method_body": "private void initializeCMA(double[] guess) {\nif (lambda <= 0) {\nfinal double[][] sigmaArray = new double[guess.length][1];\nfor (int i = 0; i < guess.length; i++) {\nsigmaArray[i][0] = inputSigma[i];\nfinal RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\nsigma = max(insigma); // overall standard deviation\nstopTolUpX = 1e3 * max(insigma);\nstopTolX = 1e-11 * max(insigma);\nstopTolFun = 1e-12;\nstopTolHistFun = 1e-13;\nmu = lambda / 2; // number of parents/points for recombination\nlogMu2 = Math.log(mu + 0.5);\nweights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);\ndouble sumw = 0;\ndouble sumwq = 0;\nfor (int i = 0; i < mu; i++) {\ndouble w = weights.getEntry(i, 0);\nsumw += w;\nsumwq += w * w;\nweights = weights.scalarMultiply(1 / sumw);\nmueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\ncc = (4 + mueff / dimension) /\ncs = (mueff + 2) / (dimension + mueff + 3.);\ndamps = (1 + 2 * Math.max(0, Math.sqrt((mueff - 1) /\nccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);\nccovmu = Math.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /\nccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3);\nccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);\nchiN = Math.sqrt(dimension) *\nxmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables\ndiagD = insigma.scalarMultiply(1 / sigma);\ndiagC = square(diagD);\npc = zeros(dimension, 1); // evolution paths for C and sigma\nps = zeros(dimension, 1); // B defines the coordinate system\nnormps = ps.getFrobeniusNorm();\nB = eye(dimension, dimension);\nD = ones(dimension, 1); // diagonal D defines the scaling\nBD = times(B, repmat(diagD.transpose(), dimension, 1));\nC = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\nhistorySize = 10 + (int) (3 * 10 * dimension / (double) lambda);\nfitnessHistory = new double[historySize]; // history of fitness values\nfor (int i = 0; i < historySize; i++) {\nfitnessHistory[i] = Double.MAX_VALUE;\n}",
            "method_id": 174
        }
    ]
}