{
    "bug_id": 29,
    "test_id": 1,
    "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingOutputStream",
    "test_body": "324: public void testEncodingOutputStream() throws Exception {\n325: int failed = 0;\n326: for(int i = 1; i <= TESTS.length; i++) {\n327: TestData test = TESTS[i-1];\n328: if (test.hasOutputStream) {\n329: ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n330: final String field = getField(ais, test.fieldName);\n331: if (!eq(test.expectedEncoding, field)) {\n332: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n333: failed++;\n334: }\n335: }\n336: }\n337: if (failed > 0) {\n338: fail(\"Tests failed: \" + failed);\n339: }\n340: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
            "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
            "method_body": "private ZipEncoding zipEncoding =\nprivate boolean useUTF8Flag = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\nprivate boolean hasUsedZip64 = false;\nprivate Zip64Mode zip64Mode = Zip64Mode.AsNeeded;\nprivate final byte[] copyBuffer = new byte[32768];\nprivate final Calendar calendarInstance = Calendar.getInstance();\npublic ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
            "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
            "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthis.isCompressed = isCompressed;\nblockSize = recordSize * recsPerBlock;\nbyte[] oldBuffer = blockBuffer;\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
            "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
            "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\nreturn DumpArchiveConstants.CHECKSUM -\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nbuf.limit(0);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
            "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
            "method_body": "public int getVolume() {\nreturn volume;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
            "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;SILjava/lang/String;)V",
            "method_body": "private final short entryFormat;\nprivate final HashMap<String, CpioArchiveEntry> names =\nprivate long crc = 0;\nprivate long nextArtificalDeviceAndInode = 1;\n* blocksize of {@link CpioConstants#BLOCK_SIZE BLOCK_SIZE} and",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
            "method_body": "private boolean jarMarkerAdded = false;\nsuper(out);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
            "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
            "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>(Ljava/lang/String;Ljava/lang/String;ILorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
            "method_body": "private String name;\nprivate TYPE type = TYPE.UNKNOWN;\nprivate Set<PERMISSION> permissions = Collections.emptySet();\nprivate final DumpArchiveSummary summary = null;\nprivate final TapeSegmentHeader header = new TapeSegmentHeader();\npublic DumpArchiveEntry() {\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
            "method_body": "public CpioArchiveOutputStream(final OutputStream out, String encoding) {\nthis(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
            "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
            "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
            "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
            "method_body": "static StreamCompressor create(OutputStream os, Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
            "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
            "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\nif (-1 == read(result, 0, result.length)) {\nreturn result;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "private long bytesWritten = 0;\nsuper(out);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
            "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
            "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
            "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
            "method_body": "private boolean readFully(byte[] b, int off, int len)\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nreturn true;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
            "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
            "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null) {\nif (out == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\nif (entryEncoding != null) {\nzip.setEncoding(entryEncoding);\nreturn zip;\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveOutputStream(out, entryEncoding);\nreturn new TarArchiveOutputStream(out);\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveOutputStream(out, entryEncoding);\nreturn new CpioArchiveOutputStream(out);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
            "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:<init>(Ljava/util/zip/Deflater;)V",
            "method_body": "StreamCompressor(Deflater deflater) {\nthis.def = deflater;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
            "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}",
            "method_id": 79
        }
    ]
}