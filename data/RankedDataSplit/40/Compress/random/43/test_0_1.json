{
    "bug_id": 43,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries",
    "test_body": "135: public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n136: ByteArrayOutputStream init = new ByteArrayOutputStream();\n137: try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n138: zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n139: zos.write(\"foo\".getBytes(\"UTF-8\"));\n140: zos.closeArchiveEntry();\n141: }\n142: 143: File f = new File(dir, \"test.zip\");\n144: try (FileOutputStream fos = new FileOutputStream(f)) {\n145: fos.write(init.toByteArray());\n146: }\n147: 148: ByteArrayOutputStream o = new ByteArrayOutputStream();\n149: ZipArchiveEntry zae;\n150: try (ZipFile zf = new ZipFile(f);\n151: ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n152: zae = zf.getEntry(\"test1.txt\");\n153: zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n154: }\n155: 156: byte[] data = o.toByteArray();\n157: byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n158: // still 2.0 because of Deflate\n159: assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n160: byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n161: // no DD but EFS flag\n162: assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n163: 164: int cdhStart = findCentralDirectory(data);\n165: byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n166: assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n167: byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n168: assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n169: 170: int ddStart = cdhStart - 16;\n171: assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n172: long crcFromLFH = ZipLong.getValue(data, 14);\n173: long cSizeFromLFH = ZipLong.getValue(data, 18);\n174: long sizeFromLFH = ZipLong.getValue(data, 22);\n175: assertEquals(3, sizeFromLFH);\n176: 177: long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n178: assertEquals(crcFromLFH, crcFromCDH);\n179: long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n180: assertEquals(cSizeFromLFH, cSizeFromCDH);\n181: long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n182: assertEquals(sizeFromLFH, sizeFromCDH);\n183: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:addRawArchiveEntry(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/io/InputStream;)V",
            "method_body": "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\nfinal ZipArchiveEntry ae = new ZipArchiveEntry(entry);\nif (hasZip64Extra(ae)) {\nfinal boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\nputArchiveEntry(ae, is2PhaseSource);\ncopyFromZipInputStream(rawStream);\ncloseCopiedEntry(is2PhaseSource);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:read(JLjava/nio/ByteBuffer;)I",
            "method_body": "protected int read(long pos, ByteBuffer buf) throws IOException {\nint read = archive.read(buf, pos);\nbuf.flip();\nreturn read;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
            "method_body": "public static byte[] getBytes(final int value) {\nfinal byte[] result = new byte[2];\nputShort(value, result, 0);\nreturn result;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
            "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteCounted(EOCD_SIG);\nwriteCounted(ZERO);\nwriteCounted(ZERO);\nfinal int numberOfEntries = entries.size();\nif (numberOfEntries > ZIP64_MAGIC_SHORT\nif (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\nfinal byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\nwriteCounted(num);\nwriteCounted(num);\nwriteCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\nwriteCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\nfinal ByteBuffer data = this.zipEncoding.encode(comment);\nfinal int dataLen = data.limit() - data.position();\nwriteCounted(ZipShort.getBytes(dataLen));\nstreamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$CurrentEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "private final ZipArchiveEntry entry;\nprivate long localDataStart = 0;\nprivate long dataStart = 0;\nprivate long bytesRead = 0;\nprivate boolean causedUseOfZip64 = false;\n* #closeArchiveEntry closeArchiveEntry} will write an empty",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
            "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
            "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthis.size = size;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
            "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal long offset = ze.getLocalHeaderOffset();\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\nze.setDataOffset(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nze.setStreamContiguous(true);\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\nentriesOfThatName.addLast(ze);\n}\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
            "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.position(off);\nreturn found;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif (finished) {\nif (entry != null) {\ncdOffset = streamCompressor.getTotalBytesWritten();\nwriteCentralDirectoryInChunks();\ncdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\nwriteZip64CentralDirectory();\nwriteCentralDirectoryEnd();\nmetaData.clear();\nentries.clear();\nstreamCompressor.close();\nfinished = true;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read([BII)I",
            "method_body": "public synchronized int read(final byte[] b, final int off, int len) throws IOException {\nif (len <= 0) {\nif (len > end-loc) {\nif (loc >= end) {\nif (loc == end && addDummy) {\nreturn -1;\nlen = (int)(end-loc);\nbuf = ByteBuffer.wrap(b, off, len);\nint ret = read(loc, buf);\nif (ret > 0) {\nloc += ret;\nreturn ret;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>()V",
            "method_body": "Entry() {\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
            "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getGeneralPurposeBits(ZZ)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
            "method_body": "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useUTF8ForNames(useUTF8Flag || utfFallback);\nif (usesDataDescriptor) {\nb.useDataDescriptor(true);\nreturn b;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
            "method_body": "public X7875_NewUnix() {\nreset();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
            "method_body": "public byte[] getLocalFileDataExtra() {\nfinal byte[] extra = getExtra();\nreturn extra != null ? extra : EMPTY;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getTotalBytesWritten()J",
            "method_body": "public long getTotalBytesWritten() {\nreturn totalWrittenToOutputStream;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
            "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nreturn (int) ByteUtils.fromLittleEndian(bytes, offset, 2);\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
            "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedFileChannelInputStream(final long start, final long remaining) {\nsuper(start, remaining);\narchive = (FileChannel)ZipFile.this.archive;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getBytesRead()J",
            "method_body": "public long getBytesRead() {\nreturn sourcePayloadLength;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
            "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
            "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
            "method_body": "public int getCode() {\nreturn code;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
            "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/nio/channels/SeekableByteChannel;)V",
            "method_body": "private ZipEncoding zipEncoding =\nprivate boolean useUTF8Flag = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\nprivate boolean hasUsedZip64 = false;\nprivate Zip64Mode zip64Mode = Zip64Mode.AsNeeded;\nprivate final byte[] copyBuffer = new byte[32768];\nprivate final Calendar calendarInstance = Calendar.getInstance();\npublic ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
            "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<clinit>()V",
            "method_body": "public static final ZipShort ID = new ZipShort(0xa11e);\nprivate int padding = 0;\npublic ResourceAlignmentExtraField() {\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
            "method_body": "protected void count(final long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getName(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/nio/ByteBuffer;",
            "method_body": "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\nreturn getEntryEncoding(ze).encode(ze.getName());\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nreturn null;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:validateSizeInformation(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)V",
            "method_body": "private void validateSizeInformation(final Zip64Mode effectiveMode)\nif (entry.entry.getMethod() == STORED && channel == null) {\nif ((entry.entry.getSize() >= ZIP64_MAGIC\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ByteUtils:checkReadLength(I)V",
            "method_body": "private static final void checkReadLength(int length) {\nif (length > 8) {\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
            "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
            "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile",
            "method_id": 79
        }
    ]
}