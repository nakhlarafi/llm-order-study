{
    "bug_id": 25,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry",
    "test_body": "160: public void testReadingOfFirstStoredEntry() throws Exception {\n161: ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n162: 163: try {\n164: ZipArchiveEntry ze = in.getNextZipEntry();\n165: assertEquals(5, ze.getSize());\n166: assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n167: IOUtils.toByteArray(in));\n168: } finally {\n169: in.close();\n170: }\n171: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
            "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nreturn null;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
            "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
            "method_body": "public static final UnparseableExtraField READ\nprivate UnparseableExtraField(int k) {\nkey = k;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
            "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nv.add(ze);\n}\nstart += length + WORD;\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += local.length + WORD;\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
            "method_body": "public AsiExtraField() {\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
            "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(1 +\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nbyte[] data = new byte[getLocalFileDataLength().getValue()];\nint pos = 0;\ndata[pos++] = 0;\nif (bit0_modifyTimePresent) {\ndata[0] |= MODIFY_TIME_BIT;\nSystem.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\npos += 4;\nif (bit1_accessTimePresent && accessTime != null) {\ndata[0] |= ACCESS_TIME_BIT;\nSystem.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\npos += 4;\nif (bit2_createTimePresent && createTime != null) {\nreturn data;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(\nreset();\nfinal int len = offset + length;\nsetFlags(data[offset++]);\nif (bit0_modifyTimePresent) {\nmodifyTime = new ZipLong(data, offset);\noffset += 4;\nif (bit1_accessTimePresent && offset + 4 <= len) {\naccessTime = new ZipLong(data, offset);\noffset += 4;\nif (bit2_createTimePresent && offset + 4 <= len) {\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:reset()V",
            "method_body": "private void reset() {\nsetFlags((byte) 0);\nthis.modifyTime = null;\nthis.accessTime = null;\nthis.createTime = null;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setFlags(B)V",
            "method_body": "public void setFlags(byte flags) {\nthis.flags = flags;\nthis.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\nthis.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\nthis.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
            "method_body": "public X7875_NewUnix() {\nreset();\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\nreturn new ZipShort(3 + uidSize + gidSize);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\nreverse(uidBytes);\nreverse(gidBytes);\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
            "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
            "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\nfinal int MIN_LENGTH = 1;\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
            "method_body": "public JarMarker() {\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
            "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
            "method_body": "protected AbstractUnicodeExtraField() {\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}",
            "method_id": 119
        }
    ]
}