{
    "bug_id": 6,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord",
    "test_body": "public void testToMapWithShortRecord() throws Exception {\nfinal CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\nfinal CSVRecord shortRec = parser.iterator().next();\nshortRec.toMap();\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 2\nat org.apache.commons.csv.CSVRecord.putIn(CSVRecord.java:182)\nat org.apache.commons.csv.CSVRecord.toMap(CSVRecord.java:212)\nat org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord(CSVRecordTest.java:167)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getDelimiter()C",
            "method_body": "public char getDelimiter() {\nreturn delimiter;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withIgnoreSurroundingSpaces(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\nreturn new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:initializeHeader()Ljava/util/Map;",
            "method_body": "private Map<String, Integer> initializeHeader() throws IOException {\nMap<String, Integer> hdrMap = null;\nfinal String[] formatHeader = this.format.getHeader();\nif (formatHeader != null) {\nhdrMap = new LinkedHashMap<String, Integer>();\nString[] header = null;\nif (formatHeader.length == 0) {\nif (this.format.getSkipHeaderRecord()) {\nheader = formatHeader;\nif (header != null) {\nfor (int i = 0; i < header.length; i++) {\nhdrMap.put(header[i], Integer.valueOf(i));\nreturn hdrMap;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getHeader()[Ljava/lang/String;",
            "method_body": "public String[] getHeader() {\nreturn header != null ? header.clone() : null;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreEmptyLines()Z",
            "method_body": "public boolean getIgnoreEmptyLines() {\nreturn ignoreEmptyLines;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:toMap()Ljava/util/Map;",
            "method_body": "public Map<String, String> toMap() {\nreturn putIn(new HashMap<String, String>(values.length));\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:<init>(Ljava/io/Reader;Lorg/apache/commons/csv/CSVFormat;)V",
            "method_body": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\nAssertions.notNull(reader, \"reader\");\nAssertions.notNull(format, \"format\");\nformat.validate();\nthis.format = format;\nthis.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\nthis.headerMap = this.initializeHeader();\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$1:next()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nnext = this.getNextRecord();\nif (next == null) {\nreturn next;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withRecordSeparator(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withRecordSeparator(final char recordSeparator) {\nreturn withRecordSeparator(String.valueOf(recordSeparator));\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getCommentStart()Ljava/lang/Character;",
            "method_body": "public Character getCommentStart() {\nreturn commentStart;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(C)Z",
            "method_body": "private static boolean isLineBreak(final char c) {\nreturn c == LF || c == CR;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<clinit>()V",
            "method_body": "public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\npublic static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\npublic static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\npublic static final CSVFormat TDF =\npublic static final CSVFormat MYSQL =\nreturn c == LF || c == CR;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:nextRecord()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "CSVRecord nextRecord() throws IOException {\nCSVRecord result = null;\nthis.record.clear();\nStringBuilder sb = null;\nthis.reusableToken.reset();\nthis.lexer.nextToken(this.reusableToken);\nswitch (this.reusableToken.type) {\nthis.addRecordValue();\nbreak;\nif (this.reusableToken.isReady) {\nthis.addRecordValue();\n} while (this.reusableToken.type == TOKEN);\nif (!this.record.isEmpty()) {\nthis.recordNumber++;\nfinal String comment = sb == null ? null : sb.toString();\nresult = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\nreturn result;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:iterator()Ljava/util/Iterator;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nnext = this.getNextRecord();\nif (next == null) {\nreturn next;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:read()I",
            "method_body": "public int read() throws IOException {\nfinal int current = super.read();\nif (current == CR || (current == LF && lastChar != CR)) {\nlastChar = current;\nreturn lastChar;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreSurroundingSpaces()Z",
            "method_body": "public boolean getIgnoreSurroundingSpaces() {\nreturn ignoreSurroundingSpaces;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<init>(CLjava/lang/Character;Lorg/apache/commons/csv/Quote;Ljava/lang/Character;Ljava/lang/Character;ZZLjava/lang/String;Ljava/lang/String;[Ljava/lang/String;Z)V",
            "method_body": "CSVFormat(final char delimiter, final Character quoteChar,\nfinal String nullString, final String[] header, final boolean skipHeaderRecord) {\nif (isLineBreak(delimiter)) {\nthis.delimiter = delimiter;\nthis.quoteChar = quoteChar;\nthis.quotePolicy = quotePolicy;\nthis.commentStart = commentStart;\nthis.escape = escape;\nthis.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\nthis.ignoreEmptyLines = ignoreEmptyLines;\nthis.recordSeparator = recordSeparator;\nthis.nullString = nullString;\nthis.header = header == null ? null : header.clone();\nthis.skipHeaderRecord = skipHeaderRecord;\n}",
            "method_id": 56
        }
    ]
}