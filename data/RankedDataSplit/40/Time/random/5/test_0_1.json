{
    "bug_id": 5,
    "test_id": 0,
    "test_name": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_monthsWeeks",
    "test_body": "public void testNormalizedStandard_periodType_monthsWeeks() {\nPeriodType type = PeriodType.forFields(new DurationFieldType[]{\nDurationFieldType.months(),\nDurationFieldType.weeks(),\nDurationFieldType.days()});\nPeriod test = new Period(2, 4, 6, 0, 0, 0, 0, 0);\nPeriod result = test.normalizedStandard(type);\nassertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);",
    "stack_trace": "java.lang.UnsupportedOperationException: Field is not supported\nat org.joda.time.PeriodType.setIndexedField(PeriodType.java:690)\nat org.joda.time.Period.withYears(Period.java:896)\nat org.joda.time.Period.normalizedStandard(Period.java:1631)\nat org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_monthsWeeks(TestPeriod_Basics.java:1557)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
            "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\nreturn type;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.PeriodType:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nreturn iTypes[index];\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nreturn getPeriodType().getFieldType(index);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.Period:getMinutes()I",
            "method_body": "public int getMinutes() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:getValues()[I",
            "method_body": "public int[] getValues() {\nint[] result = new int[size()];\nfor (int i = 0; i < result.length; i++) {\nresult[i] = getValue(i);\nreturn result;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.Period:withYears(I)Lorg/joda/time/Period;",
            "method_body": "public Period withYears(int years) {\nint[] values = getValues();  // cloned\ngetPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\nreturn new Period(values, getPeriodType());\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
            "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.Period:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "public Period(long duration, PeriodType type, Chronology chronology) {\nsuper(duration, type, chronology);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:getValue(I)I",
            "method_body": "public int getValue(int index) {\nreturn iValues[index];\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
            "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.Period:normalizedStandard(Lorg/joda/time/PeriodType;)Lorg/joda/time/Period;",
            "method_body": "public Period normalizedStandard(PeriodType type) {\ntype = DateTimeUtils.getPeriodType(type);\nlong millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\nmillis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\nmillis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\nmillis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\nmillis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\nmillis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\nPeriod result = new Period(millis, type, ISOChronology.getInstanceUTC());\nint years = getYears();\nint months = getMonths();\nif (years != 0 || months != 0) {\nyears = FieldUtils.safeAdd(years, months / 12);\nmonths = months % 12;\nif (years != 0) {\nresult = result.withYears(years);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:getDifferenceAsLong(JJ)J",
            "method_body": "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\nlong difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\nreturn difference / iUnitMillis;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisSystem()V",
            "method_body": "public static final void setCurrentMillisSystem() throws SecurityException {\ncheckPermission();\ncMillisProvider = SYSTEM_MILLIS_PROVIDER;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nreturn zone;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:months()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField months() {\nreturn iMonths;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.Period:getMillis()I",
            "method_body": "public int getMillis() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setPeriodInternal(IIIIIIII)[I",
            "method_body": "private int[] setPeriodInternal(int years, int months, int weeks, int days,\nint[] newValues = new int[size()];\ncheckAndUpdate(DurationFieldType.years(), newValues, years);\ncheckAndUpdate(DurationFieldType.months(), newValues, months);\ncheckAndUpdate(DurationFieldType.weeks(), newValues, weeks);\ncheckAndUpdate(DurationFieldType.days(), newValues, days);\ncheckAndUpdate(DurationFieldType.hours(), newValues, hours);\ncheckAndUpdate(DurationFieldType.minutes(), newValues, minutes);\ncheckAndUpdate(DurationFieldType.seconds(), newValues, seconds);\ncheckAndUpdate(DurationFieldType.millis(), newValues, millis);\nreturn newValues;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeToInt(J)I",
            "method_body": "public static int safeToInt(long value) {\nif (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\nreturn (int) value;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:getPeriodType()Lorg/joda/time/PeriodType;",
            "method_body": "public PeriodType getPeriodType() {\nreturn iType;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.joda.time.PeriodType:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "public int indexOf(DurationFieldType type) {\nfor (int i = 0, isize = size(); i < isize; i++) {\nif (iTypes[i] == type) {\nreturn i;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeSubtract(JJ)J",
            "method_body": "public static long safeSubtract(long val1, long val2) {\nlong diff = val1 - val2;\nif ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\nreturn diff;\n}",
            "method_id": 66
        }
    ]
}