{
    "bug_id": 13,
    "test_id": 1,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest.testWinzipBackSlashWorkaround",
    "test_body": "145: public void testWinzipBackSlashWorkaround() throws Exception {\n146: URL zip = getClass().getResource(\"/test-winzip.zip\");\n147: File archive = new File(new URI(zip.toString()));\n148: zf = new ZipFile(archive);\n149: assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n150: assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n151: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
            "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nZip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
            "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
            "method_body": "private void positionAtCentralDirectory()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nif (!found) {\npositionAtCentralDirectory32();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
            "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
            "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length < 5) {\nint version = buffer[offset];\nif (version != 0x01) {\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
            "method_body": "public int getValue() {\nreturn value;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
            "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
            "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
            "method_body": "public ZipArchiveEntry getEntry(String name) {\nreturn nameMap.get(name);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nze.parseFromCentralDirectoryData(data, start + WORD,\nv.add(ze);\n}\nstart += (length + WORD);\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
            "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
            "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.seek(off);\nreturn found;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
            "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
            "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
            "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
            "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
            "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}.",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
            "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
            "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
            "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
            "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}",
            "method_id": 29
        }
    ]
}