{
    "bug_id": 3,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.ArchiveOutputStreamTest.testFinish",
    "test_body": "24: public void testFinish() throws Exception {\n25: OutputStream out1 = new ByteArrayOutputStream();\n26: 27: ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n28: aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n29: try {\n30: aos1.finish();\n31: fail(\"After putArchive should follow closeArchive\");\n32: } catch (IOException io) {\n33: // Exception expected\n34: }\n35: 36: aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n37: aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n38: try {\n39: aos1.finish();\n40: fail(\"After putArchive should follow closeArchive\");\n41: } catch (IOException io) {\n42: // Exception expected\n43: }\n44: 45: aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n46: aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n47: try {\n48: aos1.finish();\n49: fail(\"After putArchive should follow closeArchive\");\n50: } catch (IOException io) {\n51: // Exception expected\n52: }\n53: 54: aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n55: aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n56: try {\n57: aos1.finish();\n58: fail(\"After putArchive should follow closeArchive\");\n59: } catch (IOException io) {\n60: // Exception expected\n61: }\n62: 63: aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n64: aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n65: try {\n66: aos1.finish();\n67: fail(\"After putArchive should follow closeArchive\");\n68: } catch (IOException io) {\n69: // Exception expected\n70: }\n71: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getTime()J",
            "method_body": "public long getTime() {\nreturn this.mtime;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
            "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeAsciiLong(JII)V",
            "method_body": "private void writeAsciiLong(final long number, final int length,\nStringBuffer tmp = new StringBuffer();\nif (radix == 16) {\ntmp.append(Long.toHexString(number));\nif (tmp.length() <= length) {\nlong insertLength = length - tmp.length();\nfor (int pos = 0; pos < insertLength; pos++) {\ntmp.insert(0, \"0\");\ntmpStr = tmp.toString();\n} else {\nout.write(tmpStr.getBytes()); // TODO is it correct to use the default charset here?\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
            "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\nint csOffset = offset;\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\nlong chk = TarUtils.computeCheckSum(outbuf);\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getGID()J",
            "method_body": "public long getGID() {\nreturn this.gid;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
            "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\nreturn sum;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
            "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\ncurrBytes = 0;\nif (entry.isDirectory()) {\ncurrSize = entry.getSize();\ncurrName = entry.getName();\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
            "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
            "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLastModified()J",
            "method_body": "public long getLastModified() {\nreturn lastModified;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getUserId()I",
            "method_body": "public int getUserId() {\nreturn userId;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
            "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\nbuffer.writeRecord(recordBuf);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
            "method_body": "public void putArchiveEntry(ArchiveEntry ze) throws IOException {\nif (!jarMarkerAdded) {\n((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\njarMarkerAdded = true;\nsuper.putArchiveEntry(ze);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;JIIIJ)V",
            "method_body": "public ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {\nthis.name = name;\nthis.length = length;\nthis.userId = userId;\nthis.groupId = groupId;\nthis.mode = mode;\nthis.lastModified = lastModified;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif(haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([BII)V",
            "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\nentryOffset += len;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
            "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nreturn NULL;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn this.filesize;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
            "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
            "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null || out == null) {\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLength()J",
            "method_body": "public long getLength() {\nreturn length;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 59
        }
    ]
}