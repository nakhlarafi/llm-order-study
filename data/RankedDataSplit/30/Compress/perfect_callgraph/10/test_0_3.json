{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive",
    "test_body": "126: public void testReadWinZipArchive() throws IOException, URISyntaxException {\n127: URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n128: File archive = new File(new URI(zip.toString()));\n129: ZipFile zf = null;\n130: try {\n131: zf = new ZipFile(archive, null, true);\n132: assertCanRead(zf, ASCII_TXT);\n133: assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n134: assertCanRead(zf, OIL_BARREL_TXT);\n135: } finally {\n136: ZipFile.closeQuietly(zf);\n137: }\n138: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromCentralDirectoryData([BII)V",
            "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nparseFromLocalFileData(buffer, offset, length);\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
            "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
            "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
            "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\nif (!success) {\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
            "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
            "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\nzipfile.close();\n}\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
            "method_body": "public InputStream getInputStream(ZipArchiveEntry ze)\nOffsetEntry offsetEntry = entries.get(ze);\nif (offsetEntry == null) {\nreturn null;\nZipUtil.checkRequestedFeatures(ze);\nlong start = offsetEntry.dataOffset;\nBoundedInputStream bis =\nswitch (ze.getMethod()) {\nreturn bis;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
            "method_body": "private void\nbyte[] cfh = new byte[CFH_LEN];\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\noff += SHORT; // skip version info\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint diskStart = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\nentries.put(ze, offset);\nnameMap.put(ze.getName(), ze);\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
            "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nZip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
            "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$NameAndComment:<init>([B[B)V",
            "method_body": "private NameAndComment(byte[] name, byte[] comment) {\nthis.name = name;\nthis.comment = comment;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
            "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
            "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
            "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
            "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedInputStream(long start, long remaining) {\nthis.remaining = remaining;\nloc = start;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read()I",
            "method_body": "public int read() throws IOException {\nif (remaining-- <= 0) {\nsynchronized (archive) {\narchive.seek(loc++);\nreturn archive.read();\n}",
            "method_id": 116
        }
    ]
}