{
    "bug_id": 6,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([DZ)V",
            "method_body": "public ArrayRealVector(double[] d, boolean copyArray)\nthrows NullArgumentException {\nif (d == null) {\ndata = copyArray ? d.clone() :  d;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeCost([D)D",
            "method_body": "protected double computeCost(double[] residuals) {\nfinal ArrayRealVector r = new ArrayRealVector(residuals);\nreturn FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data)\nif (data == null ||\nreturn (data.length * data[0].length <= 4096) ?\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[DZ)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nsuper(copyArray ?\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:computeJacobian([D)[[D",
            "method_body": "protected double[][] computeJacobian(final double[] params) {\nreturn jacobian.value(params);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeResiduals([D)[D",
            "method_body": "protected double[] computeResiduals(double[] objectiveValue) {\nfinal double[] target = getTarget();\nif (objectiveValue.length != target.length) {\nfinal double[] residuals = new double[target.length];\nfor (int i = 0; i < target.length; i++) {\nresiduals[i] = target[i] - objectiveValue[i];\nreturn residuals;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:getWeightSquareRoot()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeightSquareRoot() {\nreturn weightMatrixSqrt.copy();\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Target:<init>([D)V",
            "method_body": "public Target(double[] observations) {\ntarget = observations.clone();\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row)\nif (row < 0 ||\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[D)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nthis(point, value, true);\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:checkVectorDimensions(I)V",
            "method_body": "protected void checkVectorDimensions(int n)\nif (data.length != n) {\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction:getModelFunction()Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;",
            "method_body": "public MultivariateVectorFunction getModelFunction() {\nreturn model;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:multiply(Lorg/apache/commons/math3/linear/DiagonalMatrix;)Lorg/apache/commons/math3/linear/DiagonalMatrix;",
            "method_body": "public DiagonalMatrix multiply(final DiagonalMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int dim = getRowDimension();\nfinal double[] outData = new double[dim];\nfor (int i = 0; i < dim; i++) {\noutData[i] = data[i] * m.data[i];\nreturn new DiagonalMatrix(outData, false);\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:squareRoot(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix squareRoot(RealMatrix m) {\nif (m instanceof DiagonalMatrix) {\nfinal int dim = m.getRowDimension();\nfinal RealMatrix sqrtM = new DiagonalMatrix(dim);\nfor (int i = 0; i < dim; i++) {\nsqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\nreturn sqrtM;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMDirection([D[D[D[D)V",
            "method_body": "private void determineLMDirection(double[] qy, double[] diag,\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nfor (int i = j + 1; i < solvedCols; ++i) {\nlmDir[j] = diagR[pj];\nwork[j]  = qy[j];\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dpj = diag[pj];\nif (dpj != 0) {\nArrays.fill(lmDiag, j + 1, lmDiag.length, 0);\nlmDiag[j] = dpj;\ndouble qtbpj = 0;\nfor (int k = j; k < solvedCols; ++k) {\nint pk = permutation[k];\nif (lmDiag[k] != 0) {\ndouble rkk = weightedJacobian[k][pk];\nif (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\nfinal double cotan = rkk / lmDiag[k];\nsin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\ncos   = sin * cotan;\n} else {\nweightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\nfinal double temp = cos * work[k] + sin * qtbpj;\nqtbpj = -sin * work[k] + cos * qtbpj;\nwork[k] = temp;\nfor (int i = k + 1; i < solvedCols; ++i) {\nlmDiag[j] = weightedJacobian[j][permutation[j]];\nweightedJacobian[j][permutation[j]] = lmDir[j];\nint nSing = solvedCols;\nfor (int j = 0; j < solvedCols; ++j) {\nif ((lmDiag[j] == 0) && (nSing == solvedCols)) {\nif (nSing < solvedCols) {\nif (nSing > 0) {\nfor (int j = nSing - 1; j >= 0; --j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = j + 1; i < nSing; ++i) {\nwork[j] = (work[j] - sum) / lmDiag[j];\nfor (int j = 0; j < lmDir.length; ++j) {\nlmDir[permutation[j]] = work[j];\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\nevaluations.incrementCount();\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getDataRef()[D",
            "method_body": "public double[] getDataRef() {\nreturn data;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\nif (a < b) {\nreturn b;\nif (a != b) {\nreturn Double.NaN;\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\nif (data instanceof MaxIter) {\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\nif (a < b) {\nreturn a;\nif (a != b) {\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:getTarget()[D",
            "method_body": "public double[] getTarget() {\nreturn target.clone();\n}",
            "method_id": 89
        }
    ]
}