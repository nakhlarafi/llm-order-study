{
    "bug_id": 6,
    "test_id": 6,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testElliRotated",
    "test_body": "public void testElliRotated() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new ElliRotated(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testElliRotated(CMAESOptimizerTest.java:183)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:getPopulationSize()I",
            "method_body": "public int getPopulationSize() {\nreturn lambda;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:start(IIIIII)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:unbounded(I)Lorg/apache/commons/math3/optim/SimpleBounds;",
            "method_body": "public static SimpleBounds unbounded(int dim) {\nfinal double[] lB = new double[dim];\nArrays.fill(lB, Double.NEGATIVE_INFINITY);\nfinal double[] uB = new double[dim];\nArrays.fill(uB, Double.POSITIVE_INFINITY);\nreturn new SimpleBounds(lB, uB);\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getValue()Ljava/lang/Object;",
            "method_body": "public V getValue() {\nreturn value;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:square(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix square(final RealMatrix m) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nd[r][c] = e * e;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nfinal double[] hK = householderVectors[k - 1];\nqta[k][k] = 1;\nif (hK[k] != 0.0) {\nfinal double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = 1.0 / secondary[k - 1];\nqta[k][k] = 1 + beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[k][i] = beta * hK[i];\nfor (int j = k + 1; j < m; ++j) {\nbeta = 0;\nfor (int i = k + 1; i < m; ++i) {\nbeta += qta[j][i] * hK[i];\nbeta *= inv;\nqta[j][k] = beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[j][i] += beta * hK[i];\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:eye(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix eye(int n, int m) {\nfinal double[][] d = new double[n][m];\nfor (int r = 0; r < n; r++) {\nif (r < m) {\nd[r][r] = 1;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:<init>(DI)V",
            "method_body": "DoubleIndex(double value, int index) {\nthis.value = value;\nthis.index = index;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:<init>(I)V",
            "method_body": "public PopulationSize(int size)\nthrows NotStrictlyPositiveException {\nif (size <= 0) {\nlambda = size;\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:min([D)D",
            "method_body": "private static double min(final double[] m) {\ndouble min = Double.MAX_VALUE;\nfor (int r = 0; r < m.length; r++) {\nif (min > m[r]) {\nmin = m[r];\nreturn min;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:updateCovariance(ZLorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;[ILorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\ndouble negccov = 0;\nif (ccov1 + ccovmu > 0) {\nfinal RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\nfinal RealMatrix roneu = pc.multiply(pc.transpose())\ndouble oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\noldFac += 1 - ccov1 - ccovmu;\nif (isActiveCMA) {\nnegccov = (1 - ccovmu) * 0.25 * mueff /\nfinal double negminresidualvariance = 0.66;\nfinal double negalphaold = 0.5;\nfinal int[] arReverseIndex = reverse(arindex);\nRealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\nRealMatrix arnorms = sqrt(sumRows(square(arzneg)));\nfinal int[] idxnorms = sortedIndices(arnorms.getRow(0));\nfinal RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\nfinal int[] idxReverse = reverse(idxnorms);\nfinal RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\narnorms = divide(arnormsReverse, arnormsSorted);\nfinal int[] idxInv = inverse(idxnorms);\nfinal RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\nfinal double negcovMax = (1 - negminresidualvariance) /\nif (negccov > negcovMax) {\narzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\nfinal RealMatrix artmp = BD.multiply(arzneg);\nfinal RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\noldFac += negalphaold * negccov;\nC = C.scalarMultiply(oldFac)\n} else {\nupdateBD(negccov);\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:repair([D)[D",
            "method_body": "private double[] repair(final double[] x) {\nfinal double[] lB = CMAESOptimizer.this.getLowerBound();\nfinal double[] uB = CMAESOptimizer.this.getUpperBound();\nfinal double[] repaired = new double[x.length];\nfor (int i = 0; i < x.length; i++) {\nif (x[i] < lB[i]) {\n} else if (x[i] > uB[i]) {\nrepaired[i] = x[i];\nreturn repaired;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\ndouble x2 = x*x;\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\np = p * x2 * x;\nreturn p;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:inverse([I)[I",
            "method_body": "private static int[] inverse(final int[] indices) {\nfinal int[] inverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\ninverse[indices[i]] = i;\nreturn inverse;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 149
        }
    ]
}