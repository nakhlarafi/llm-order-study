{
    "bug_id": 6,
    "test_id": 16,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigTab",
    "test_body": "public void testCigTab() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.3);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new CigTab(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigTab(CMAESOptimizerTest.java:243)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getV()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getV() {\nif (cachedV == null) {\nfinal int m = eigenvectors.length;\ncachedV = MatrixUtils.createRealMatrix(m, m);\nfor (int k = 0; k < m; ++k) {\ncachedV.setColumnVector(k, eigenvectors[k]);\nreturn cachedV;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\ndouble a = 0;\ndouble b = 0;\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nb = b + sintA * cosEpsB + costA * sinEpsB;\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nresult = a + b;\nreturn result;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nmaxEval = max;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:nextGaussian()D",
            "method_body": "public double nextGaussian() {\nif (Double.isNaN(nextGaussian)) {\nfinal double x = nextDouble();\nfinal double y = nextDouble();\nfinal double alpha = 2 * FastMath.PI * x;\nfinal double r      = FastMath.sqrt(-2 * FastMath.log(y));\nrandom       = r * FastMath.cos(alpha);\nnextGaussian = r * FastMath.sin(alpha);\n} else {\nrandom = nextGaussian;\nnextGaussian = Double.NaN;\nreturn random;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sequence(DDD)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sequence(double start, double end, double step) {\nfinal int size = (int) ((end - start) / step + 1);\nfinal double[][] d = new double[size][1];\ndouble value = start;\nfor (int r = 0; r < size; r++) {\nd[r][0] = value;\nvalue += step;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:start(IIIIII)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleBounds:getUpper()[D",
            "method_body": "public double[] getUpper() {\nreturn upper.clone();\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:transpose()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumnVector(ILorg/apache/commons/math3/linear/RealVector;)V",
            "method_body": "public void setColumnVector(final int column, final RealVector vector)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (vector.getDimension() != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, vector.getEntry(i));\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(I)V",
            "method_body": "public void setSeed(int seed) {\nlong longMT = seed;\nmt[0]= (int) longMT;\nfor (mti = 1; mti < N; ++mti) {\nlongMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\nmt[mti]= (int) longMT;\nclear(); // Clear normal deviate cache\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:<init>(IDZIILorg/apache/commons/math3/random/RandomGenerator;ZLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public CMAESOptimizer(int maxIterations,\nsuper(checker);\nthis.maxIterations = maxIterations;\nthis.stopFitness = stopFitness;\nthis.isActiveCMA = isActiveCMA;\nthis.diagonalOnly = diagonalOnly;\nthis.checkFeasableCount = checkFeasableCount;\nthis.random = random;\nthis.generateStatistics = generateStatistics;\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([II)[I",
            "method_body": "public static int[] copyOf(int[] source, int len) {\nfinal int[] output = new int[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nfinal double[] hK = householderVectors[k - 1];\nqta[k][k] = 1;\nif (hK[k] != 0.0) {\nfinal double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = 1.0 / secondary[k - 1];\nqta[k][k] = 1 + beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[k][i] = beta * hK[i];\nfor (int j = k + 1; j < m; ++j) {\nbeta = 0;\nfor (int i = k + 1; i < m; ++i) {\nbeta += qta[j][i] * hK[i];\nbeta *= inv;\nqta[j][k] = beta * hK[k];\nfor (int i = k + 1; i < m; ++i) {\nqta[j][i] += beta * hK[i];\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x == Double.POSITIVE_INFINITY) {\nint exp = (int)(bits >> 52)-1023;\nif ((bits & 0x7ff0000000000000L) == 0) {\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nreturn ya + yb;\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\nif (hiPrec != null) {\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\nif (hiPrec != null) {\nreturn a + b;\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDD)Z",
            "method_body": "public static boolean equals(double x, double y, double eps) {\nreturn equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarMultiply(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarMultiply(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) * d);\nreturn out;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:max(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double max(final RealMatrix m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (max < e) {\nmax = e;\nreturn max;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:reverse([I)[I",
            "method_body": "private static int[] reverse(final int[] indices) {\nfinal int[] reverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\nreverse[i] = indices[indices.length - i - 1];\nreturn reverse;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public EigenDecomposition(final RealMatrix matrix)\nthrows MathArithmeticException {\nfinal double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\nisSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\nif (isSymmetric) {\ntransformToTridiagonal(matrix);\nfindEigenVectors(transformer.getQ().getData());\n}",
            "method_id": 149
        }
    ]
}