{
    "bug_id": 6,
    "test_id": 16,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigTab",
    "test_body": "public void testCigTab() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.3);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new CigTab(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigTab(CMAESOptimizerTest.java:243)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nif (upperBound != null) {\nif (upperBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof InitialGuess) {\nstart = ((InitialGuess) data).getInitialGuess();\ncontinue;\nif (data instanceof SimpleBounds) {\nfinal SimpleBounds bounds = (SimpleBounds) data;\nlowerBound = bounds.getLower();\nupperBound = bounds.getUpper();\ncontinue;\ncheckParameters();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkSubtractionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer;)V",
            "method_body": "public FitnessFunction() {\nvalueRange = 1;\nisRepairMode = true;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex:compareTo(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer$DoubleIndex;)I",
            "method_body": "public int compareTo(DoubleIndex o) {\nreturn Double.compare(value, o.value);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column)\nif (column < 0 || column >= m.getColumnDimension()) {\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nif (left.getColumnDimension() != right.getRowDimension()) {\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getEntry(I)D",
            "method_body": "public double getEntry(int index) throws OutOfRangeException {\nreturn data[index];\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:compareTo(DDD)I",
            "method_body": "public static int compareTo(double x, double y, double eps) {\nif (equals(x, y, eps)) {\nreturn 0;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sqrt(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sqrt(final RealMatrix m) {\nfinal double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = Math.sqrt(m.getEntry(r, c));\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:initializeCMA([D)V",
            "method_body": "private void initializeCMA(double[] guess) {\nif (lambda <= 0) {\nfinal double[][] sigmaArray = new double[guess.length][1];\nfor (int i = 0; i < guess.length; i++) {\nsigmaArray[i][0] = inputSigma[i];\nfinal RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\nsigma = max(insigma); // overall standard deviation\nstopTolUpX = 1e3 * max(insigma);\nstopTolX = 1e-11 * max(insigma);\nstopTolFun = 1e-12;\nstopTolHistFun = 1e-13;\nmu = lambda / 2; // number of parents/points for recombination\nlogMu2 = Math.log(mu + 0.5);\nweights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);\ndouble sumw = 0;\ndouble sumwq = 0;\nfor (int i = 0; i < mu; i++) {\ndouble w = weights.getEntry(i, 0);\nsumw += w;\nsumwq += w * w;\nweights = weights.scalarMultiply(1 / sumw);\nmueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\ncc = (4 + mueff / dimension) /\ncs = (mueff + 2) / (dimension + mueff + 3.);\ndamps = (1 + 2 * Math.max(0, Math.sqrt((mueff - 1) /\nccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);\nccovmu = Math.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /\nccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3);\nccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);\nchiN = Math.sqrt(dimension) *\nxmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables\ndiagD = insigma.scalarMultiply(1 / sigma);\ndiagC = square(diagD);\npc = zeros(dimension, 1); // evolution paths for C and sigma\nps = zeros(dimension, 1); // B defines the coordinate system\nnormps = ps.getFrobeniusNorm();\nB = eye(dimension, dimension);\nD = ones(dimension, 1); // diagonal D defines the scaling\nBD = times(B, repmat(diagD.transpose(), dimension, 1));\nC = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\nhistorySize = 10 + (int) (3 * 10 * dimension / (double) lambda);\nfitnessHistory = new double[historySize]; // history of fitness values\nfor (int i = 0; i < historySize; i++) {\nfitnessHistory[i] = Double.MAX_VALUE;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:min(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double min(final RealMatrix m) {\ndouble min = Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (min > e) {\nmin = e;\nreturn min;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getSecondaryDiagonalRef()[D",
            "method_body": "double[] getSecondaryDiagonalRef() {\nreturn secondary;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumnMatrix(I)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getColumnMatrix(final int column)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal RealMatrix out = createMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nout.setEntry(i, 0, getEntry(i, column));\nreturn out;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif (data instanceof GoalType) {\ngoal = (GoalType) data;\ncontinue;\nif (data instanceof ObjectiveFunction) {\nfunction = ((ObjectiveFunction) data).getObjectiveFunction();\ncontinue;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D)D",
            "method_body": "public static double log(final double x) {\nreturn log(x, null);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sumRows(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sumRows(final RealMatrix m) {\nfinal double[][] d = new double[1][m.getColumnDimension()];\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble sum = 0;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nsum += m.getEntry(r, c);\nd[0][c] = sum;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:value([D)D",
            "method_body": "public double value(final double[] point) {\nif (isRepairMode) {\ndouble[] repaired = repair(point);\nvalue = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n} else {\nreturn isMinimize ? value : -value;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nfinal double[] init = getStartPoint();\nfinal double[] lB = getLowerBound();\nfinal double[] uB = getUpperBound();\nif (inputSigma != null) {\nif (inputSigma.length != init.length) {\nfor (int i = 0; i < init.length; i++) {\nif (inputSigma[i] > uB[i] - lB[i]) {\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\nif (data instanceof MaxIter) {\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\ndouble x2 = x*x;\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\np = p * x2 * x;\nreturn p;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:<init>()V",
            "method_body": "public MersenneTwister() {\nmt = new int[N];\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}",
            "method_id": 29
        }
    ]
}