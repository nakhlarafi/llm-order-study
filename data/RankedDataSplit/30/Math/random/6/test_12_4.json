{
    "bug_id": 6,
    "test_id": 12,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testAckley",
    "test_body": "public void testAckley() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,1.0);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new Ackley(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testAckley(CMAESOptimizerTest.java:318)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\nisMinimize = getGoalType().equals(GoalType.MINIMIZE);\nfinal FitnessFunction fitfun = new FitnessFunction();\nfinal double[] guess = getStartPoint();\ndimension = guess.length;\ninitializeCMA(guess);\niterations = 0;\ndouble bestValue = fitfun.value(guess);\npush(fitnessHistory, bestValue);\nPointValuePair optimum\nPointValuePair lastResult = null;\nfor (iterations = 1; iterations <= maxIterations; iterations++) {\nfinal RealMatrix arz = randn1(dimension, lambda);\nfinal RealMatrix arx = zeros(dimension, lambda);\nfinal double[] fitness = new double[lambda];\nfor (int k = 0; k < lambda; k++) {\nRealMatrix arxk = null;\nfor (int i = 0; i < checkFeasableCount + 1; i++) {\nif (diagonalOnly <= 0) {\narxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\narxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\nif (i >= checkFeasableCount ||\ncopyColumn(arxk, 0, arx, k);\nfitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n}\nfinal int[] arindex = sortedIndices(fitness);\nfinal RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\nfinal RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\nxmean = bestArx.multiply(weights);\nfinal RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\nfinal RealMatrix zmean = bestArz.multiply(weights);\nfinal boolean hsig = updateEvolutionPaths(zmean, xold);\nif (diagonalOnly <= 0) {\nupdateCovariance(hsig, bestArx, arz, arindex, xold);\nupdateCovarianceDiagonalOnly(hsig, bestArz);\nsigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\nfinal double bestFitness = fitness[arindex[0]];\nfinal double worstFitness = fitness[arindex[arindex.length - 1]];\nif (bestValue > bestFitness) {\nbestValue = bestFitness;\nlastResult = optimum;\noptimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\nif (getConvergenceChecker() != null &&\nif (stopFitness != 0) { // only if stopFitness is defined\nif (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\nbreak generationLoop;\nfinal double[] sqrtDiagC = sqrt(diagC).getColumn(0);\nfinal double[] pcCol = pc.getColumn(0);\nfor (int i = 0; i < dimension; i++) {\nif (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\nbreak;\nif (i >= dimension - 1) {\nbreak generationLoop;\nfor (int i = 0; i < dimension; i++) {\nif (sigma * sqrtDiagC[i] > stopTolUpX) {\nfinal double historyBest = min(fitnessHistory);\nfinal double historyWorst = max(fitnessHistory);\nif (iterations > 2 &&\nbreak generationLoop;\nif (iterations > fitnessHistory.length &&\nif (max(diagD) / min(diagD) > 1e7) {\nbreak generationLoop;\nif (getConvergenceChecker() != null) {\nif (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\nif (iterations > 2 && Math.max(historyWorst, bestFitness) -\npush(fitnessHistory,bestFitness);\nfitfun.setValueRange(worstFitness-bestFitness);\nif (generateStatistics) {\nreturn optimum;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer;)V",
            "method_body": "public FitnessFunction() {\nvalueRange = 1;\nisRepairMode = true;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column)\nif (column < 0 || column >= m.getColumnDimension()) {\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nfinal double[] init = getStartPoint();\nfinal double[] lB = getLowerBound();\nfinal double[] uB = getUpperBound();\nif (inputSigma != null) {\nif (inputSigma.length != init.length) {\nfor (int i = 0; i < init.length; i++) {\nif (inputSigma[i] > uB[i] - lB[i]) {\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:transform()V",
            "method_body": "private void transform() {\nfinal int m = householderVectors.length;\nfinal double[] z = new double[m];\nfor (int k = 0; k < m - 1; k++) {\nfinal double[] hK = householderVectors[k];\nmain[k] = hK[k];\ndouble xNormSqr = 0;\nfor (int j = k + 1; j < m; ++j) {\nfinal double c = hK[j];\nxNormSqr += c * c;\nfinal double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\nsecondary[k] = a;\nif (a != 0.0) {\nhK[k + 1] -= a;\nfinal double beta = -1 / (a * hK[k + 1]);\nArrays.fill(z, k + 1, m, 0);\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfinal double hKI = hK[i];\ndouble zI = hI[i] * hKI;\nfor (int j = i + 1; j < m; ++j) {\nfinal double hIJ = hI[j];\nzI   += hIJ * hK[j];\nz[j] += hIJ * hKI;\nz[i] = beta * (z[i] + zI);\ndouble gamma = 0;\nfor (int i = k + 1; i < m; ++i) {\ngamma += z[i] * hK[i];\ngamma *= beta / 2;\nfor (int i = k + 1; i < m; ++i) {\nz[i] -= gamma * hK[i];\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfor (int j = i; j < m; ++j) {\nhI[j] -= hK[i] * z[j] + z[i] * hK[j];\nmain[m - 1] = householderVectors[m - 1][m - 1];\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetricInternal(Lorg/apache/commons/math3/linear/RealMatrix;DZ)Z",
            "method_body": "private static boolean isSymmetricInternal(RealMatrix matrix,\nfinal int rows = matrix.getRowDimension();\nif (rows != matrix.getColumnDimension()) {\nfor (int i = 0; i < rows; i++) {\nfor (int j = i + 1; j < rows; j++) {\nfinal double mij = matrix.getEntry(i, j);\nfinal double mji = matrix.getEntry(j, i);\nif (FastMath.abs(mij - mji) >\nreturn true;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sequence(DDD)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sequence(double start, double end, double step) {\nfinal int size = (int) ((end - start) / step + 1);\nfinal double[][] d = new double[size][1];\ndouble value = start;\nfor (int r = 0; r < size; r++) {\nd[r][0] = value;\nvalue += step;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:<init>(IDZIILorg/apache/commons/math3/random/RandomGenerator;ZLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public CMAESOptimizer(int maxIterations,\nsuper(checker);\nthis.maxIterations = maxIterations;\nthis.stopFitness = stopFitness;\nthis.isActiveCMA = isActiveCMA;\nthis.diagonalOnly = diagonalOnly;\nthis.checkFeasableCount = checkFeasableCount;\nthis.random = random;\nthis.generateStatistics = generateStatistics;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction:repair([D)[D",
            "method_body": "private double[] repair(final double[] x) {\nfinal double[] lB = CMAESOptimizer.this.getLowerBound();\nfinal double[] uB = CMAESOptimizer.this.getUpperBound();\nfinal double[] repaired = new double[x.length];\nfor (int i = 0; i < x.length; i++) {\nif (x[i] < lB[i]) {\n} else if (x[i] > uB[i]) {\nrepaired[i] = x[i];\nreturn repaired;\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DD)V",
            "method_body": "public PointValuePair(final double[] point,\nthis(point, value, true);\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:inverse([I)[I",
            "method_body": "private static int[] inverse(final int[] indices) {\nfinal int[] inverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\ninverse[indices[i]] = i;\nreturn inverse;\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize:<init>(I)V",
            "method_body": "public PopulationSize(int size)\nthrows NotStrictlyPositiveException {\nif (size <= 0) {\nlambda = size;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:randn1(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix randn1(int size, int popSize) {\nfinal double[][] d = new double[size][popSize];\nfor (int r = 0; r < size; r++) {\nfor (int c = 0; c < popSize; c++) {\nd[r][c] = random.nextGaussian();\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x == Double.POSITIVE_INFINITY) {\nint exp = (int)(bits >> 52)-1023;\nif ((bits & 0x7ff0000000000000L) == 0) {\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nreturn ya + yb;\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\nif (hiPrec != null) {\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\nif (hiPrec != null) {\nreturn a + b;\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:clear()V",
            "method_body": "public void clear() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\nout.setEntry(row, col, sum);\nreturn out;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQ()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQ() {\nif (cachedQ == null) {\ncachedQ = getQT().transpose();\nreturn cachedQ;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getColumn(I)[D",
            "method_body": "public double[] getColumn(final int column) throws OutOfRangeException {\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nfinal double[] out = new double[nRows];\nfor (int i = 0; i < nRows; ++i) {\nout[i] = getEntry(i, column);\nreturn out;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getV()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getV() {\nif (cachedV == null) {\nfinal int m = eigenvectors.length;\ncachedV = MatrixUtils.createRealMatrix(m, m);\nfor (int k = 0; k < m; ++k) {\ncachedV.setColumnVector(k, eigenvectors[k]);\nreturn cachedV;\n}",
            "method_id": 149
        }
    ]
}