{
    "bug_id": 71,
    "test_id": 1,
    "test_name": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent",
    "test_body": "public void testMissedEndEvent() throws IntegratorException, DerivativeException {\nfinal double   t0     = 1878250320.0000029;\nfinal double   tEvent = 1878250379.9999986;\nfinal double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\nFirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n50: public int getDimension() {\nreturn k.length;\n}\n54: public void computeDerivatives(double t, double[] y, double[] yDot) {\nfor (int i = 0; i < y.length; ++i) {\nyDot[i] = k[i] * y[i];\n}\n}\n};\n61: ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n63: double[] y0   = new double[k.length];\nfor (int i = 0; i < y0.length; ++i) {\ny0[i] = i + 1;\n}\ndouble[] y    = new double[k.length];\n69: double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\nAssert.assertEquals(tEvent, finalT, 5.0e-6);\nfor (int i = 0; i < y.length; ++i) {",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getPreviousTime()D",
            "method_body": "public double getPreviousTime() {\nreturn previousTime;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:<init>()V",
            "method_body": "public CombinedEventsManager() {\nstates      = new ArrayList<EventState>();\nfirst       = null;\ninitialized = false;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:eventOccurred(D[DZ)I",
            "method_body": "public int eventOccurred(double t, double[] y, boolean increasing) {\nreturn STOP;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nt0 = t;\ng0 = handler.g(t, y);\nif (pendingEvent) {\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\ng0Positive = g0 >= 0;\nnextAction = EventHandler.CONTINUE;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:isForward()Z",
            "method_body": "public boolean isForward() {\nreturn forward;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nfor (EventState state : states) {\nstate.stepAccepted(t, y);\n}\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;)V",
            "method_body": "protected void setEquations(final FirstOrderDifferentialEquations equations) {\nthis.equations = equations;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getCurrentTime()D",
            "method_body": "public double getCurrentTime() {\nreturn currentTime;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:requiresDenseOutput()Z",
            "method_body": "protected boolean requiresDenseOutput() {\nfor (StepHandler handler : stepHandlers) {\nreturn false;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(final double t, final double[] y, final double[] yDot)\nif (++evaluations > maxEvaluations) {\nequations.computeDerivatives(t, y, yDot);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedState()[D",
            "method_body": "public double[] getInterpolatedState() throws DerivativeException {\nif (dirtyState) {\nfinal double oneMinusThetaH = currentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\nreturn interpolatedState;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventsStates()Ljava/util/Collection;",
            "method_body": "public Collection<EventState> getEventsStates() {\nreturn states;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEndTimeChecker(DDLorg/apache/commons/math/ode/events/CombinedEventsManager;)Lorg/apache/commons/math/ode/events/CombinedEventsManager;",
            "method_body": "protected CombinedEventsManager addEndTimeChecker(final double startTime,\nCombinedEventsManager newManager = new CombinedEventsManager();\nfor (final EventState state : manager.getEventsStates()) {\nnewManager.addEventHandler(new EndTimeChecker(endTime),\nreturn newManager;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn (first == null) ? Double.NaN : first.getEventTime();\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:<init>(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = Math.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.CONTINUE;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEventTime;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:clearResult()V",
            "method_body": "protected final void clearResult() {\nthis.iterationCount = 0;\nthis.resultComputed = false;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:g(D[D)D",
            "method_body": "public double g(double t, double[] y) {\nreturn t - endTime;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setInterpolatedTime(D)V",
            "method_body": "public void setInterpolatedTime(final double time) {\ninterpolatedTime = time;\ndirtyState       = true;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reinitializeBegin(D[D)V",
            "method_body": "public void reinitializeBegin(final double tStart, final double[] yStart)\nt0 = tStart;\ng0 = handler.g(tStart, yStart);\ng0Positive = g0 >= 0;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator:<init>(D)V",
            "method_body": "public ClassicalRungeKuttaIntegrator(final double step) {\nsuper(\"classical Runge-Kutta\", STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.DummyStepInterpolator:<init>([D[DZ)V",
            "method_body": "public DummyStepInterpolator(final double[] y, final double[] yDot, final boolean forward) {\nsuper(y, forward);\ncurrentDerivative = yDot;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\nfinal int stages = c.length + 1;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, y0.length);\nfinal double[][] yDotK = new double[stages][];\nfor (int i = 0; i < stages; ++i) {\nyDotK [i] = new double[y0.length];\nfinal double[] yTmp = new double[y0.length];\nif (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\ninterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\ninterpolator.storeTime(t0);\nstepStart = t0;\nstepSize  = forward ? step : -step;\nfor (StepHandler handler : stepHandlers) {\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nboolean lastStep = false;\nwhile (!lastStep) {\ninterpolator.shift();\nfor (boolean loop = true; loop;) {\ncomputeDerivatives(stepStart, y, yDotK[0]);\nfor (int k = 1; k < stages; ++k) {\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\nyTmp[j] = y[j] + stepSize * sum;\ninterpolator.storeTime(stepStart + stepSize);\nif (manager.evaluateStep(interpolator)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\nloop     = false;\nstepSize = dt;\n} else {\nloop = false;\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\ninterpolator.storeTime(nextStep);\nfor (StepHandler handler : stepHandlers) {\nstepStart = nextStep;\nif (manager.reset(stepStart, y) && ! lastStep) {\nstepSize = forward ? step : -step;\n}\nfinal double stopTime = stepStart;\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\nreturn stopTime;\n}",
            "method_id": 53
        }
    ]
}