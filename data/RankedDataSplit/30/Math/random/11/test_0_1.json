{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution",
    "test_body": "public void testUnivariateDistribution() {\nfinal double[] mu = { -1.5 };\nfinal double[][] sigma = { { 1 } };\n143: final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n145: final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\nfinal Random rng = new Random();\nfinal int numCases = 100;\nfinal double tol = Math.ulp(1d);\nfor (int i = 0; i < numCases; i++) {\nfinal double v = rng.nextDouble() * 10 - 5;\nAssert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n}",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.23644016090654427> but was:<0.5926675925866471>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution(MultivariateNormalDistributionTest.java:151)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver:getInverse()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getInverse() {\nif (!isNonSingular()) {\nfinal int m = realEigenvalues.length;\nfinal double[][] invData = new double[m][m];\nfor (int i = 0; i < m; ++i) {\nfinal double[] invI = invData[i];\nfor (int j = 0; j < m; ++j) {\ndouble invIJ = 0;\nfor (int k = 0; k < m; ++k) {\nfinal double[] vK = eigenvectors[k].getDataRef();\ninvIJ += vK[i] * vK[j] / realEigenvalues[k];\ninvI[j] = invIJ;\nreturn MatrixUtils.createRealMatrix(invData);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:copy()Lorg/apache/commons/math3/linear/ArrayRealVector;",
            "method_body": "public ArrayRealVector copy() {\nreturn new ArrayRealVector(this, true);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\nif (x < 0.0) {\nintVal = (int) -x;\nif (intVal > 746) {\nif (intVal > 709) {\nif (intVal == 709) {\nintVal++;\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\nintVal = -intVal;\nintVal = (int) x;\nif (intVal > 709) {\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\nfinal double tempC = tempB + tempA;\nif (extra != 0.0) {\nresult = tempC*z + tempB + tempA;\nif (hiPrec != null) {\nreturn result;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumn(I[D)V",
            "method_body": "public void setColumn(final int column, final double[] array)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (array.length != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, array[i]);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data)\nif (data == null ||\nreturn (data.length * data[0].length <= 4096) ?\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([DI)[D",
            "method_body": "public static double[] copyOf(double[] source, int len) {\nfinal double[] output = new double[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getDeterminant()D",
            "method_body": "public double getDeterminant() {\ndouble determinant = 1;\nfor (double lambda : realEigenvalues) {\ndeterminant *= lambda;\nreturn determinant;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:pow(DD)D",
            "method_body": "public static double pow(double x, double y) {\nfinal double lns[] = new double[2];\nif (y == 0.0) {\nif (x != x) { // X is NaN\nif (x == 0) {\nif (x == Double.POSITIVE_INFINITY) {\nif (y == Double.POSITIVE_INFINITY) {\nif (x == Double.NEGATIVE_INFINITY) {\nif (y == Double.NEGATIVE_INFINITY) {\nif (x < 0) {\nif (y < 8e298 && y > -8e298) {\ndouble tmp1 = y * HEX_40000000;\nya = y + tmp1 - tmp1;\nyb = y - ya;\n} else {\nfinal double lores = log(x, lns);\nif (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\ndouble lna = lns[0];\ndouble lnb = lns[1];\ndouble tmp1 = lna * HEX_40000000;\ndouble tmp2 = lna + tmp1 - tmp1;\nlnb += lna - tmp2;\nlna = tmp2;\nfinal double aa = lna * ya;\nfinal double ab = lna * yb + lnb * ya + lnb * yb;\nlna = aa+ab;\nlnb = -(lna - aa - ab);\ndouble z = 1.0 / 120.0;\nz = z * lnb + (1.0 / 24.0);\nz = z * lnb + (1.0 / 6.0);\nz = z * lnb + 0.5;\nz = z * lnb + 1.0;\nz = z * lnb;\nfinal double result = exp(lna, z, null);\nreturn result;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\nif (xInt < 0) {\nif (yInt < 0) {\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetric(Lorg/apache/commons/math3/linear/RealMatrix;D)Z",
            "method_body": "public static boolean isSymmetric(RealMatrix matrix,\nreturn isSymmetricInternal(matrix, eps, false);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:clear()V",
            "method_body": "public void clear() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;I)V",
            "method_body": "protected AbstractMultivariateRealDistribution(RandomGenerator rng,\nint n) {\nrandom = rng;\ndimension = n;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getSolver()Lorg/apache/commons/math3/linear/DecompositionSolver;",
            "method_body": "public DecompositionSolver getSolver() {\nif (hasComplexEigenvalues()) {\nreturn new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:<init>(IIII)V",
            "method_body": "protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\nthis(k, m1, m2, m3, null);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:pow(DI)D",
            "method_body": "public static double pow(double d, int e) {\nif (e == 0) {\nreturn 1.0;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractRealDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;)V",
            "method_body": "protected AbstractRealDistribution(RandomGenerator rng) {\nrandom = rng;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution:getExponentTerm([D)D",
            "method_body": "private double getExponentTerm(final double[] values) {\nfinal double[] centered = new double[values.length];\nfor (int i = 0; i < centered.length; i++) {\ncentered[i] = values[i] - getMeans()[i];\nfinal double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);\ndouble sum = 0;\nfor (int i = 0; i < preMultiplied.length; i++) {\nsum += preMultiplied[i] * centered[i];\nreturn FastMath.exp(-0.5 * sum);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:getEigenvector(I)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector getEigenvector(final int i) {\nreturn eigenvectors[i].copy();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math3/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\nout.setEntry(row, col, sum);\nreturn out;\n}",
            "method_id": 59
        }
    ]
}