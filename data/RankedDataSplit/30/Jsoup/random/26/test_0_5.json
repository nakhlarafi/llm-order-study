{
    "bug_id": 26,
    "test_id": 0,
    "test_name": "org.jsoup.safety.CleanerTest.handlesFramesets",
    "test_body": "170: @Test public void handlesFramesets() {\n171: String dirty = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\";\n172: String clean = Jsoup.clean(dirty, Whitelist.basic());\n173: assertEquals(\"\", clean); // nothing good can come out of that\n174: 175: Document dirtyDoc = Jsoup.parse(dirty);\n176: Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n177: assertFalse(cleanDoc == null);\n178: assertEquals(0, cleanDoc.body().childNodes().size());\n179: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:getStack()Lorg/jsoup/helper/DescendableLinkedList;",
            "method_body": "DescendableLinkedList<Element> getStack() {\nreturn stack;\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.nodes.Document:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#document\";\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.safety.Whitelist$TypedValue:hashCode()I",
            "method_body": "public int hashCode() {\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((value == null) ? 0 : value.hashCode());\nreturn result;\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.helper.DescendableLinkedList$DescendingIterator:remove()V",
            "method_body": "public void remove() {\niter.remove();\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$20:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\n} else if (t.isComment()) {\n} else if (t.isDoctype()) {\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n} else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\ntb.transition(AfterAfterFrameset);\nreturn true;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:originalState()Lorg/jsoup/parser/HtmlTreeBuilderState;",
            "method_body": "HtmlTreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEndTag()Z",
            "method_body": "boolean isEndTag() {\nreturn type == TokenType.EndTag;\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$19:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\n} else if (t.isComment()) {\n} else if (t.isDoctype()) {\n} else if (t.isStartTag()) {\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\n} else if (name.equals(\"frameset\")) {\n} else if (name.equals(\"frame\")) {\ntb.insertEmpty(start);\n} else if (t.isEndTag() && t.asEndTag().name().equals(\"frameset\")) {\nif (tb.currentElement().nodeName().equals(\"html\")) { // frag\ntb.pop();\nif (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\ntb.transition(AfterFrameset);\nreturn true;\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:<init>()V",
            "method_body": "private HtmlTreeBuilderState state; // the current state\nprivate boolean baseUriSetFromDoc = false;\nprivate DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\nprivate List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\nprivate boolean framesetOk = true; // if ok to go into frameset\nprivate boolean fosterInserts = false; // if next inserts should be fostered\nprivate boolean fragmentParsing = false; // if parsing a fragment of html\nHtmlTreeBuilder() {}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inSpecificScope([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\nIterator<Element> it = stack.descendingIterator();\nwhile (it.hasNext()) {\nElement el = it.next();\nString elName = el.nodeName();\nif (StringUtil.in(elName, targetNames))\nif (StringUtil.in(elName, baseTypes))\nreturn false;\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn isEmpty() ? EOF : input[pos];\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.helper.DescendableLinkedList$DescendingIterator:hasNext()Z",
            "method_body": "public boolean hasNext() {\nreturn iter.hasPrevious();\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inScope(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName, String[] extras) {\nreturn inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.jsoup.Jsoup:clean(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/safety/Whitelist;)Ljava/lang/String;",
            "method_body": "public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\nDocument dirty = parseBodyFragment(bodyHtml, baseUri);\nCleaner cleaner = new Cleaner(whitelist);\nDocument clean = cleaner.clean(dirty);\nreturn clean.body().html();\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.jsoup.safety.Whitelist:<init>()V",
            "method_body": "public Whitelist() {\ntagNames = new HashSet<TagName>();\nattributes = new HashMap<TagName, Set<AttributeKey>>();\nenforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>();\nprotocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>();\npreserveRelativeLinks = false;\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "Tokeniser(CharacterReader reader, ParseErrorList errors) {\nthis.reader = reader;\nthis.errors = errors;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.jsoup.safety.Whitelist:basic()Lorg/jsoup/safety/Whitelist;",
            "method_body": "public static Whitelist basic() {\nreturn new Whitelist()\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\nattributes = new Attributes();\ntype = TokenType.StartTag;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "CharacterReader(String input) {\nValidate.notNull(input);\nthis.input = input.toCharArray();\nthis.length = this.input.length;\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.jsoup.safety.Whitelist:addTags([Ljava/lang/String;)Lorg/jsoup/safety/Whitelist;",
            "method_body": "public Whitelist addTags(String... tags) {\nValidate.notNull(tags);\nfor (String tagName : tags) {\nValidate.notEmpty(tagName);\ntagNames.add(TagName.valueOf(tagName));\nreturn this;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nboolean selfClosing = false;\nif (attributes == null)\nif (pendingAttributeName != null) {\nif (pendingAttributeValue == null)\nattribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\nattributes.put(attribute);\npendingAttributeName = null;\nif (pendingAttributeValue != null)\npendingAttributeValue.delete(0, pendingAttributeValue.length());\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? new Token.StartTag() : new Token.EndTag();\nreturn tagPending;\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName) {\nValidate.notNull(tagName);\ntagName = tagName.trim().toLowerCase();\nValidate.notEmpty(tagName);\nsynchronized (tags) {\nTag tag = tags.get(tagName);\nif (tag == null) {\ntag = new Tag(tagName);\ntag.isBlock = false;\ntag.canContainBlock = true;\nreturn tag;\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getKey()Ljava/lang/String;",
            "method_body": "public String getKey() {\nreturn key;\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\nt.advanceTransition(TagOpen);\nbreak;\nt.emit(new Token.EOF());\nbreak;\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$17:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.consume()) {\nt.createTempBuffer();\nt.transition(ScriptDataEndTagOpen);\nbreak;\n}",
            "method_id": 179
        }
    ]
}