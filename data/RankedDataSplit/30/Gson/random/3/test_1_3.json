{
    "bug_id": 3,
    "test_id": 1,
    "test_name": "com.google.gson.functional.MapTest.testConcurrentNavigableMap",
    "test_body": "public void testConcurrentNavigableMap() throws Exception {\nType typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();\nConcurrentNavigableMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\nassertEquals(1, map.size());",
    "stack_trace": "java.lang.ClassCastException: java.util.TreeMap cannot be cast to java.util.concurrent.ConcurrentNavigableMap\nat com.google.gson.functional.MapTest.testConcurrentNavigableMap(MapTest.java:208)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
            "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}",
            "method_id": 90
        },
        {
            "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}",
            "method_id": 91
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
            "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}",
            "method_id": 92
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}",
            "method_id": 93
        }
    ]
}