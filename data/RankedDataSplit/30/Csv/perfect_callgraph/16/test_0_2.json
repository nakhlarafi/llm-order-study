{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking",
    "test_body": "public void testIteratorSequenceBreaking() throws IOException {\nfinal String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n1005: // Iterator hasNext() shouldn't break sequence\nCSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nint recordNumber = 0;\nIterator<CSVRecord> iter = parser.iterator();\nrecordNumber = 0;\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\niter.hasNext();\nwhile (iter.hasNext()) {\nCSVRecord record = iter.next();\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1025: // Consecutive enhanced for loops shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}\n1040: // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\nparser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\nrecordNumber = 0;\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\nif (recordNumber >= 2) {\nbreak;\n}\n}\nparser.iterator().hasNext();\nfor (CSVRecord record : parser) {\nrecordNumber++;\nassertEquals(String.valueOf(recordNumber), record.get(0));\n}",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getLastChar()I",
            "method_body": "int getLastChar() {\nreturn lastChar;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getPosition()J",
            "method_body": "long getPosition() {\nreturn this.position;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:isClosed()Z",
            "method_body": "public boolean isClosed() {\nreturn closed;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$1:getNextRecord()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nif (this.current == null) {\nthis.current = this.getNextRecord();\nreturn this.current != null;\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nreturn next;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$1:hasNext()Z",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nif (this.current == null) {\nthis.current = this.getNextRecord();\nreturn this.current != null;\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nreturn next;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$1:next()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nif (this.current == null) {\nthis.current = this.getNextRecord();\nreturn this.current != null;\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nreturn next;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$2:<clinit>()V",
            "method_body": "CSVRecord nextRecord() throws IOException {\nCSVRecord result = null;\nthis.recordList.clear();\nStringBuilder sb = null;\nfinal long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\nthis.reusableToken.reset();\nthis.lexer.nextToken(this.reusableToken);\nswitch (this.reusableToken.type) {\nthis.addRecordValue(true);\nbreak;\nif (this.reusableToken.isReady) {\n} while (this.reusableToken.type == TOKEN);\nif (!this.recordList.isEmpty()) {\nthis.recordNumber++;\nfinal String comment = sb == null ? null : sb.toString();\nresult = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\nreturn result;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:<init>([Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;JJ)V",
            "method_body": "CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber,\nfinal long characterPosition) {\nthis.recordNumber = recordNumber;\nthis.values = values != null ? values : EMPTY_STRING_ARRAY;\nthis.mapping = mapping;\nthis.comment = comment;\nthis.characterPosition = characterPosition;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:<clinit>()V",
            "method_body": "private static final String[] EMPTY_STRING_ARRAY = new String[0];\nfinal long characterPosition) {\nthis.recordNumber = recordNumber;\nthis.values = values != null ? values : EMPTY_STRING_ARRAY;\nthis.mapping = mapping;\nthis.comment = comment;\nthis.characterPosition = characterPosition;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:get(I)Ljava/lang/String;",
            "method_body": "public String get(final int i) {\nreturn values[i];\n}",
            "method_id": 69
        }
    ]
}