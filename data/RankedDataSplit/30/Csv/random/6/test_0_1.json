{
    "bug_id": 6,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord",
    "test_body": "public void testToMapWithShortRecord() throws Exception {\nfinal CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\nfinal CSVRecord shortRec = parser.iterator().next();\nshortRec.toMap();\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 2\nat org.apache.commons.csv.CSVRecord.putIn(CSVRecord.java:182)\nat org.apache.commons.csv.CSVRecord.toMap(CSVRecord.java:212)\nat org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord(CSVRecordTest.java:167)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getEscape()Ljava/lang/Character;",
            "method_body": "public Character getEscape() {\nreturn escape;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:readEndOfLine(I)Z",
            "method_body": "boolean readEndOfLine(int ch) throws IOException {\nif (ch == CR && reader.lookAhead() == LF) {\nreturn ch == LF || ch == CR;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:getLastChar()I",
            "method_body": "int getLastChar() {\nreturn lastChar;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:validate()V",
            "method_body": "void validate() throws IllegalStateException {\nif (quoteChar != null && delimiter == quoteChar.charValue()) {\nif (escape != null && delimiter == escape.charValue()) {\nif (commentStart != null && delimiter == commentStart.charValue()) {\nif (quoteChar != null && quoteChar.equals(commentStart)) {\nif (escape != null && escape.equals(commentStart)) {\nif (escape == null && quotePolicy == Quote.NONE) {\nif (header != null) {\nfinal Set<String> set = new HashSet<String>(header.length);\nset.addAll(Arrays.asList(header));\nif (set.size() != header.length) {\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:parseSimpleToken(Lorg/apache/commons/csv/Token;I)Lorg/apache/commons/csv/Token;",
            "method_body": "private Token parseSimpleToken(final Token token, int ch) throws IOException {\nif (readEndOfLine(ch)) {\n} else if (isEndOfFile(ch)) {\ntoken.type = EOF;\ntoken.isReady = true; // There is data at EOF\nbreak;\n} else if (isDelimiter(ch)) {\ntoken.type = TOKEN;\nbreak;\n} else if (isEscape(ch)) {\ntoken.content.append((char) ch);\nch = reader.read(); // continue\nif (ignoreSurroundingSpaces) {\nreturn token;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEndOfFile(I)Z",
            "method_body": "boolean isEndOfFile(final int ch) {\nreturn ch == END_OF_STREAM;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withEscape(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withEscape(final char escape) {\nreturn withEscape(Character.valueOf(escape));\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.csv.Assertions:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(final Object parameter, final String parameterName) {\nif (parameter == null) {\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:addRecordValue()V",
            "method_body": "private void addRecordValue() {\nfinal String input = this.reusableToken.content.toString();\nfinal String nullString = this.format.getNullString();\nif (nullString == null) {\nthis.record.add(input);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:nextToken(Lorg/apache/commons/csv/Token;)Lorg/apache/commons/csv/Token;",
            "method_body": "Token nextToken(final Token token) throws IOException {\nint lastChar = reader.getLastChar();\nint c = reader.read();\nboolean eol = readEndOfLine(c);\nif (ignoreEmptyLines) {\nwhile (eol && isStartOfLine(lastChar)) {\nif (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {\nif (isStartOfLine(lastChar) && isCommentStart(c)) {\nwhile (token.type == INVALID) {\nif (ignoreSurroundingSpaces) {\nif (isDelimiter(c)) {\n} else if (eol) {\n} else if (isQuoteChar(c)) {\n} else if (isEndOfFile(c)) {\nparseSimpleToken(token, c);\nreturn token;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getDelimiter()C",
            "method_body": "public char getDelimiter() {\nreturn delimiter;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withIgnoreSurroundingSpaces(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\nreturn new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:initializeHeader()Ljava/util/Map;",
            "method_body": "private Map<String, Integer> initializeHeader() throws IOException {\nMap<String, Integer> hdrMap = null;\nfinal String[] formatHeader = this.format.getHeader();\nif (formatHeader != null) {\nhdrMap = new LinkedHashMap<String, Integer>();\nString[] header = null;\nif (formatHeader.length == 0) {\nif (this.format.getSkipHeaderRecord()) {\nheader = formatHeader;\nif (header != null) {\nfor (int i = 0; i < header.length; i++) {\nhdrMap.put(header[i], Integer.valueOf(i));\nreturn hdrMap;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getHeader()[Ljava/lang/String;",
            "method_body": "public String[] getHeader() {\nreturn header != null ? header.clone() : null;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreEmptyLines()Z",
            "method_body": "public boolean getIgnoreEmptyLines() {\nreturn ignoreEmptyLines;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:toMap()Ljava/util/Map;",
            "method_body": "public Map<String, String> toMap() {\nreturn putIn(new HashMap<String, String>(values.length));\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:<init>(Ljava/io/Reader;Lorg/apache/commons/csv/CSVFormat;)V",
            "method_body": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\nAssertions.notNull(reader, \"reader\");\nAssertions.notNull(format, \"format\");\nformat.validate();\nthis.format = format;\nthis.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\nthis.headerMap = this.initializeHeader();\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$1:next()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nnext = this.getNextRecord();\nif (next == null) {\nreturn next;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withRecordSeparator(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withRecordSeparator(final char recordSeparator) {\nreturn withRecordSeparator(String.valueOf(recordSeparator));\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getCommentStart()Ljava/lang/Character;",
            "method_body": "public Character getCommentStart() {\nreturn commentStart;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(C)Z",
            "method_body": "private static boolean isLineBreak(final char c) {\nreturn c == LF || c == CR;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<clinit>()V",
            "method_body": "public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\npublic static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\npublic static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\npublic static final CSVFormat TDF =\npublic static final CSVFormat MYSQL =\nreturn c == LF || c == CR;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:nextRecord()Lorg/apache/commons/csv/CSVRecord;",
            "method_body": "CSVRecord nextRecord() throws IOException {\nCSVRecord result = null;\nthis.record.clear();\nStringBuilder sb = null;\nthis.reusableToken.reset();\nthis.lexer.nextToken(this.reusableToken);\nswitch (this.reusableToken.type) {\nthis.addRecordValue();\nbreak;\nif (this.reusableToken.isReady) {\nthis.addRecordValue();\n} while (this.reusableToken.type == TOKEN);\nif (!this.record.isEmpty()) {\nthis.recordNumber++;\nfinal String comment = sb == null ? null : sb.toString();\nresult = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\nreturn result;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:iterator()Ljava/util/Iterator;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nnext = this.getNextRecord();\nif (next == null) {\nreturn next;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:read()I",
            "method_body": "public int read() throws IOException {\nfinal int current = super.read();\nif (current == CR || (current == LF && lastChar != CR)) {\nlastChar = current;\nreturn lastChar;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreSurroundingSpaces()Z",
            "method_body": "public boolean getIgnoreSurroundingSpaces() {\nreturn ignoreSurroundingSpaces;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<init>(CLjava/lang/Character;Lorg/apache/commons/csv/Quote;Ljava/lang/Character;Ljava/lang/Character;ZZLjava/lang/String;Ljava/lang/String;[Ljava/lang/String;Z)V",
            "method_body": "CSVFormat(final char delimiter, final Character quoteChar,\nfinal String nullString, final String[] header, final boolean skipHeaderRecord) {\nif (isLineBreak(delimiter)) {\nthis.delimiter = delimiter;\nthis.quoteChar = quoteChar;\nthis.quotePolicy = quotePolicy;\nthis.commentStart = commentStart;\nthis.escape = escape;\nthis.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\nthis.ignoreEmptyLines = ignoreEmptyLines;\nthis.recordSeparator = recordSeparator;\nthis.nullString = nullString;\nthis.header = header == null ? null : header.clone();\nthis.skipHeaderRecord = skipHeaderRecord;\n}",
            "method_id": 56
        }
    ]
}