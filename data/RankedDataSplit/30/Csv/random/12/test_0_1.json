{
    "bug_id": 12,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVParserTest.testExcelHeaderCountLessThanData",
    "test_body": "public void testExcelHeaderCountLessThanData() throws Exception {\nfinal String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\nfinal CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\ntry {",
    "stack_trace": "java.lang.IllegalArgumentException: The header contains a duplicate name: \"\" in [A, B, C, , ]\nat org.apache.commons.csv.CSVParser.initializeHeader(CSVParser.java:367)\nat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:248)\nat org.apache.commons.csv.CSVParser.parse(CSVParser.java:178)\nat org.apache.commons.csv.CSVParserTest.testExcelHeaderCountLessThanData(CSVParserTest.java:380)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEndOfFile(I)Z",
            "method_body": "boolean isEndOfFile(final int ch) {\nreturn ch == END_OF_STREAM;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getQuoteCharacter()Ljava/lang/Character;",
            "method_body": "public Character getQuoteCharacter() {\nreturn quoteCharacter;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.csv.Token:reset()V",
            "method_body": "void reset() {\ncontent.setLength(0);\ntype = INVALID;\nisReady = false;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:parseSimpleToken(Lorg/apache/commons/csv/Token;I)Lorg/apache/commons/csv/Token;",
            "method_body": "private Token parseSimpleToken(final Token token, int ch) throws IOException {\nif (readEndOfLine(ch)) {\n} else if (isEndOfFile(ch)) {\n} else if (isDelimiter(ch)) {\ntoken.type = TOKEN;\nbreak;\n} else if (isEscape(ch)) {\ntoken.content.append((char) ch);\nch = reader.read(); // continue\nif (ignoreSurroundingSpaces) {\nreturn token;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:isEscape(I)Z",
            "method_body": "boolean isEscape(final int ch) {\nreturn ch == escape;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:<init>(Ljava/io/Reader;Lorg/apache/commons/csv/CSVFormat;)V",
            "method_body": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\nAssertions.notNull(reader, \"reader\");\nAssertions.notNull(format, \"format\");\nthis.format = format;\nthis.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\nthis.headerMap = this.initializeHeader();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withQuote(Ljava/lang/Character;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withQuote(final Character quoteChar) {\nif (isLineBreak(quoteChar)) {\nreturn new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.csv.Token:<init>()V",
            "method_body": "Token.Type type = INVALID;\nfinal StringBuilder content = new StringBuilder(INITIAL_TOKEN_LENGTH);\ncontent.setLength(0);\ntype = INVALID;\nisReady = false;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getNullString()Ljava/lang/String;",
            "method_body": "public String getNullString() {\nreturn nullString;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<clinit>()V",
            "method_body": "public static final CSVFormat MYSQL =\nreturn c == LF || c == CR;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.csv.ExtendedBufferedReader:<init>(Ljava/io/Reader;)V",
            "method_body": "ExtendedBufferedReader(final Reader reader) {\nsuper(reader);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(Ljava/lang/Character;)Z",
            "method_body": "private static boolean isLineBreak(final Character c) {\nreturn c != null && isLineBreak(c.charValue());\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:getIgnoreEmptyLines()Z",
            "method_body": "public boolean getIgnoreEmptyLines() {\nreturn ignoreEmptyLines;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<init>(CLjava/lang/Character;Lorg/apache/commons/csv/QuoteMode;Ljava/lang/Character;Ljava/lang/Character;ZZLjava/lang/String;Ljava/lang/String;[Ljava/lang/String;ZZ)V",
            "method_body": "private CSVFormat(final char delimiter, final Character quoteChar,\nfinal boolean allowMissingColumnNames) {\nif (isLineBreak(delimiter)) {\nthis.delimiter = delimiter;\nthis.quoteCharacter = quoteChar;\nthis.quoteMode = quoteMode;\nthis.commentMarker = commentStart;\nthis.escapeCharacter = escape;\nthis.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\nthis.allowMissingColumnNames = allowMissingColumnNames;\nthis.ignoreEmptyLines = ignoreEmptyLines;\nthis.recordSeparator = recordSeparator;\nthis.nullString = nullString;\nif (header == null) {\nthis.header = null;\nfinal Set<String> dupCheck = new HashSet<String>();\nfor (final String hdr : header) {\nthis.header = header.clone();\nthis.skipHeaderRecord = skipHeaderRecord;\nvalidate();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:addRecordValue()V",
            "method_body": "private void addRecordValue() {\nfinal String input = this.reusableToken.content.toString();\nfinal String nullString = this.format.getNullString();\nif (nullString == null) {\nthis.record.add(input);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.csv.Lexer:readEndOfLine(I)Z",
            "method_body": "boolean readEndOfLine(int ch) throws IOException {\nif (ch == CR && reader.lookAhead() == LF) {\nch = reader.read();\nreturn ch == LF || ch == CR;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:isLineBreak(C)Z",
            "method_body": "private static boolean isLineBreak(final char c) {\nreturn c == LF || c == CR;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withEscape(Ljava/lang/Character;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withEscape(final Character escape) {\nif (isLineBreak(escape)) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser$2:<clinit>()V",
            "method_body": "CSVRecord nextRecord() throws IOException {\nCSVRecord result = null;\nthis.record.clear();\nStringBuilder sb = null;\nthis.reusableToken.reset();\nthis.lexer.nextToken(this.reusableToken);\nswitch (this.reusableToken.type) {\nthis.addRecordValue();\nbreak;\nthis.addRecordValue();\nbreak;\n} while (this.reusableToken.type == TOKEN);\nif (!this.record.isEmpty()) {\nthis.recordNumber++;\nfinal String comment = sb == null ? null : sb.toString();\nresult = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\nreturn result;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withDelimiter(C)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withDelimiter(final char delimiter) {\nif (isLineBreak(delimiter)) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withIgnoreSurroundingSpaces(Z)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\nreturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.csv.Token$Type:<clinit>()V",
            "method_body": "private static final int INITIAL_TOKEN_LENGTH = 50;\nenum Type {\nINVALID,\nTOKEN,\nEOF,\nEORECORD,\nCOMMENT\n}",
            "method_id": 51
        }
    ]
}