{
    "bug_id": 16,
    "test_id": 3,
    "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29",
    "test_body": "public void testParseInto_monthDay_feb29() {\nDateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\nMutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\nassertEquals(4, f.parseInto(result, \"2 29\", 0));\nassertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2004-02-29T12:20:30.000Z> but was:<2000-02-29T12:20:30.000Z>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29(TestDateTimeFormatter.java:905)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfYear(JI)I",
            "method_body": "int getDayOfYear(long instant, int year) {\nlong yearStart = getYearMillis(year);\nreturn (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "protected Chronology checkChronology(Chronology chronology) {\nreturn DateTimeUtils.getChronology(chronology);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:findMatchingRecurrence(J)Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;",
            "method_body": "private Recurrence findMatchingRecurrence(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\nstart = startRecurrence.next\n}\nend = endRecurrence.next\n}\nreturn (start > end) ? startRecurrence : endRecurrence;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nbuf.append(iValue);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
            "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:previousTransition(J)J",
            "method_body": "public long previousTransition(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\ni = ~i;\nif (i < transitions.length) {\nif (iTailZone != null) {\nlong prev = iTailZone.previousTransition(instant);\nif (prev < instant) {\nreturn prev;\nlong prev = transitions[i - 1];\nif (prev > Long.MIN_VALUE) {\nreturn prev - 1;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iUnitField;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\nreturn info;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nswitch (iOrdinal) {\nreturn chronology.year();\nreturn chronology.monthOfYear();\nreturn chronology.dayOfMonth();\nreturn chronology.hourOfDay();\nreturn chronology.minuteOfHour();\nreturn chronology.secondOfDay();\nreturn chronology.secondOfMinute();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMillis(I)J",
            "method_body": "long getYearMillis(int year) {\nreturn getYearInfo(year).iFirstDayMillis;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append(Lorg/joda/time/format/DateTimeFormatter;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\nif (formatter == null) {\nreturn append0(formatter.getPrinter(), formatter.getParser());\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfMonthNext(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfMonthNext(Chronology chrono, long next) {\nnext = setDayOfMonth(chrono, next);\n}\nreturn next;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:localToUTC(J)J",
            "method_body": "private long localToUTC(long instant) {\nDateTimeZone zone = getZone();\nint offset = zone.getOffsetFromLocal(instant);\ninstant -= offset;\nif (offset != zone.getOffset(instant)) {\nreturn instant;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:previous(JII)J",
            "method_body": "public long previous(long instant, int standardOffset, int saveMillis) {\nreturn iOfYear.previous(instant, standardOffset, saveMillis);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:nextTransition(J)J",
            "method_body": "public long nextTransition(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\ni = (i >= 0) ? (i + 1) : ~i;\nif (i < transitions.length) {\nif (iTailZone == null) {\nreturn instant;\nlong end = transitions[transitions.length - 1];\nif (instant < end) {\nreturn iTailZone.nextTransition(instant);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
            "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iMaxParsedDigits;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
            "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn estimatePrintedLength();\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
            "method_body": "boolean isParser() {\nreturn iParsers != null;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfDay() {\nreturn iHourOfDay;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
            "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:compareTo(Lorg/joda/time/DurationField;)I",
            "method_body": "public int compareTo(DurationField otherField) {\nlong otherMillis = otherField.getUnitMillis();\nlong thisMillis = getUnitMillis();\nif (thisMillis == otherMillis) {\nreturn 0;\nif (thisMillis < otherMillis) {\nreturn 1;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = iBase) != null && (iBaseFlags & 5) == 5) {\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n}",
            "method_id": 59
        }
    ]
}