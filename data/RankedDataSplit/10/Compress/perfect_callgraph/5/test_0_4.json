{
    "bug_id": 5,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest.testRead7ZipMultiVolumeArchiveForStream",
    "test_body": "69: public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n70: URISyntaxException {\n71: 72: URL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n73: FileInputStream archive = new FileInputStream(\n74: new File(new URI(zip.toString())));\n75: ZipArchiveInputStream zi = null;\n76: try {\n77: zi = new ZipArchiveInputStream(archive,null,false);\n78: 79: // these are the entries that are supposed to be processed\n80: // correctly without any problems\n81: for (int i = 0; i < ENTRIES.length; i++) {\n82: assertEquals(ENTRIES[i], zi.getNextEntry().getName());\n83: }\n84: 85: // this is the last entry that is truncated\n86: ArchiveEntry lastEntry = zi.getNextEntry();\n87: assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n88: byte [] buffer = new byte [4096];\n89: 90: // before the fix, we'd get 0 bytes on this read and all\n91: // subsequent reads thus a client application might enter\n92: // an infinite loop after the fix, we should get an\n93: // exception\n94: try {\n95: int read = 0;\n96: while ((read = zi.read(buffer)) > 0) { }\n97: fail(\"shouldn't be able to read from truncated entry\");\n98: } catch (IOException e) {\n99: assertEquals(\"Truncated ZIP file\", e.getMessage());\n100: }\n101: 102: // and now we get another entry, which should also yield\n103: // an exception\n104: try {\n105: zi.getNextEntry();\n106: fail(\"shouldn't be able to read another entry from truncated\"\n107: + \" file\");\n108: } catch (IOException e) {\n109: // this is to be expected\n110: }\n111: } finally {\n112: if (zi != null) {\n113: zi.close();\n114: }\n115: }\n116: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZ)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local)\nList v = new ArrayList();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn (ZipExtraField[]) v.toArray(result);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nreturn result;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
            "method_body": "protected AbstractUnicodeExtraField() {\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}",
            "method_id": 49
        }
    ]
}