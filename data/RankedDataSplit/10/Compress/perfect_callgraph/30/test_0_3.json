{
    "bug_id": 30,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest.readOfLength0ShouldReturn0",
    "test_body": "46: public void readOfLength0ShouldReturn0() throws Exception {\n47: // Create a big random piece of data\n48: byte[] rawData = new byte[1048576];\n49: for (int i=0; i < rawData.length; ++i) {\n50: rawData[i] = (byte) Math.floor(Math.random()*256);\n51: }\n52: 53: // Compress it\n54: ByteArrayOutputStream baos = new ByteArrayOutputStream();\n55: BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n56: bzipOut.write(rawData);\n57: bzipOut.flush();\n58: bzipOut.close();\n59: baos.flush();\n60: baos.close();\n61: 62: // Try to read it back in\n63: ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n64: BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n65: byte[] buffer = new byte[1024];\n66: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n67: Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n68: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n69: bzipIn.close();\n70: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
            "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nreturn setupNoRandPartA();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthis(out, MAX_BLOCKSIZE);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
            "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nif (blockSize > 9) {\nthis.blockSize100k = blockSize;\nthis.out = out;\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
            "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nyy = 0;\nzz = 1;\ntmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\n}\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\nif (tooLong) {\n}\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
            "method_body": "public void write(final byte[] buf, int offs, final int len)\nif (offs < 0) {\nif (len < 0) {\nif (offs + len > buf.length) {\nif (this.out == null) {\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
            "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
            "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\nvec <<= 1;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
            "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\nint remF = this.nMTF;\nint gs = 0;\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\naFreq -= mtfFreq[ge--];\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\nlen_np[v] = GREATER_ICOST;\ngs = ge + 1;\nremF -= aFreq;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
            "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\nint nSelectors = 0;\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\nnSelectors = 0;\nfor (int gs = 0; gs < this.nMTF;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nif (nGroups == N_GROUPS) {\nshort cost0 = 0;\nshort cost1 = 0;\nshort cost2 = 0;\nshort cost3 = 0;\nshort cost4 = 0;\nshort cost5 = 0;\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\ncost0 += len_0[icv] & 0xff;\ncost1 += len_1[icv] & 0xff;\ncost2 += len_2[icv] & 0xff;\ncost3 += len_3[icv] & 0xff;\ncost4 += len_4[icv] & 0xff;\ncost5 += len_5[icv] & 0xff;\ncost[0] = cost0;\ncost[1] = cost1;\ncost[2] = cost2;\ncost[3] = cost3;\ncost[4] = cost4;\ncost[5] = cost5;\n} else {\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\ngs = ge + 1;\n}\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\nreturn nSelectors;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
            "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}",
            "method_id": 39
        }
    ]
}