{
    "bug_id": 13,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.winzipBackSlashWorkaround",
    "test_body": "35: public void winzipBackSlashWorkaround() throws Exception {\n36: URL zip = getClass().getResource(\"/test-winzip.zip\");\n37: ZipArchiveInputStream in = null;\n38: try {\n39: in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n40: ZipArchiveEntry zae = in.getNextZipEntry();\n41: zae = in.getNextZipEntry();\n42: zae = in.getNextZipEntry();\n43: assertEquals(\"\\u00e4/\", zae.getName());\n44: } finally {\n45: if (in != null) {\n46: in.close();\n47: }\n48: }\n49: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
            "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\nif (commentBytes != null && commentBytes.length > 0) {\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
            "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.buf.length);\nthis.allowStoredEntriesWithDataDescriptor =\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
            "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
            "method_body": "public long getValue() {\nreturn value;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:reset()V",
            "method_body": "private void reset() {\noffsetInBuffer = lengthOfLastRead = 0;\n}",
            "method_id": 29
        }
    ]
}