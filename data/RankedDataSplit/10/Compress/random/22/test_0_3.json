{
    "bug_id": 22,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test.testPartialReadTruncatedData",
    "test_body": "85: public void testPartialReadTruncatedData() throws IOException {\n86: //with BZ2File(self.filename) as f:\n87: //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n88: //    self.assertRaises(EOFError, f.read, 1)\n89: 90: final int length = TEXT.length();\n91: ByteBuffer buffer = ByteBuffer.allocate(length);\n92: bz2Channel.read(buffer);\n93: 94: assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),\n95: buffer.array());\n96: 97: // subsequent read should throw\n98: buffer = ByteBuffer.allocate(1);\n99: try {\n100: bz2Channel.read(buffer);\n101: Assert.fail(\"The read should have thrown.\");\n102: } catch (IOException e) {\n103: // pass\n104: }\n105: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
            "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\nthis.nInUse = nInUseShadow;\nfinal int eob = nInUseShadow + 1;\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\nint wr = 0;\nint zPend = 0;\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\nif (j == 0) {\nzPend++;\nif (zPend > 0) {\nzPend--;\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\nzPend = 0;\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\nif (zPend > 0) {\nzPend--;\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\nif (zPend >= 2) {\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fvswap([IIII)V",
            "method_body": "private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\nwhile (yyn > 0) {\nfswap(fmap, yyp1, yyp2);\nyyp1++; yyp2++; yyn--;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
            "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\nvec <<= 1;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpop(I)[I",
            "method_body": "private int[] fpop(int sp) {\nreturn new int[] { stack_ll[sp], stack_hh[sp] };\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
            "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n2391484 };",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fswap([III)V",
            "method_body": "private void fswap(int[] fmap, int zz1, int zz2) {\nint zztmp = fmap[zz1];\nfmap[zz1] = fmap[zz2];\nfmap[zz2] = zztmp;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:endBlock()V",
            "method_body": "private void endBlock() throws IOException {\nthis.computedBlockCRC = this.crc.getFinalCRC();\nif (this.storedBlockCRC != this.computedBlockCRC) {\nthis.computedCombinedCRC = (this.computedCombinedCRC << 1)\nthis.computedCombinedCRC ^= this.computedBlockCRC;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
            "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
            "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackQSort3([I[III)V",
            "method_body": "private void fallbackQSort3(int[] fmap,\nlong r = 0;\nint sp = 0;\nfpush(sp++, loSt, hiSt);\nwhile (sp > 0) {\nint[] s = fpop(--sp);\nlo = s[0]; hi = s[1];\nif (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\nfallbackSimpleSort(fmap, eclass, lo, hi);\ncontinue;\nr = ((r * 7621) + 1) % 32768;\nlong r3 = r % 3, med;\nif (r3 == 0) {\nmed = eclass[fmap[lo]];\n} else if (r3 == 1) {\nmed = eclass[fmap[(lo + hi) >>> 1]];\nmed = eclass[fmap[hi]];\nunLo = ltLo = lo;\nunHi = gtHi = hi;\nif (unLo > unHi) {\nbreak;\nn = eclass[fmap[unLo]] - (int) med;\nif (n == 0) {\nfswap(fmap, unLo, ltLo);\nltLo++; unLo++;\ncontinue;\nif (n > 0) {\nbreak;\nunLo++;\nif (unLo > unHi) {\nbreak;\nn = eclass[fmap[unHi]] - (int) med;\nif (n == 0) {\nfswap(fmap, unHi, gtHi);\ngtHi--; unHi--;\ncontinue;\nif (n < 0) {\nbreak;\nunHi--;\nif (unLo > unHi) {\nbreak;\nfswap(fmap, unLo, unHi); unLo++; unHi--;\nif (gtHi < ltLo) {\ncontinue;\nn = fmin(ltLo - lo, unLo - ltLo);\nfvswap(fmap, lo, unLo - n, n);\nint m = fmin(hi - gtHi, gtHi - unHi);\nfvswap(fmap, unHi + 1, hi - m + 1, m);\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\nif (n - lo > hi - m) {\nfpush(sp++, lo, n);\nfpush(sp++, m, hi);\nfpush(sp++, m, hi);\nfpush(sp++, lo, n);\n}\n}",
            "method_id": 39
        }
    ]
}