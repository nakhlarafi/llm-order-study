{
    "bug_id": 4,
    "test_id": 5,
    "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra",
    "test_body": "78: public void testASCIIFileRoundtripImplicitUnicodeExtra()\n79: throws IOException {\n80: testFileRoundtrip(US_ASCII, false, false);\n81: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
            "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
            "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
            "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
            "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
            "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
            "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}",
            "method_id": 59
        }
    ]
}