{
    "bug_id": 32,
    "test_id": 0,
    "test_name": "org.mockitousage.bugs.SpyShouldHaveNiceNameTest.shouldPrintNiceName",
    "test_body": "public void shouldPrintNiceName() {\n//when\nveryCoolSpy.add(1);\n27: try {\nverify(veryCoolSpy).add(2);\nfail();",
    "stack_trace": "junit.framework.AssertionFailedError: <'\nArgument(s) are different! Wanted:\nlinkedList.add(2);\n-> at org.mockitousage.bugs.SpyShouldHaveNiceNameTest.shouldPrintNiceName(SpyShouldHaveNiceNameTest.java:28)",
    "covered_methods": [
        {
            "method_signature": "org.mockito.internal.invocation.Invocation:getArguments()[Ljava/lang/Object;",
            "method_body": "public Object[] getArguments() {\nreturn arguments;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:setConstructorsAccessible(Ljava/lang/Class;Z)V",
            "method_body": "private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\nfor (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\nconstructor.setAccessible(accessible);\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.mockito.internal.stubbing.answers.CallsRealMethods:answer(Lorg/mockito/invocation/InvocationOnMock;)Ljava/lang/Object;",
            "method_body": "public Object answer(InvocationOnMock invocation) throws Throwable {\nreturn invocation.callRealMethod();\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.mockito.internal.util.MockUtil:createMock(Ljava/lang/Class;Lorg/mockito/internal/creation/MockSettingsImpl;)Ljava/lang/Object;",
            "method_body": "public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\ncreationValidator.validateType(classToMock);\ncreationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\ncreationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\nsettings.initiateMockName(classToMock);\nMockHandler<T> mockHandler = new MockHandler<T>(settings);\nMethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\nClass<?>[] interfaces = settings.getExtraInterfaces();\nif (settings.isSerializable()) {\nancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\nObject spiedInstance = settings.getSpiedInstance();\nT mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\nif (spiedInstance != null) {\nnew LenientCopyTool().copyToMock(spiedInstance, mock);\nreturn mock;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker:check(Ljava/util/List;Lorg/mockito/internal/invocation/InvocationMatcher;)V",
            "method_body": "public void check(List<Invocation> invocations, InvocationMatcher wanted) {\nList<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\nif (actualInvocations.isEmpty()) {\nInvocation similar = finder.findSimilarInvocation(invocations, wanted);\nif (similar != null) {\nArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\nInteger[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\nSmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\nreporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n} else {\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.mockito.internal.util.reflection.FieldCopier:copyValue(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Field;)V",
            "method_body": "public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\nObject value = field.get(from);\nfield.set(to, value);\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.mockito.exceptions.verification.junit.JUnitTool:hasJUnit()Z",
            "method_body": "public static boolean hasJUnit() {\nreturn hasJUnit;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:canImposterise(Ljava/lang/Class;)Z",
            "method_body": "public boolean canImposterise(Class<?> type) {\nreturn !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public ArgumentsAreDifferent(String message, String wanted, String actual) {\nsuper(message, wanted, actual);\nthis.message = message;\nunfilteredStackTrace = getStackTrace();\nConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\nfilter.filter(this);\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.mockito.internal.invocation.Invocation:toString(Lorg/mockito/internal/reporting/PrintSettings;)Ljava/lang/String;",
            "method_body": "public String toString(PrintSettings printSettings) {\nreturn toString(argumentsToMatchers(), printSettings);\n}",
            "method_id": 99
        }
    ]
}