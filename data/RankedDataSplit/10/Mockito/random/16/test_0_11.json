{
    "bug_id": 16,
    "test_id": 0,
    "test_name": "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest.shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS",
    "test_body": "public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\nIMethods mock = mock(IMethods.class, RETURNS_MOCKS);\nwhen(mock.objectReturningMethodNoArgs()).thenReturn(null);\n}\n",
    "stack_trace": "org.mockito.exceptions.misusing.MissingMethodInvocationException:\nwhen() requires an argument which has to be a method call on a mock.\nFor example:\nwhen(mock.getArticles()).thenReturn(articles);\n\nAlso, this error might show up because you stub final/private/equals() or hashCode() method.\nThose methods *cannot* be stubbed/verified.\n\nat org.mockito.exceptions.Reporter.missingMethodInvocation(Reporter.java:77)\nat org.mockito.internal.MockitoCore.stub(MockitoCore.java:43)\nat org.mockito.internal.MockitoCore.when(MockitoCore.java:56)\nat org.mockito.Mockito.when(Mockito.java:994)\nat org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest.shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS(StubbingMocksThatAreConfiguredToReturnMocksTest.java:19)",
    "covered_methods": [
        {
            "method_signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl:pullMatchers()Ljava/util/List;",
            "method_body": "public List<Matcher> pullMatchers() {\nif (matcherStack.isEmpty()) {\nreturn Collections.emptyList();\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.mockito.internal.progress.ThreadSafeMockingProgress:getDebuggingInfo()Lorg/mockito/internal/debugging/DebuggingInfo;",
            "method_body": "public DebuggingInfo getDebuggingInfo() {\nreturn threadSafely().getDebuggingInfo();\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.mockito.internal.progress.MockingProgressImpl:stubbingStarted()V",
            "method_body": "public void stubbingStarted() {\nvalidateState();\nstubbingInProgress = new Location();\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.mockito.internal.creation.jmock.ClassImposterizer:createProxy(Ljava/lang/Class;Lorg/mockito/cglib/proxy/MethodInterceptor;)Ljava/lang/Object;",
            "method_body": "private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\nFactory proxy = (Factory) objenesis.newInstance(proxyClass);\nproxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\nreturn proxy;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.mockito.internal.progress.ThreadSafeMockingProgress:reportOngoingStubbing(Lorg/mockito/internal/progress/IOngoingStubbing;)V",
            "method_body": "public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\nthreadSafely().reportOngoingStubbing(iOngoingStubbing);\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.mockito.internal.exceptions.base.StackTraceFilter:filter([Ljava/lang/StackTraceElement;Z)[Ljava/lang/StackTraceElement;",
            "method_body": "public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\nList<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\nint lastBad = -1;\nint firstBad = -1;\nfor (int i = 0; i < unfilteredStackTrace.size(); i++) {\nif (!this.isBad(unfilteredStackTrace.get(i))) {\ncontinue;\nlastBad = i;\nif (firstBad == -1) {\nfirstBad = i;\nif (keepTop && firstBad != -1) {\ntop = new LinkedList<StackTraceElement>();\nList<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\nList<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\nfiltered.addAll(bottom);\nreturn filtered.toArray(new StackTraceElement[]{});\n}",
            "method_id": 115
        }
    ]
}