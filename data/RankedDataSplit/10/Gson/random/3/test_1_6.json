{
    "bug_id": 3,
    "test_id": 1,
    "test_name": "com.google.gson.functional.MapTest.testConcurrentNavigableMap",
    "test_body": "public void testConcurrentNavigableMap() throws Exception {\nType typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();\nConcurrentNavigableMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\nassertEquals(1, map.size());",
    "stack_trace": "java.lang.ClassCastException: java.util.TreeMap cannot be cast to java.util.concurrent.ConcurrentNavigableMap\nat com.google.gson.functional.MapTest.testConcurrentNavigableMap(MapTest.java:208)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
            "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}",
            "method_id": 60
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$7:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
            "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nreturn in.nextInt();\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
            "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
            "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}",
            "method_id": 63
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
            "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
            "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
            "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}",
            "method_id": 69
        }
    ]
}