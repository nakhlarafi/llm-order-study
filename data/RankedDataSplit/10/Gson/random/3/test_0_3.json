{
    "bug_id": 3,
    "test_id": 0,
    "test_name": "com.google.gson.functional.MapTest.testConcurrentMap",
    "test_body": "public void testConcurrentMap() throws Exception {\nType typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();\nConcurrentMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\nassertEquals(1, map.size());",
    "stack_trace": "java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to java.util.concurrent.ConcurrentMap\nat com.google.gson.functional.MapTest.testConcurrentMap(MapTest.java:188)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
            "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}",
            "method_id": 30
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
            "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}",
            "method_id": 31
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}",
            "method_id": 32
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$13:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
            "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nif (peek == JsonToken.BOOLEAN) {\nreturn in.nextString();\n}",
            "method_id": 33
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
            "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}",
            "method_id": 34
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}",
            "method_id": 35
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
            "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0; i < array.length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}",
            "method_id": 36
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
            "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\nargs[t] = resolvedTypeArgument;\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
            "method_body": "public final Type getType() {\nreturn type;\n}",
            "method_id": 38
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
            "method_body": "private String nextQuotedValue(char quote) throws IOException {\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nint p = pos;\nint l = limit;\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\n} else if (c == '\\n') {\n}\n}",
            "method_id": 39
        }
    ]
}