{
    "bug_id": 85,
    "test_id": 0,
    "test_name": "org.apache.commons.math.distribution.NormalDistributionTest.testMath280",
    "test_body": "public void testMath280() throws MathException {\nNormalDistribution normal = new NormalDistributionImpl(0,1);\ndouble result = normal.inverseCumulativeProbability(0.9772498680518209);\nassertEquals(2.0, result, 1.0e-12);",
    "stack_trace": "org.apache.commons.math.MathException: org.apache.commons.math.ConvergenceException: number of iterations=1, maximum iterations=2,147,483,647, initial=1, lower bound=0, upper bound=179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000, final a value=0, final b value=2, f(a)=-0.477, f(b)=0\nat org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:104)\nat org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:162)\nat org.apache.commons.math.distribution.NormalDistributionTest.testMath280(NormalDistributionTest.java:169)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:cumulativeProbability(D)D",
            "method_body": "public double cumulativeProbability(double x) throws MathException {\nreturn 0.5 * (1.0 + Erf.erf((x - mean) /\n} catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n} else if (x > (mean + 20 * standardDeviation)) {\nreturn 1.0d;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.MaxIterationsExceededException:<init>(I)V",
            "method_body": "public MaxIterationsExceededException(final int maxIterations) {\nsuper(\"Maximal number of iterations ({0}) exceeded\", maxIterations);\nthis.maxIterations = maxIterations;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:getStandardDeviation()D",
            "method_body": "public double getStandardDeviation() {\nreturn standardDeviation;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.MathException:buildMessage(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
            "method_body": "private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\nreturn (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution:inverseCumulativeProbability(D)D",
            "method_body": "public double inverseCumulativeProbability(final double p)\nif (p < 0.0 || p > 1.0) {\nUnivariateRealFunction rootFindingFunction =\nnew UnivariateRealFunction() {\nreturn cumulativeProbability(x) - p;\ndouble lowerBound = getDomainLowerBound(p);\ndouble upperBound = getDomainUpperBound(p);\ndouble[] bracket = null;\nbracket = UnivariateRealSolverUtils.bracket(\n}  catch (ConvergenceException ex) {\nif (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\nif (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\nthrow new MathException(ex);\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getLocalizedMessage()Ljava/lang/String;",
            "method_body": "public String getLocalizedMessage() {\nreturn getMessage(Locale.getDefault());\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:bracket(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DDD)[D",
            "method_body": "public static double[] bracket(UnivariateRealFunction function,\nreturn bracket( function, initial, lowerBound, upperBound,\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution$1:value(D)D",
            "method_body": "public double inverseCumulativeProbability(final double p)\nif (p < 0.0 || p > 1.0) {\nUnivariateRealFunction rootFindingFunction =\nnew UnivariateRealFunction() {\nreturn cumulativeProbability(x) - p;\ndouble lowerBound = getDomainLowerBound(p);\ndouble upperBound = getDomainUpperBound(p);\ndouble[] bracket = null;\nbracket = UnivariateRealSolverUtils.bracket(\n}  catch (ConvergenceException ex) {\nif (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\nif (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\nthrow new MathException(ex);\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:getDomainLowerBound(D)D",
            "method_body": "protected double getDomainLowerBound(double p) {\nif (p < .5) {\nret = getMean();\nreturn ret;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma:regularizedGammaP(DDDI)D",
            "method_body": "public static double regularizedGammaP(double a,\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n} else if (x == 0.0) {\nret = 0.0;\n} else if (a >= 1.0 && x > a) {\ndouble n = 0.0; // current element index\ndouble an = 1.0 / a; // n-th element in the series\ndouble sum = an; // partial sum\nwhile (Math.abs(an) > epsilon && n < maxIterations) {\nn = n + 1.0;\nan = an * (x / (a + n));\nsum = sum + an;\nif (n >= maxIterations) {\nthrow new MaxIterationsExceededException(maxIterations);\nret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\nreturn ret;\n}",
            "method_id": 19
        }
    ]
}