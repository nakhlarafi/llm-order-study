{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:<init>(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = Math.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.CONTINUE;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setMaximalIterationCount(I)V",
            "method_body": "public void setMaximalIterationCount(int count) {\nmaximalIterationCount = count;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta,\nif (! vectorsInitialized) {\nif (v == null) {\nfinalizeStep();\nfor (int i = 0; i < interpolatedState.length; ++i) {\nfinal double yDot1  = yDotK[0][i];\nfinal double yDot6  = yDotK[5][i];\nfinal double yDot7  = yDotK[6][i];\nfinal double yDot8  = yDotK[7][i];\nfinal double yDot9  = yDotK[8][i];\nfinal double yDot10 = yDotK[9][i];\nfinal double yDot11 = yDotK[10][i];\nfinal double yDot12 = yDotK[11][i];\nfinal double yDot13 = yDotK[12][i];\nfinal double yDot14 = yDotKLast[0][i];\nfinal double yDot15 = yDotKLast[1][i];\nfinal double yDot16 = yDotKLast[2][i];\nv[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\nv[1][i] = yDot1 - v[0][i];\nv[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\nfor (int k = 0; k < D.length; ++k) {\nv[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\nvectorsInitialized = true;\nfinal double eta      = 1 - theta;\nfinal double twoTheta = 2 * theta;\nfinal double theta2   = theta * theta;\nfinal double dot1 = 1 - twoTheta;\nfinal double dot2 = theta * (2 - 3 * theta);\nfinal double dot3 = twoTheta * (1 + theta * (twoTheta -3));\nfinal double dot4 = theta2 * (3 + theta * (5 * theta - 8));\nfinal double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\nfinal double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\nfor (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = currentState[i] -\ninterpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:<init>(ID)V",
            "method_body": "protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nthis.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\nthis.defaultRelativeAccuracy = 1.0e-14;\nthis.absoluteAccuracy = defaultAbsoluteAccuracy;\nthis.relativeAccuracy = defaultRelativeAccuracy;\nthis.defaultMaximalIterationCount = defaultMaximalIterationCount;\nthis.maximalIterationCount = defaultMaximalIterationCount;\nthis.iterationCount = 0;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>(Lorg/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator;)V",
            "method_body": "public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\nsuper(interpolator);\nif (interpolator.currentState == null) {\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:<init>(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/sampling/StepInterpolator;)V",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nif (ga * gb > 0) {\nincreasing = gb >= ga;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\nreturn false;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZ)V",
            "method_body": "public void reinitialize(final AbstractIntegrator rkIntegrator,\nreinitialize(y, forward);\nthis.yDotK = yDotArray;\nthis.integrator = rkIntegrator;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(double t, double[] y, double[] dot)\nMultistepIntegrator.this.computeDerivatives(t, y, dot);\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getCurrentStepStart()D",
            "method_body": "public double getCurrentStepStart() {\nreturn stepStart;\n}",
            "method_id": 89
        }
    ]
}