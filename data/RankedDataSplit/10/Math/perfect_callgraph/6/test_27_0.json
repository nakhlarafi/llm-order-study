{
    "bug_id": 6,
    "test_id": 27,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.testSumSinc",
    "test_body": "public void testSumSinc() {\nfinal MultivariateFunction func = new SumSincFunction(-1);\n54: int dim = 2;\nfinal double[] minPoint = new double[dim];\nfor (int i = 0; i < dim; i++) {\nminPoint[i] = 0;\n}\n60: double[] init = new double[dim];\n62: // Initial is minimum.\nfor (int i = 0; i < dim; i++) {\ninit[i] = minPoint[i];\n}\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);\n68: // Initial is far from minimum.\nfor (int i = 0; i < dim; i++) {\ninit[i] = minPoint[i] + 3;\n}\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);\n// More stringent line search tolerance enhances the precision\n// of the result.\ndoTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.doTest(PowellOptimizerTest.java:266)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.testSumSinc(PowellOptimizerTest.java:75)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\nfinal GoalType goal = getGoalType();\nfinal double[] guess = getStartPoint();\nfinal int n = guess.length;\nfinal double[][] direc = new double[n][n];\nfor (int i = 0; i < n; i++) {\ndirec[i][i] = 1;\nfinal ConvergenceChecker<PointValuePair> checker\ndouble[] x = guess;\ndouble fVal = computeObjectiveValue(x);\ndouble[] x1 = x.clone();\nint iter = 0;\n++iter;\ndouble fX = fVal;\ndouble fX2 = 0;\ndouble delta = 0;\nint bigInd = 0;\ndouble alphaMin = 0;\nfor (int i = 0; i < n; i++) {\nfinal double[] d = MathArrays.copyOf(direc[i]);\nfX2 = fVal;\nfinal UnivariatePointValuePair optimum = line.search(x, d);\nfVal = optimum.getValue();\nalphaMin = optimum.getPoint();\nfinal double[][] result = newPointAndDirection(x, d, alphaMin);\nx = result[0];\nif ((fX2 - fVal) > delta) {\ndelta = fX2 - fVal;\nbigInd = i;\nboolean stop = 2 * (fX - fVal) <=\nfinal PointValuePair previous = new PointValuePair(x1, fX);\nfinal PointValuePair current = new PointValuePair(x, fVal);\nif (!stop) { // User-defined stopping criteria.\nif (checker != null) {\nif (stop) {\nif (goal == GoalType.MINIMIZE) {\nreturn (fVal < fX) ? current : previous;\nfinal double[] d = new double[n];\nfinal double[] x2 = new double[n];\nfor (int i = 0; i < n; i++) {\nd[i] = x[i] - x1[i];\nx2[i] = 2 * x[i] - x1[i];\nx1 = x.clone();\nfX2 = computeObjectiveValue(x2);\nif (fX > fX2) {\ndouble t = 2 * (fX + fX2 - 2 * fVal);\ndouble temp = fX - fVal - delta;\nt *= temp * temp;\ntemp = fX - fX2;\nt -= delta * temp * temp;\nif (t < 0.0) {\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer:<init>(DD)V",
            "method_body": "public PowellOptimizer(double rel,\nthis(rel, abs, null);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nmaxEval = max;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer:<init>(DDDD)V",
            "method_body": "public PowellOptimizer(double rel,\nthis(rel, abs, lineRel, lineAbs, null);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker:<init>(DD)V",
            "method_body": "public SimpleUnivariateValueChecker(final double relativeThreshold,\nsuper(relativeThreshold, absoluteThreshold);\nmaxIterationCount = ITERATION_CHECK_DISABLED;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.univariate.BracketFinder:<init>()V",
            "method_body": "public BracketFinder() {\nthis(100, 50);\n}",
            "method_id": 9
        }
    ]
}