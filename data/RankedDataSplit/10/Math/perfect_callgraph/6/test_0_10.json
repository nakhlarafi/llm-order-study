{
    "bug_id": 6,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:getValueRef()[D",
            "method_body": "public double[] getValueRef() {\nreturn super.getValue();\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math3.linear.LUDecomposition:getSolver()Lorg/apache/commons/math3/linear/DecompositionSolver;",
            "method_body": "public DecompositionSolver getSolver() {\nreturn new Solver(lu, pivot, singular);\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nreturn super.optimize(optData);\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math3/linear/RealVector;)D",
            "method_body": "public double dotProduct(RealVector v) throws DimensionMismatchException {\nif (v instanceof ArrayRealVector) {\nfinal double[] vData = ((ArrayRealVector) v).data;\ncheckVectorDimensions(vData.length);\ndouble dot = 0;\nfor (int i = 0; i < data.length; i++) {\ndot += data[i] * vData[i];\nreturn dot;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.math3.linear.LUDecomposition$Solver:solve(Lorg/apache/commons/math3/linear/RealVector;)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector solve(RealVector b) {\nfinal int m = pivot.length;\nif (b.getDimension() != m) {\nif (singular) {\nfinal double[] bp = new double[m];\nfor (int row = 0; row < m; row++) {\nbp[row] = b.getEntry(pivot[row]);\nfor (int col = 0; col < m; col++) {\nfinal double bpCol = bp[col];\nfor (int i = col + 1; i < m; i++) {\nfor (int col = m - 1; col >= 0; col--) {\nbp[col] /= lu[col][col];\nfinal double bpCol = bp[col];\nfor (int i = 0; i < col; i++) {\nreturn new ArrayRealVector(bp, false);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:operate([D)[D",
            "method_body": "public double[] operate(final double[] v)\nreturn multiply(new DiagonalMatrix(v, false)).getDataRef();\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:computeJacobian([D)[[D",
            "method_body": "protected double[][] computeJacobian(final double[] params) {\nreturn jacobian.value(params);\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getRelativeThreshold()D",
            "method_body": "public double getRelativeThreshold() {\nreturn relativeThreshold;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>(II[[DZ)V",
            "method_body": "public BlockRealMatrix(final int rows, final int columns,\nsuper(rows, columns);\nthis.rows = rows;\nthis.columns = columns;\nblockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\nif (copyArray) {\nblocks = blockData;\nint index = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int iHeight = blockHeight(iBlock);\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\nif (blockData[index].length != iHeight * blockWidth(jBlock)) {\nif (copyArray) {\n}",
            "method_id": 109
        }
    ]
}