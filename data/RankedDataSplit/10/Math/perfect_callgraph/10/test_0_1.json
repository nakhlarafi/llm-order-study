{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest.testAtan2SpecialCases",
    "test_body": "public void testAtan2SpecialCases() {\n813: DerivativeStructure pp =\nDerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\nnew DerivativeStructure(2, 2, 1, +0.0));\nAssert.assertEquals(0, pp.getValue(), 1.0e-15);\nAssert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.0> but was:<NaN>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest.testAtan2SpecialCases(DerivativeStructureTest.java:816)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DerivativeStructure:atan2(Lorg/apache/commons/math3/analysis/differentiation/DerivativeStructure;Lorg/apache/commons/math3/analysis/differentiation/DerivativeStructure;)Lorg/apache/commons/math3/analysis/differentiation/DerivativeStructure;",
            "method_body": "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\ny.compiler.checkCompatibility(x.compiler);\nfinal DerivativeStructure result = new DerivativeStructure(y.compiler);\ny.compiler.atan2(y.data, 0, x.data, 0, result.data, 0);\nreturn result;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DerivativeStructure:getValue()D",
            "method_body": "public double getValue() {\nreturn data[0];\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:divide([DI[DI[DI)V",
            "method_body": "public void divide(final double[] lhs, final int lhsOffset,\nfinal double[] reciprocal = new double[getSize()];\npow(rhs, lhsOffset, -1, reciprocal, 0);\nmultiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:multiply([DI[DI[DI)V",
            "method_body": "public void multiply(final double[] lhs, final int lhsOffset,\nfor (int i = 0; i < multIndirection.length; ++i) {\nfinal int[][] mappingI = multIndirection[i];\ndouble r = 0;\nfor (int j = 0; j < mappingI.length; ++j) {\nr += mappingI[j][0] *\nresult[resultOffset + i] = r;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:rootN([DII[DI)V",
            "method_body": "public void rootN(final double[] operand, final int operandOffset, final int n,\ndouble[] function = new double[1 + order];\nif (n == 2) {\nfunction[0] = FastMath.sqrt(operand[operandOffset]);\nxk          = 0.5 / function[0];\nfinal double nReciprocal = 1.0 / n;\nfinal double xReciprocal = 1.0 / operand[operandOffset];\nfor (int i = 1; i <= order; ++i) {\nfunction[i] = xk;\nxk *= xReciprocal * (nReciprocal - i);\ncompose(operand, operandOffset, function, result, resultOffset);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DerivativeStructure:<init>(Lorg/apache/commons/math3/analysis/differentiation/DSCompiler;)V",
            "method_body": "private DerivativeStructure(final DSCompiler compiler) {\nthis.compiler = compiler;\nthis.data     = new double[compiler.getSize()];\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:add([DI[DI[DI)V",
            "method_body": "public void add(final double[] lhs, final int lhsOffset,\nfor (int i = 0; i < getSize(); ++i) {\nresult[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:checkCompatibility(Lorg/apache/commons/math3/analysis/differentiation/DSCompiler;)V",
            "method_body": "public void checkCompatibility(final DSCompiler compiler)\nif (parameters != compiler.parameters) {\nif (order != compiler.order) {\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:compose([DI[D[DI)V",
            "method_body": "public void compose(final double[] operand, final int operandOffset, final double[] f,\nfor (int i = 0; i < compIndirection.length; ++i) {\nfinal int[][] mappingI = compIndirection[i];\ndouble r = 0;\nfor (int j = 0; j < mappingI.length; ++j) {\nfinal int[] mappingIJ = mappingI[j];\ndouble product = mappingIJ[0] * f[mappingIJ[1]];\nfor (int k = 2; k < mappingIJ.length; ++k) {\nproduct *= operand[operandOffset + mappingIJ[k]];\nr += product;\nresult[resultOffset + i] = r;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.differentiation.DSCompiler:pow([DII[DI)V",
            "method_body": "public void pow(final double[] operand, final int operandOffset, final int n,\nif (n == 0) {\ndouble[] function = new double[1 + order];\nif (n > 0) {\nfinal double inv = 1.0 / operand[operandOffset];\ndouble xk = FastMath.pow(inv, -n);\nfor (int i = 0; i <= order; ++i) {\nfunction[i] = xk;\nxk *= inv;\ndouble coefficient = n;\nfor (int i = 1; i <= order; ++i) {\nfunction[i] *= coefficient;\ncoefficient *= n - i;\ncompose(operand, operandOffset, function, result, resultOffset);\n}",
            "method_id": 19
        }
    ]
}