{
    "bug_id": 44,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.events.EventStateTest.testIssue695",
    "test_body": "public void testIssue695() {\n82: FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n84: public int getDimension() {\nreturn 1;\n}\n88: public void computeDerivatives(double t, double[] y, double[] yDot) {\nyDot[0] = 1.0;\n}\n};\n93: DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\nintegrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\nintegrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\nintegrator.setInitialStepSize(3.0);\n98: double target = 30.0;\ndouble[] y = new double[1];\ndouble tEnd = integrator.integrate(equation, 0.0, y, target, y);\nAssert.assertEquals(target, tEnd, 1.0e-10);",
    "stack_trace": "junit.framework.AssertionFailedError: going backard in time! (7.796578226186635 < 10.99)\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math.ode.events.EventStateTest$ResettingEvent.g(EventStateTest.java:120)\nat org.apache.commons.math.ode.events.EventState.evaluateStep(EventState.java:214)\nat org.apache.commons.math.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:302)\nat org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:296)\nat org.apache.commons.math.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:213)\nat org.apache.commons.math.ode.events.EventStateTest.testIssue695(EventStateTest.java:100)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getRelativeAccuracy()D",
            "method_body": "public double getRelativeAccuracy() {\nreturn relativeAccuracy;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getMin()D",
            "method_body": "public double getMin() {\nreturn searchMin;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math.ode.EquationsMapper:extractEquationData([D[D)V",
            "method_body": "public void extractEquationData(double[] complete, double[] equationData)\nif (equationData.length != dimension) {\nSystem.arraycopy(complete, firstIndex, equationData, 0, dimension);\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZLorg/apache/commons/math/ode/EquationsMapper;[Lorg/apache/commons/math/ode/EquationsMapper;)V",
            "method_body": "public void reinitialize(final AbstractIntegrator integrator,\nsuper.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\nfinal int dimension = currentState.length;\nyDotKLast = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k]  = new double[dimension];\nvectorsInitialized = false;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(ILorg/apache/commons/math/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:setPrimaryState([D)V",
            "method_body": "public void setPrimaryState(final double[] primaryState) throws DimensionMismatchException {\nif (primaryState.length != this.primaryState.length) {\nSystem.arraycopy(primaryState, 0, this.primaryState, 0, primaryState.length);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nif (y0.length != equations.getDimension()) {\nif (y.length != equations.getDimension()) {\nfinal ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\nexpandableODE.setTime(t0);\nexpandableODE.setPrimaryState(y0);\nintegrate(expandableODE, t);\nSystem.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\nreturn expandableODE.getTime();\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 89
        }
    ]
}