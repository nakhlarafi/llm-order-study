{
    "bug_id": 82,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest.testMath288",
    "test_body": "public void testMath288() throws OptimizationException {\nLinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );\nCollection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\nconstraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));\nconstraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));\nconstraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));\nconstraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));\nconstraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n71: SimplexSolver solver = new SimplexSolver();\nRealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\nassertEquals(10.0, solution.getValue(), .0000001);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<10.0> but was:<11.5>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math.optimization.linear.SimplexSolverTest.testMath288(SimplexSolverTest.java:73)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:getNumObjectiveFunctions()I",
            "method_body": "protected final int getNumObjectiveFunctions() {\nreturn this.numArtificialVariables > 0 ? 2 : 1;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:getConstraintTypeCounts(Lorg/apache/commons/math/optimization/linear/Relationship;)I",
            "method_body": "private int getConstraintTypeCounts(final Relationship relationship) {\nint count = 0;\nfor (final LinearConstraint constraint : constraints) {\nif (constraint.getRelationship() == relationship) {\n++count;\nreturn count;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:compareTo(DDD)I",
            "method_body": "public static int compareTo(double x, double y, double eps) {\nif (equals(x, y, eps)) {\nreturn 0;\n} else if (x < y) {\nreturn -1;\nreturn 1;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.optimization.RealPointValuePair:getValue()D",
            "method_body": "public double getValue() {\nreturn value;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:createTableau(Z)[[D",
            "method_body": "protected double[][] createTableau(final boolean maximize) {\nList<LinearConstraint> constraints = getNormalizedConstraints();\nint width = numDecisionVariables + numSlackVariables +\nint height = constraints.size() + getNumObjectiveFunctions();\ndouble[][] matrix = new double[height][width];\nif (getNumObjectiveFunctions() == 2) {\nint zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\nmatrix[zIndex][zIndex] = maximize ? 1 : -1;\nRealVector objectiveCoefficients =\ncopyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\nmatrix[zIndex][width - 1] =\nif (!restrictToNonNegative) {\nint slackVar = 0;\nint artificialVar = 0;\nfor (int i = 0; i < constraints.size(); i++) {\nLinearConstraint constraint = constraints.get(i);\nint row = getNumObjectiveFunctions() + i;\ncopyArray(constraint.getCoefficients().getData(), matrix[row], 1);\nif (!restrictToNonNegative) {\nmatrix[row][width - 1] = constraint.getValue();\nif (constraint.getRelationship() == Relationship.LEQ) {\nmatrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\nif ((constraint.getRelationship() == Relationship.EQ) ||\nreturn matrix;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:divideRow(ID)V",
            "method_body": "protected void divideRow(final int dividendRow, final double divisor) {\nfor (int j = 0; j < getWidth(); j++) {\ntableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in) {\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:getEntry(II)D",
            "method_body": "protected final double getEntry(final int row, final int column) {\nreturn tableau.getEntry(row, column);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexSolver:doIteration(Lorg/apache/commons/math/optimization/linear/SimplexTableau;)V",
            "method_body": "protected void doIteration(final SimplexTableau tableau)\nincrementIterationsCounter();\nInteger pivotCol = getPivotColumn(tableau);\nInteger pivotRow = getPivotRow(pivotCol, tableau);\nif (pivotRow == null) {\ndouble pivotVal = tableau.getEntry(pivotRow, pivotCol);\ntableau.divideRow(pivotRow, pivotVal);\nfor (int i = 0; i < tableau.getHeight(); i++) {\nif (i != pivotRow) {\ndouble multiplier = tableau.getEntry(i, pivotCol);\ntableau.subtractRow(i, pivotRow, multiplier);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer:setMaxIterations(I)V",
            "method_body": "public void setMaxIterations(int maxIterations) {\nthis.maxIterations = maxIterations;\n}",
            "method_id": 39
        }
    ]
}