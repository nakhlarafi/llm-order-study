{
    "bug_id": 42,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest.testMath713NegativeVariable",
    "test_body": "public void testMath713NegativeVariable() {\nLinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);\nArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\nconstraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));\n38: double epsilon = 1e-6;\nSimplexSolver solver = new SimplexSolver();\nRealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n42: Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);\nAssert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.optimization.linear.SimplexSolverTest.testMath713NegativeVariable(SimplexSolverTest.java:43)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:divideRow(ID)V",
            "method_body": "protected void divideRow(final int dividendRow, final double divisor) {\nfor (int j = 0; j < getWidth(); j++) {\ntableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:getArtificialVariableOffset()I",
            "method_body": "protected final int getArtificialVariableOffset() {\nreturn getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:getRow(I)[D",
            "method_body": "public double[] getRow(final int row) {\nMatrixUtils.checkRowIndex(this, row);\nfinal int nCols = getColumnDimension();\nfinal double[] out = new double[nCols];\nfor (int i = 0; i < nCols; ++i) {\nout[i] = getEntry(row, i);\nreturn out;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math.linear.RealVector:mapMultiply(D)Lorg/apache/commons/math/linear/RealVector;",
            "method_body": "public RealVector mapMultiply(double d) {\nreturn copy().mapMultiplyToSelf(d);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexSolver:doIteration(Lorg/apache/commons/math/optimization/linear/SimplexTableau;)V",
            "method_body": "protected void doIteration(final SimplexTableau tableau)\nincrementIterationsCounter();\nInteger pivotCol = getPivotColumn(tableau);\nInteger pivotRow = getPivotRow(tableau, pivotCol);\nif (pivotRow == null) {\ndouble pivotVal = tableau.getEntry(pivotRow, pivotCol);\ntableau.divideRow(pivotRow, pivotVal);\nfor (int i = 0; i < tableau.getHeight(); i++) {\nif (i != pivotRow) {\ndouble multiplier = tableau.getEntry(i, pivotCol);\ntableau.subtractRow(i, pivotRow, multiplier);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer:setMaxIterations(I)V",
            "method_body": "public void setMaxIterations(int maxIterations) {\nthis.maxIterations = maxIterations;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexSolver:solvePhase1(Lorg/apache/commons/math/optimization/linear/SimplexTableau;)V",
            "method_body": "protected void solvePhase1(final SimplexTableau tableau)\nif (tableau.getNumArtificialVariables() == 0) {\nwhile (!tableau.isOptimal()) {\ndoIteration(tableau);\nif (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math.optimization.linear.SimplexTableau:normalize(Lorg/apache/commons/math/optimization/linear/LinearConstraint;)Lorg/apache/commons/math/optimization/linear/LinearConstraint;",
            "method_body": "private LinearConstraint normalize(final LinearConstraint constraint) {\nif (constraint.getValue() < 0) {\nreturn new LinearConstraint(constraint.getCoefficients(),\n}",
            "method_id": 59
        }
    ]
}