{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testMath864",
    "test_body": "public void testMath864() {\nfinal CMAESOptimizer optimizer = new CMAESOptimizer();\nfinal MultivariateFunction fitnessFunction = new MultivariateFunction() {\n@Override\npublic double value(double[] parameters) {\nfinal double target = 1;\nfinal double error = target - parameters[0];\nreturn error * error;\n}\n};\n395: final double[] start = { 0 };\nfinal double[] lower = { -1e6 };\nfinal double[] upper = { 0.5 };\nfinal double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\nstart, lower, upper).getPoint();\nAssert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\nresult[0] <= upper[0]);",
    "stack_trace": "junit.framework.AssertionFailedError: Out of bounds (0.5246031767455861 > 0.5)\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testMath864(CMAESOptimizerTest.java:400)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:getQT()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getQT() {\nif (cachedQt == null) {\nfinal int m = householderVectors.length;\ndouble[][] qta = new double[m][m];\nfor (int k = m - 1; k >= 1; --k) {\nqta[0][0] = 1;\ncachedQt = MatrixUtils.createRealMatrix(qta);\nreturn cachedQt;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa, xb);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:penalty([D[D)D",
            "method_body": "private double penalty(final double[] x, final double[] repaired) {\ndouble penalty = 0;\nfor (int i = 0; i < x.length; i++) {\ndouble diff = Math.abs(x[i] - repaired[i]);\npenalty += diff * valueRange;\nreturn isMinimize ? penalty : -penalty;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:updateBD(D)V",
            "method_body": "private void updateBD(double negccov) {\nif (ccov1 + ccovmu + negccov > 0 &&\nC = triu(C, 0).add(triu(C, 1).transpose());\nEigenDecomposition eig = new EigenDecomposition(C);\nB = eig.getV(); // eigen decomposition, B==normalized eigenvectors\nD = eig.getD();\ndiagD = diag(D);\nif (min(diagD) <= 0) {\nif (max(diagD) > 1e14 * min(diagD)) {\ndiagC = diag(C);\ndiagD = sqrt(diagD); // D contains standard deviations now\nBD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:inverse([I)[I",
            "method_body": "private static int[] inverse(final int[] indices) {\nint[] inverse = new int[indices.length];\nfor (int i = 0; i < indices.length; i++) {\ninverse[indices[i]] = i;\nreturn inverse;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\nreturn out;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:transformToTridiagonal(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void transformToTridiagonal(final RealMatrix matrix) {\ntransformer = new TriDiagonalTransformer(matrix);\nmain = transformer.getMainDiagonalRef();\nsecondary = transformer.getSecondaryDiagonalRef();\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:getMaxEvaluations()I",
            "method_body": "public int getMaxEvaluations() {\nreturn evaluations.getMaximalCount();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 19
        }
    ]
}