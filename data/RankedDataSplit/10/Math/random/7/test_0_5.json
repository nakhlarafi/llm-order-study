{
    "bug_id": 7,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling",
    "test_body": "public void testEventsScheduling() {\n339: FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n341: public int getDimension() {\nreturn 2;\n}\n345: public void computeDerivatives(double t, double[] y, double[] yDot) {\nyDot[0] =  y[1];\nyDot[1] = -y[0];\n}\n350: };\n352: SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\nSchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n355: FirstOrderIntegrator integ =\nnew DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\ninteg.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\ninteg.addStepHandler(sinChecker);\ninteg.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\ninteg.addStepHandler(cosChecker);\ndouble   t0 = 0.5;\ndouble[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\ndouble   t  = 10.0;\ndouble[] y  = new double[2];\ninteg.integrate(sincos, t0, y0, t, y);\n367: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest$SchedulingChecker.g(DormandPrince853IntegratorTest.java:389)\nat org.apache.commons.math3.ode.events.EventState.evaluateStep(EventState.java:224)\nat org.apache.commons.math3.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:323)\nat org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:303)\nat org.apache.commons.math3.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:228)\nat org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling(DormandPrince853IntegratorTest.java:365)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:verifySequence(DDD)V",
            "method_body": "public static void verifySequence(final double lower,\nverifyInterval(lower, initial);\nverifyInterval(initial, upper);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize() throws MaxCountExceededException {\nif (currentState == null) {\nreturn;\nfinal double[] yTmp = new double[currentState.length];\nfinal double pT = getGlobalPreviousTime();\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:shift()V",
            "method_body": "public void shift() {\nglobalPreviousTime = globalCurrentTime;\nsoftPreviousTime   = globalPreviousTime;\nsoftCurrentTime    = globalCurrentTime;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver:doSolve()D",
            "method_body": "protected double doSolve()\nfinal double[] x = new double[maximalOrder + 1];\nfinal double[] y = new double[maximalOrder + 1];\nx[0] = getMin();\nx[1] = getStartValue();\nx[2] = getMax();\nverifySequence(x[0], x[1], x[2]);\ny[1] = computeObjectiveValue(x[1]);\nif (Precision.equals(y[1], 0.0, 1)) {\ny[0] = computeObjectiveValue(x[0]);\nif (Precision.equals(y[0], 0.0, 1)) {\nif (y[0] * y[1] < 0) {\ny[2] = computeObjectiveValue(x[2]);\nif (Precision.equals(y[2], 0.0, 1)) {\nif (y[1] * y[2] < 0) {\nnbPoints        = 3;\nsignChangeIndex = 2;\nfinal double[] tmpX = new double[x.length];\ndouble xA    = x[signChangeIndex - 1];\ndouble yA    = y[signChangeIndex - 1];\ndouble absYA = FastMath.abs(yA);\nint agingA   = 0;\ndouble xB    = x[signChangeIndex];\ndouble yB    = y[signChangeIndex];\ndouble absYB = FastMath.abs(yB);\nint agingB   = 0;\nfinal double xTol = getAbsoluteAccuracy() +\nif (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\nswitch (allowed) {\nreturn xB;\nif (agingA >= MAXIMAL_AGING) {\nfinal int p = agingA - MAXIMAL_AGING;\nfinal double weightA = (1 << p) - 1;\nfinal double weightB = p + 1;\ntargetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n} else if (agingB >= MAXIMAL_AGING) {\ntargetY = 0;\nint start = 0;\nint end   = nbPoints;\nSystem.arraycopy(x, start, tmpX, start, end - start);\nnextX = guessX(targetY, tmpX, y, start, end);\nif (!((nextX > xA) && (nextX < xB))) {\n} while (Double.isNaN(nextX) && (end - start > 1));\nif (Double.isNaN(nextX)) {\nfinal double nextY = computeObjectiveValue(nextX);\nif (Precision.equals(nextY, 0.0, 1)) {\nif ((nbPoints > 2) && (end - start != nbPoints)) {\n} else  if (nbPoints == x.length) {\nSystem.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\nx[signChangeIndex] = nextX;\nSystem.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\ny[signChangeIndex] = nextY;\n++nbPoints;\nif (nextY * yA <= 0) {\nxB = nextX;\nyB = nextY;\nabsYB = FastMath.abs(yB);\n++agingA;\nagingB = 0;\nxA = nextX;\nyA = nextY;\nabsYA = FastMath.abs(yA);\nagingA = 0;\n++agingB;\nsignChangeIndex++;\n}\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.RungeKuttaStepInterpolator:shift()V",
            "method_body": "public void shift() {\npreviousState = currentState.clone();\nsuper.shift();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator:<init>()V",
            "method_body": "protected AbstractStepInterpolator() {\nglobalPreviousTime = Double.NaN;\nglobalCurrentTime  = Double.NaN;\nsoftPreviousTime   = Double.NaN;\nsoftCurrentTime    = Double.NaN;\nh                  = Double.NaN;\ninterpolatedTime   = Double.NaN;\ncurrentState       = null;\nfinalized          = false;\nthis.forward       = true;\nthis.dirtyState    = true;\nprimaryMapper      = null;\nsecondaryMappers   = null;\nallocateInterpolatedArrays(-1);\n}",
            "method_id": 59
        }
    ]
}