{
    "bug_id": 2,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.HypergeometricDistributionTest.testMath1021",
    "test_body": "public void testMath1021() {\nfinal int N = 43130568;\nfinal int m = 42976365;\nfinal int n = 50;\nfinal HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);\n295: for (int i = 0; i < 100; i++) {\nfinal int sample = dist.sample();\nAssert.assertTrue(\"sample=\" + sample, 0 <= sample);\nAssert.assertTrue(\"sample=\" + sample, sample <= n);",
    "stack_trace": "junit.framework.AssertionFailedError: sample=-50\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math3.distribution.HypergeometricDistributionTest.testMath1021(HypergeometricDistributionTest.java:297)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:clear()V",
            "method_body": "public void clear() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.HypergeometricDistribution:getSupportUpperBound()I",
            "method_body": "public int getSupportUpperBound() {\nreturn FastMath.min(getNumberOfSuccesses(), getSampleSize());\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;)V",
            "method_body": "protected AbstractIntegerDistribution(RandomGenerator rng) {\nrandom = rng;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.HypergeometricDistribution:getPopulationSize()I",
            "method_body": "public int getPopulationSize() {\nreturn populationSize;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution:sample()I",
            "method_body": "public int sample() {\nreturn inverseCumulativeProbability(random.nextDouble());\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution:inverseCumulativeProbability(D)I",
            "method_body": "public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\nif (p < 0.0 || p > 1.0) {\nint lower = getSupportLowerBound();\nif (p == 0.0) {\nif (lower == Integer.MIN_VALUE) {\nlower -= 1; // this ensures cumulativeProbability(lower) < p, which\nint upper = getSupportUpperBound();\nif (p == 1.0) {\nfinal double mu = getNumericalMean();\nfinal double sigma = FastMath.sqrt(getNumericalVariance());\nfinal boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\nif (chebyshevApplies) {\ndouble k = FastMath.sqrt((1.0 - p) / p);\ndouble tmp = mu - k * sigma;\nif (tmp > lower) {\nk = 1.0 / k;\ntmp = mu + k * sigma;\nif (tmp < upper) {\nupper = ((int) Math.ceil(tmp)) - 1;\nreturn solveInverseCumulativeProbability(p, lower, upper);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.random.Well19937c:next(I)I",
            "method_body": "protected int next(final int bits) {\nfinal int indexRm1 = iRm1[index];\nfinal int indexRm2 = iRm2[index];\nfinal int v0       = v[index];\nfinal int vM1      = v[i1[index]];\nfinal int vM2      = v[i2[index]];\nfinal int vM3      = v[i3[index]];\nfinal int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);\nfinal int z1 = (v0 ^ (v0 << 25))  ^ (vM1 ^ (vM1 >>> 27));\nfinal int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));\nfinal int z3 = z1      ^ z2;\nint z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));\nv[index]     = z3;\nv[indexRm1]  = z4;\nv[indexRm2] &= 0x80000000;\nindex        = indexRm1;\nz4 = z4 ^ ((z4 <<  7) & 0xe46e1700);\nz4 = z4 ^ ((z4 << 15) & 0x9b868000);\nreturn z4 >>> (32 - bits);\n}",
            "method_id": 9
        }
    ]
}