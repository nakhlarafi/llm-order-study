{
    "bug_id": 37,
    "test_id": 2,
    "test_name": "org.apache.commons.math.complex.ComplexTest.testTanh",
    "test_body": "public void testTanh() {\nComplex z = new Complex(3, 4);\nComplex expected = new Complex(1.00071, 0.00490826);\nTestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n/* Check that no overflow occurs (MATH-722) */\nComplex actual = new Complex(1E10, 3.0).tanh();\nexpected = new Complex(1, 0);\nTestUtils.assertEquals(expected, actual, 1.0e-5);\nactual = new Complex(-1E10, 3.0).tanh();",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1.0> but was:<NaN>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math.TestUtils.assertEquals(TestUtils.java:94)\nat org.apache.commons.math.complex.ComplexTest.testTanh(ComplexTest.java:1039)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:tanh()Lorg/apache/commons/math/complex/Complex;",
            "method_body": "public Complex tanh() {\nif (isNaN) {\ndouble real2 = 2.0 * real;\ndouble imaginary2 = 2.0 * imaginary;\ndouble d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\nreturn createComplex(FastMath.sinh(real2) / d,\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getReal()D",
            "method_body": "public double getReal() {\nreturn real;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\ndouble a = 0;\ndouble b = 0;\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nb = b + sintA * cosEpsB + costA * sinEpsB;\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\nresult = a + b;\nreturn result;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getImaginary()D",
            "method_body": "public double getImaginary() {\nreturn imaginary;\n}",
            "method_id": 14
        }
    ]
}