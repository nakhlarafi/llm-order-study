{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:<init>(Lorg/apache/commons/math/ode/MultistepIntegrator;I)V",
            "method_body": "public CountingDifferentialEquations(final int dimension) {\nthis.dimension = dimension;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nif (ga * gb > 0) {\nincreasing = gb >= ga;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\nreturn false;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:sanityChecks(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)V",
            "method_body": "protected void sanityChecks(final FirstOrderDifferentialEquations equations,\nsuper.sanityChecks(equations, t0, y0, t, y);\nif ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\nif ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEventTime;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\ncurrentTime = t;\nh           = currentTime - previousTime;\nsetInterpolatedTime(t);\nfinalized  = false;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:<init>(ID)V",
            "method_body": "protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\nsuper(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\nthis.defaultFunctionValueAccuracy = 1.0e-15;\nthis.functionValueAccuracy = defaultFunctionValueAccuracy;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:reinitialize([DZ)V",
            "method_body": "protected void reinitialize(final double[] y, final boolean isForward) {\npreviousTime      = Double.NaN;\ncurrentTime       = Double.NaN;\nh                 = Double.NaN;\ninterpolatedTime  = Double.NaN;\ncurrentState            = y;\ninterpolatedState       = new double[y.length];\ninterpolatedDerivatives = new double[y.length];\nfinalized         = false;\nthis.forward      = isForward;\nthis.dirtyState   = true;\n}",
            "method_id": 39
        }
    ]
}