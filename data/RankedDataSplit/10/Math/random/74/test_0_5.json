{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n140: for (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:filterStep(DZZ)D",
            "method_body": "protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\ndouble filteredH = h;\nif (Math.abs(h) < minStep) {\nif (filteredH > maxStep) {\nfilteredH = maxStep;\n} else if (filteredH < -maxStep) {\nreturn filteredH;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize()\nif (currentState == null) {\nreturn;\nfinal double[] yTmp = new double[currentState.length];\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nyTmp[j] = currentState[j] + h * s;\nintegrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:clearStepHandlers()V",
            "method_body": "public void clearStepHandlers() {\nstepHandlers.clear();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math.MathException:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public MathException(Throwable rootCause) {\nsuper(rootCause);\nthis.pattern   = getMessage();\nthis.arguments = new Object[0];\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal int n = y0.length;\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, n);\nfinal double[] yDot = new double[y0.length];\nfinal double[] yTmp = new double[y0.length];\nfinal NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\ninterpolator.reinitialize(y, forward);\nfinal NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\ninterpolatorTmp.reinitialize(yTmp, forward);\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nstart(t0, y, t);\ninterpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\ninterpolator.storeTime(stepStart);\ndouble hNew = stepSize;\ninterpolator.rescale(hNew);\nboolean lastStep = false;\nwhile (!lastStep) {\ninterpolator.shift();\ndouble error = 0;\nfor (boolean loop = true; loop;) {\nstepSize = hNew;\nfinal double stepEnd = stepStart + stepSize;\ninterpolator.setInterpolatedTime(stepEnd);\nSystem.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\ncomputeDerivatives(stepEnd, yTmp, yDot);\nfinal double[] predictedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\npredictedScaled[j] = stepSize * yDot[j];\nfinal Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\nupdateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\nerror = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\nif (error <= 1.0) {\ncomputeDerivatives(stepEnd, yTmp, yDot);\nfinal double[] correctedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\ncorrectedScaled[j] = stepSize * yDot[j];\nupdateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\ninterpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\ninterpolatorTmp.storeTime(stepStart);\ninterpolatorTmp.shift();\ninterpolatorTmp.storeTime(stepEnd);\nif (manager.evaluateStep(interpolatorTmp)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\nhNew = dt;\ninterpolator.rescale(hNew);\n} else {\nscaled    = correctedScaled;\nnordsieck = nordsieckTmp;\ninterpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\nloop = false;\n} else {\nfinal double factor = computeStepGrowShrinkFactor(error);\nhNew = filterStep(stepSize * factor, forward, false);\ninterpolator.rescale(hNew);\n}\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, n);\ninterpolator.storeTime(nextStep);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\nfor (StepHandler handler : stepHandlers) {\ninterpolator.setInterpolatedTime(nextStep);\nhandler.handleStep(interpolator, lastStep);\nstepStart = nextStep;\nif (!lastStep && manager.reset(stepStart, y)) {\nif (! lastStep) {\nstepSize = filterStep(stepSize, forward, true);\nfinal double  factor     = computeStepGrowShrinkFactor(error);\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\ninterpolator.rescale(hNew);\n}\nfinal double stopTime  = stepStart;\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\nreturn stopTime;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getMaxStep()D",
            "method_body": "public double getMaxStep() {\nreturn maxStep;\n}",
            "method_id": 59
        }
    ]
}