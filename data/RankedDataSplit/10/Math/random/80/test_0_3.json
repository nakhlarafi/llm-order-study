{
    "bug_id": 80,
    "test_id": 0,
    "test_name": "org.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02",
    "test_body": "public void testMathpbx02() {\n147: double[] mainTridiagonal = {\n7484.860960227216, 18405.28129035345, 13855.225609560746,\n10016.708722343366, 559.8117399576674, 6750.190788301587, \n71.21428769782159\n};\ndouble[] secondaryTridiagonal = {\n-4175.088570476366,1975.7955858241994,5193.178422374075, \n1995.286659169179,75.34535882933804,-234.0808002076056\n};\n157: // the reference values have been computed using routine DSTEMR\n// from the fortran library LAPACK version 3.2.1\ndouble[] refEigenValues = {\n20654.744890306974412,16828.208208485466457,\n6893.155912634994820,6757.083016675340332,\n5887.799885688558788,64.309089923240379,\n57.992628792736340\n};\nRealVector[] refEigenVectors = {\nnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\nnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\nnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\nnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\nnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\nnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\nnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n};\n175: // the following line triggers the exception\nEigenDecomposition decomposition =\nnew EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n179: double[] eigenValues = decomposition.getRealEigenvalues();\nfor (int i = 0; i < refEigenValues.length; ++i) {\nassertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\nif (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<16828.208208485466> but was:<20654.74511575945>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat junit.framework.TestCase.assertEquals(TestCase.java:288)\nat org.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02(EigenDecompositionImplTest.java:181)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:initialSplits(I)V",
            "method_body": "private void initialSplits(final int n) {\npingPong = 0;\nfor (int k = 0; k < 2; ++k) {\ndouble d = work[4 * (n - 1) + pingPong];\nfor (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\nif (work[i + 2] <= TOLERANCE_2 * d) {\nwork[i + 2] = -0.0;\nd = work[i];\nd *= work[i] / (d + work[i + 2]);\nd = work[pingPong];\nfor (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\nfinal int j = i - 2 * pingPong - 1;\nwork[j] = d + work[i];\nif (work[i] <= TOLERANCE_2 * d) {\nwork[i]     = -0.0;\nwork[j]     = d;\nwork[j + 2] = 0.0;\nd = work[i + 2];\n} else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\nfinal double tmp = work[i + 2] / work[j];\nwork[j + 2] = work[i] * tmp;\nd *= tmp;\n} else {\nwork[4 * n - 3 - pingPong] = d;\npingPong = 1 - pingPong;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:computeGershgorinCircles()V",
            "method_body": "private void computeGershgorinCircles() {\nfinal int m     = main.length;\nfinal int lowerStart = 4 * m;\nfinal int upperStart = 5 * m;\nlowerSpectra = Double.POSITIVE_INFINITY;\nupperSpectra = Double.NEGATIVE_INFINITY;\ndouble eMax = 0;\ndouble eCurrent = 0;\nfor (int i = 0; i < m - 1; ++i) {\nfinal double dCurrent = main[i];\nfinal double ePrevious = eCurrent;\neCurrent = Math.abs(secondary[i]);\neMax = Math.max(eMax, eCurrent);\nfinal double radius = ePrevious + eCurrent;\nfinal double lower = dCurrent - radius;\nwork[lowerStart + i] = lower;\nlowerSpectra = Math.min(lowerSpectra, lower);\nfinal double upper = dCurrent + radius;\nwork[upperStart + i] = upper;\nupperSpectra = Math.max(upperSpectra, upper);\nfinal double dCurrent = main[m - 1];\nfinal double lower = dCurrent - eCurrent;\nwork[lowerStart + m - 1] = lower;\nlowerSpectra = Math.min(lowerSpectra, lower);\nfinal double upper = dCurrent + eCurrent;\nwork[upperStart + m - 1] = upper;\nupperSpectra = Math.max(upperSpectra, upper);\nminPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math/linear/ArrayRealVector;)D",
            "method_body": "public double dotProduct(ArrayRealVector v)\nreturn dotProduct(v.data);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data) {\nreturn (data.length * data[0].length <= 4096) ?\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:getRealEigenvalues()[D",
            "method_body": "public double[] getRealEigenvalues()\nreturn realEigenvalues.clone();\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:progressiveQuotientDifferenceWithShift([D[DD)V",
            "method_body": "private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\nfinal int nM1 = d.length - 1;\ndouble pi = d[nM1] - lambda;\nint sixI = 6 * (nM1 - 1);\nfor (int i = nM1 - 1; i >= 0; --i) {\nfinal double di   = d[i];\nfinal double li   = l[i];\nfinal double diP1 = di * li * li + pi;\nfinal double t    = di / diP1;\nwork[sixI +  9]   = pi;\nwork[sixI + 10]   = diP1;\nwork[sixI +  5]   = li * t;\npi = pi * t - lambda;\nsixI -= 6;\nwork[3] = pi;\nwork[4] = pi;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:goodStep(II)I",
            "method_body": "private int goodStep(final int start, final int end) {\ng = 0.0;\nint deflatedEnd = end;\nfor (boolean deflating = true; deflating;) {\nif (start >= deflatedEnd) {\nreturn deflatedEnd;\nfinal int k = 4 * deflatedEnd + pingPong - 1;\nif ((start == deflatedEnd - 1) ||\nwork[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\ndeflatedEnd -= 1;\n} else if ((start == deflatedEnd - 2) ||\nif (work[k - 3] > work[k - 7]) {\nif (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\ndouble t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\ndouble s = work[k - 3] * (work[k - 5] / t);\nif (s <= t) {\ns = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\nt = work[k - 7] + (s + work[k - 5]);\nwork[k - 3] *= work[k - 7] / t;\nwork[k - 7]  = t;\nwork[4 * deflatedEnd - 8] = sigma + work[k - 7];\nwork[4 * deflatedEnd - 4] = sigma + work[k - 3];\ndeflatedEnd -= 2;\ndeflating = false;\n}\nfinal int l = 4 * deflatedEnd + pingPong - 1;\nif ((dMin <= 0) || (deflatedEnd < end)) {\nif (flipIfWarranted(deflatedEnd, 1)) {\ndMin2 = Math.min(dMin2, work[l - 1]);\nwork[l - 1] =\nwork[l - 2 * pingPong] =\nqMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\ndMin  = -0.0;\nif ((dMin < 0) ||\ncomputeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\nfor (boolean loop = true; loop;) {\ndqds(start, deflatedEnd);\nif ((dMin >= 0) && (dMin1 > 0)) {\nupdateSigma(tau);\nreturn deflatedEnd;\n} else if ((dMin < 0.0) &&\nwork[4 * deflatedEnd - 3 - pingPong] = 0.0;\ndMin = 0.0;\nupdateSigma(tau);\nreturn deflatedEnd;\n} else if (dMin < 0.0) {\nif (tType < -22) {\n} else if (dMin1 > 0.0) {\ntau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\ntType -= 11;\ntau *= 0.25;\ntType -= 12;\ndqd(start, deflatedEnd);\nreturn deflatedEnd;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:flipIfWarranted(II)Z",
            "method_body": "private boolean flipIfWarranted(final int n, final int step) {\nif (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\nint j = 4 * n - 1;\nfor (int i = 0; i < j; i += 4) {\nfor (int k = 0; k < 4; k += step) {\nfinal double tmp = work[i + k];\nwork[i + k] = work[j - k];\nwork[j - k] = tmp;\nj -= 4;\nreturn true;\nreturn false;\n}",
            "method_id": 39
        }
    ]
}