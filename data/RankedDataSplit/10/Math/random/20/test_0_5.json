{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testMath864",
    "test_body": "public void testMath864() {\nfinal CMAESOptimizer optimizer = new CMAESOptimizer();\nfinal MultivariateFunction fitnessFunction = new MultivariateFunction() {\n@Override\npublic double value(double[] parameters) {\nfinal double target = 1;\nfinal double error = target - parameters[0];\nreturn error * error;\n}\n};\n395: final double[] start = { 0 };\nfinal double[] lower = { -1e6 };\nfinal double[] upper = { 0.5 };\nfinal double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\nstart, lower, upper).getPoint();\nAssert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\nresult[0] <= upper[0]);",
    "stack_trace": "junit.framework.AssertionFailedError: Out of bounds (0.5246031767455861 > 0.5)\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testMath864(CMAESOptimizerTest.java:400)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:next(I)I",
            "method_body": "protected int next(int bits) {\nif (mti >= N) { // generate N words at one time\nint mtNext = mt[0];\nfor (int k = 0; k < N - M; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\nfor (int k = N - M; k < N - 1; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\ny = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\nmt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\nmti = 0;\ny = mt[mti++];\ny ^=  y >>> 11;\ny ^= (y <<   7) & 0x9d2c5680;\ny ^= (y <<  15) & 0xefc60000;\ny ^=  y >>> 18;\nreturn y >>> (32 - bits);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:updateCovariance(ZLorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;[ILorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void updateCovariance(boolean hsig, final RealMatrix bestArx,\ndouble negccov = 0;\nif (ccov1 + ccovmu > 0) {\nRealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\nRealMatrix roneu = pc.multiply(pc.transpose())\ndouble oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\noldFac += 1. - ccov1 - ccovmu;\nif (isActiveCMA) {\nnegccov = (1. - ccovmu) * 0.25 * mueff /\ndouble negminresidualvariance = 0.66;\ndouble negalphaold = 0.5; // where to make up for the variance\nint[] arReverseIndex = reverse(arindex);\nRealMatrix arzneg\nRealMatrix arnorms = sqrt(sumRows(square(arzneg)));\nint[] idxnorms = sortedIndices(arnorms.getRow(0));\nRealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\nint[] idxReverse = reverse(idxnorms);\nRealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\narnorms = divide(arnormsReverse, arnormsSorted);\nint[] idxInv = inverse(idxnorms);\nRealMatrix arnormsInv = selectColumns(arnorms, idxInv);\ndouble negcovMax = (1. - negminresidualvariance) /\nif (negccov > negcovMax) {\nnegccov = negcovMax;\narzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\nRealMatrix artmp = BD.multiply(arzneg);\nRealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\noldFac += negalphaold * negccov;\nC = C.scalarMultiply(oldFac)\n} else {\nupdateBD(negccov);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:max([D)D",
            "method_body": "private static double max(final double[] m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.length; r++) {\nif (max < m[r]) {\nmax = m[r];\nreturn max;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\nreturn sinQ(a, b);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:setColumnVector(ILorg/apache/commons/math3/linear/RealVector;)V",
            "method_body": "public void setColumnVector(final int column, final RealVector vector)\nMatrixUtils.checkColumnIndex(this, column);\nfinal int nRows = getRowDimension();\nif (vector.getDimension() != nRows) {\nfor (int i = 0; i < nRows; ++i) {\nsetEntry(i, column, vector.getEntry(i));\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xb = 0.0;\nxa = x;\nif (x < 0) {\nif (xa == 0.0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa, xb);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nif (negative) {\nswitch (quadrant) {\nreturn sinQ(xa, xb);\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:repairAndDecode([D)[D",
            "method_body": "public double[] repairAndDecode(final double[] x) {\nreturn\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:subtract(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix subtract(final RealMatrix m)\nMatrixUtils.checkSubtractionCompatible(this, m);\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\nreturn out;\n}",
            "method_id": 59
        }
    ]
}