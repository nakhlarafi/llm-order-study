{
    "bug_id": 81,
    "test_id": 0,
    "test_name": "org.apache.commons.math.linear.EigenDecompositionImplTest.testMath308",
    "test_body": "public void testMath308() {\n114: double[] mainTridiagonal = {\n22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n};\ndouble[] secondaryTridiagonal = {\n13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n};\n121: // the reference values have been computed using routine DSTEMR\n// from the fortran library LAPACK version 3.2.1\ndouble[] refEigenValues = {\n82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n};\nRealVector[] refEigenVectors = {\nnew ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\nnew ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\nnew ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\nnew ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\nnew ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n};\n134: EigenDecomposition decomposition =\nnew EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: -1\nat org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(EigenDecompositionImpl.java:1544)\nat org.apache.commons.math.linear.EigenDecompositionImpl.goodStep(EigenDecompositionImpl.java:1071)\nat org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(EigenDecompositionImpl.java:893)\nat org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues(EigenDecompositionImpl.java:657)\nat org.apache.commons.math.linear.EigenDecompositionImpl.decompose(EigenDecompositionImpl.java:246)\nat org.apache.commons.math.linear.EigenDecompositionImpl.<init>(EigenDecompositionImpl.java:205)\nat org.apache.commons.math.linear.EigenDecompositionImplTest.testMath308(EigenDecompositionImplTest.java:134)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:ldlTDecomposition(DII)V",
            "method_body": "private void ldlTDecomposition(final double lambda, final int index, final int n) {\ndouble di = main[index] - lambda;\nwork[0] = Math.abs(di);\nfor (int i = 1; i < n; ++i) {\nfinal int    fourI = 4 * i;\nfinal double eiM1  = secondary[index + i - 1];\nfinal double ratio = eiM1 / di;\nwork[fourI - 2] = ratio * ratio * Math.abs(di);\ndi = (main[index + i] - lambda) - eiM1 * ratio;\nwork[fourI] = Math.abs(di);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:dqd(II)V",
            "method_body": "private void dqd(final int start, final int end) {\neMin = work[4 * start + pingPong + 4];\ndouble d = work[4 * start + pingPong];\ndMin = d;\nif (pingPong == 0) {\nfor (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\nwork[j4 - 2] = d + work[j4 - 1];\nif (work[j4 - 2] == 0.0) {\n} else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\nfinal double tmp = work[j4 + 1] / work[j4 - 2];\nwork[j4] = work[j4 - 1] * tmp;\nd *= tmp;\n} else {\ndMin = Math.min(dMin, d);\neMin = Math.min(eMin, work[j4]);\ndN2   = d;\ndMin2 = dMin;\nint j4 = 4 * (end - 2) - pingPong - 1;\nint j4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN2 + work[j4p2];\nif (work[j4 - 2] == 0.0) {\n} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\nfinal double tmp = work[j4p2 + 2] / work[j4 - 2];\nwork[j4] = work[j4p2] * tmp;\ndN1 = dN2 * tmp;\n} else {\ndMin = Math.min(dMin, dN1);\ndMin1 = dMin;\nj4 = j4 + 4;\nj4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN1 + work[j4p2];\nif (work[j4 - 2] == 0.0) {\n} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\nfinal double tmp = work[j4p2 + 2] / work[j4 - 2];\nwork[j4] = work[j4p2] * tmp;\ndN = dN1 * tmp;\n} else {\ndMin = Math.min(dMin, dN);\nwork[j4 + 2] = dN;\nwork[4 * end - pingPong - 1] = eMin;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:processGeneralBlock(I)V",
            "method_body": "private void processGeneralBlock(final int n)\ndouble sumOffDiag = 0;\nfor (int i = 0; i < n - 1; ++i) {\nfinal int fourI = 4 * i;\nfinal double ei = work[fourI + 2];\nsumOffDiag += ei;\nif (sumOffDiag == 0) {\nflipIfWarranted(n, 2);\ninitialSplits(n);\ntType = 0;\ndMin1 = 0;\ndMin2 = 0;\ndN    = 0;\ndN1   = 0;\ndN2   = 0;\ntau   = 0;\nint i0 = 0;\nint n0 = n;\nwhile (n0 > 0) {\nsigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\nsigmaLow = 0;\ndouble offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\ndouble offDiagMax = 0;\ndouble diagMax    = work[4 * n0 - 4];\ndouble diagMin    = diagMax;\ni0 = 0;\nfor (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\nif (work[i + 2] <= 0) {\nif (diagMin >= 4 * offDiagMax) {\ndiagMin    = Math.min(diagMin, work[i + 4]);\noffDiagMax = Math.max(offDiagMax, work[i + 2]);\ndiagMax    = Math.max(diagMax, work[i] + work[i + 2]);\noffDiagMin = Math.min(offDiagMin, work[i + 2]);\nwork[4 * n0 - 2] = offDiagMin;\ndMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\npingPong = 0;\nint maxIter = 30 * (n0 - i0);\nfor (int k = 0; i0 < n0; ++k) {\nif (k >= maxIter) {\nn0 = goodStep(i0, n0);\npingPong = 1 - pingPong;\nif ((pingPong == 0) && (n0 - i0 > 3) &&\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:initialSplits(I)V",
            "method_body": "private void initialSplits(final int n) {\npingPong = 0;\nfor (int k = 0; k < 2; ++k) {\ndouble d = work[4 * (n - 1) + pingPong];\nfor (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\nif (work[i + 2] <= TOLERANCE_2 * d) {\nd *= work[i] / (d + work[i + 2]);\nd = work[pingPong];\nfor (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\nfinal int j = i - 2 * pingPong - 1;\nwork[j] = d + work[i];\nif (work[i] <= TOLERANCE_2 * d) {\n} else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\nfinal double tmp = work[i + 2] / work[j];\nwork[j + 2] = work[i] * tmp;\nd *= tmp;\n} else {\nwork[4 * n - 3 - pingPong] = d;\npingPong = 1 - pingPong;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:dqds(II)V",
            "method_body": "private void dqds(final int start, final int end) {\neMin = work[4 * start + pingPong + 4];\ndouble d = work[4 * start + pingPong] - tau;\ndMin = d;\ndMin1 = -work[4 * start + pingPong];\nif (pingPong == 0) {\nfor (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\nwork[j4 - 2] = d + work[j4 - 1];\nfinal double tmp = work[j4 + 1] / work[j4 - 2];\nd = d * tmp - tau;\ndMin = Math.min(dMin, d);\nwork[j4] = work[j4 - 1] * tmp;\neMin = Math.min(work[j4], eMin);\nfor (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\nwork[j4 - 3] = d + work[j4];\nfinal double tmp = work[j4 + 2] / work[j4 - 3];\nd = d * tmp - tau;\ndMin = Math.min(dMin, d);\nwork[j4 - 1] = work[j4] * tmp;\neMin = Math.min(work[j4 - 1], eMin);\ndN2 = d;\ndMin2 = dMin;\nint j4 = 4 * (end - 2) - pingPong - 1;\nint j4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN2 + work[j4p2];\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\ndMin = Math.min(dMin, dN1);\ndMin1 = dMin;\nj4 = j4 + 4;\nj4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN1 + work[j4p2];\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\ndMin = Math.min(dMin, dN);\nwork[j4 + 2] = dN;\nwork[4 * end - pingPong - 1] = eMin;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:<init>([D[DD)V",
            "method_body": "public EigenDecompositionImpl(final double[] main, double[] secondary,\nthrows InvalidMatrixException {\nthis.main      = main.clone();\nthis.secondary = secondary.clone();\ntransformer    = null;\nsquaredSecondary = new double[secondary.length];\nfor (int i = 0; i < squaredSecondary.length; ++i) {\nfinal double s = secondary[i];\nsquaredSecondary[i] = s * s;\nthis.splitTolerance = splitTolerance;\ndecompose();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:updateSigma(D)V",
            "method_body": "private void updateSigma(final double shift) {\nif (shift < sigma) {\nsigmaLow += shift;\nfinal double t = sigma + sigmaLow;\nsigmaLow -= t - sigma;\nsigma = t;\n} else {\nfinal double t = sigma + shift;\nsigmaLow += sigma - (t - shift);\nsigma = t;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>()V",
            "method_body": "protected AbstractRealMatrix() {\nlu = null;\n}",
            "method_id": 29
        }
    ]
}