{
    "bug_id": 6,
    "test_id": 15,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest.testMinimize1",
    "test_body": "public void testMinimize1() {\nSimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\nfinal FourExtrema fourExtrema = new FourExtrema();\n58: final PointValuePair optimum\n= optimizer.optimize(new MaxEval(100),\nnew ObjectiveFunction(fourExtrema),\nGoalType.MINIMIZE,\nnew InitialGuess(new double[] { -3, 0 }),\nnew NelderMeadSimplex(new double[] { 0.2, 0.2 }));\nAssert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\nAssert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\nAssert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\nAssert.assertTrue(optimizer.getEvaluations() > 60);\nAssert.assertTrue(optimizer.getEvaluations() < 90);\n70: // Check that the number of iterations is updated (MATH-949).\nAssert.assertTrue(optimizer.getIterations() > 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest.testMinimize1(SimplexOptimizerNelderMeadTest.java:71)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex:<init>([D)V",
            "method_body": "public NelderMeadSimplex(final double[] steps) {\nthis(steps, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(DDZ)D",
            "method_body": "private static double atan(double xa, double xb, boolean leftPlane) {\nboolean negate = false;\nif (xa == 0.0) { // Matches +/- 0.0; return correct sign\nif (xa < 0) {\nxa = -xa;\nxb = -xb;\nnegate = true;\nif (xa > 1.633123935319537E16) { // Very large input\nif (xa < 1) {\nidx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\nfinal double oneOverXa = 1 / xa;\nidx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\ndouble epsA = xa - TANGENT_TABLE_A[idx];\ndouble epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\nepsB += xb - TANGENT_TABLE_B[idx];\ndouble temp = epsA + epsB;\nepsB = -(temp - epsA - epsB);\nepsA = temp;\ntemp = xa * HEX_40000000;\ndouble ya = xa + temp - temp;\ndouble yb = xb + xa - ya;\nxa = ya;\nxb += yb;\nif (idx == 0) {\nfinal double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\nya = epsA * denom;\nyb = epsB * denom;\n} else {\ndouble temp2 = xa * TANGENT_TABLE_A[idx];\ndouble za = 1d + temp2;\ndouble zb = -(za - 1d - temp2);\ntemp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\ntemp = za + temp2;\nzb += -(temp - za - temp2);\nza = temp;\nzb += xb * TANGENT_TABLE_B[idx];\nya = epsA / za;\ntemp = ya * HEX_40000000;\nfinal double yaa = (ya + temp) - temp;\nfinal double yab = ya - yaa;\ntemp = za * HEX_40000000;\nfinal double zaa = (za + temp) - temp;\nfinal double zab = za - zaa;\nyb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\nyb += -epsA * zb / za / za;\nyb += epsB / za;\nepsA = ya;\nepsB = yb;\nfinal double epsA2 = epsA * epsA;\nyb = 0.07490822288864472;\nyb = yb * epsA2 + -0.09088450866185192;\nyb = yb * epsA2 + 0.11111095942313305;\nyb = yb * epsA2 + -0.1428571423679182;\nyb = yb * epsA2 + 0.19999999999923582;\nyb = yb * epsA2 + -0.33333333333333287;\nyb = yb * epsA2 * epsA;\nya = epsA;\ntemp = ya + yb;\nyb = -(temp - ya - yb);\nya = temp;\nyb += epsB / (1d + epsA * epsA);\ndouble za = EIGHTHS[idx] + ya;\ndouble zb = -(za - EIGHTHS[idx] - ya);\ntemp = za + yb;\nzb += -(temp - za - yb);\nza = temp;\ndouble result = za + zb;\ndouble resultb = -(result - za - zb);\nif (leftPlane) {\nif (negate ^ leftPlane) {\nresult = -result;\nreturn result;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer$1:value([D)D",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\nreturn computeObjectiveValue(point);\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nif (converged) {\nreturn simplex.getPoint(0);\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n++iteration;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DDZ)V",
            "method_body": "public PointValuePair(final double[] point,\nsuper(copyArray ? ((point == null) ? null :\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 29
        }
    ]
}