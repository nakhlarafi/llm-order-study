{
    "bug_id": 6,
    "test_id": 2,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testConstrainedRosen",
    "test_body": "public void testConstrainedRosen() {\ndouble[] startPoint = point(DIM, 0.1);\ndouble[] insigma = point(DIM, 0.1);\ndouble[][] boundaries = boundaries(DIM, -1, 2);\nPointValuePair expected =\nnew PointValuePair(point(DIM,1.0),0.0);\ndoTest(new Rosen(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testConstrainedRosen(CMAESOptimizerTest.java:348)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sequence(DDD)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sequence(double start, double end, double step) {\nfinal int size = (int) ((end - start) / step + 1);\nfinal double[][] d = new double[size][1];\ndouble value = start;\nfor (int r = 0; r < size; r++) {\nd[r][0] = value;\nvalue += step;\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:next(I)I",
            "method_body": "protected int next(int bits) {\nif (mti >= N) { // generate N words at one time\nint mtNext = mt[0];\nfor (int k = 0; k < N - M; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\nfor (int k = N - M; k < N - 1; ++k) {\nint mtCurr = mtNext;\nmtNext = mt[k + 1];\ny = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\nmt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\ny = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\nmt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\nmti = 0;\ny = mt[mti++];\ny ^=  y >>> 11;\ny ^= (y <<   7) & 0x9d2c5680;\ny ^= (y <<  15) & 0xefc60000;\ny ^=  y >>> 18;\nreturn y >>> (32 - bits);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkAdditionCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\nif ((left.getRowDimension()    != right.getRowDimension()) ||\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:isSymmetric(Lorg/apache/commons/math3/linear/RealMatrix;D)Z",
            "method_body": "public static boolean isSymmetric(RealMatrix matrix,\nreturn isSymmetricInternal(matrix, eps, false);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.EigenDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public EigenDecomposition(final RealMatrix matrix)\nthrows MathArithmeticException {\nfinal double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\nisSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\nif (isSymmetric) {\ntransformToTridiagonal(matrix);\nfindEigenVectors(transformer.getQ().getData());\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:<init>()V",
            "method_body": "public MersenneTwister() {\nmt = new int[N];\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:push([DD)V",
            "method_body": "private static void push(double[] vals, double val) {\nfor (int i = vals.length-1; i > 0; i--) {\nvals[i] = vals[i-1];\nvals[0] = val;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 49
        }
    ]
}