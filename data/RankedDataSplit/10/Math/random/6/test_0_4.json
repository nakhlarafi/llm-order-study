{
    "bug_id": 6,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getEntry(I)D",
            "method_body": "public double getEntry(int index) throws OutOfRangeException {\nreturn data[index];\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer:<init>(ZLorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public GaussNewtonOptimizer(final boolean useLU,\nsuper(checker);\nthis.useLU = useLU;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:toBlocksLayout([[D)[[D",
            "method_body": "public static double[][] toBlocksLayout(final double[][] rawData)\nfinal int rows = rawData.length;\nfinal int columns = rawData[0].length;\nfinal int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\nfinal int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\nfor (int i = 0; i < rawData.length; ++i) {\nfinal int length = rawData[i].length;\nif (length != columns) {\nfinal double[][] blocks = new double[blockRows * blockColumns][];\nint blockIndex = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\nfinal int iHeight = pEnd - pStart;\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\nfinal int qStart = jBlock * BLOCK_SIZE;\nfinal int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\nfinal int jWidth = qEnd - qStart;\nfinal double[] block = new double[iHeight * jWidth];\nblocks[blockIndex] = block;\nint index = 0;\nfor (int p = pStart; p < pEnd; ++p) {\nSystem.arraycopy(rawData[p], qStart, block, index, jWidth);\nindex += jWidth;\n++blockIndex;\nreturn blocks;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nfinal double[][] data = new double[getRowDimension()][getColumnDimension()];\nfinal int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\nint regularPos = 0;\nint lastPos = 0;\nfor (int p = pStart; p < pEnd; ++p) {\nfinal double[] dataP = data[p];\nint blockIndex = iBlock * blockColumns;\nint dataPos = 0;\nfor (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\nSystem.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\nregularPos += BLOCK_SIZE;\nlastPos    += lastColumns;\nreturn data;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.linear.LUDecomposition$Solver:solve(Lorg/apache/commons/math3/linear/RealVector;)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector solve(RealVector b) {\nfinal int m = pivot.length;\nif (b.getDimension() != m) {\nif (singular) {\nfinal double[] bp = new double[m];\nfor (int row = 0; row < m; row++) {\nbp[row] = b.getEntry(pivot[row]);\nfor (int col = 0; col < m; col++) {\nfinal double bpCol = bp[col];\nfor (int i = col + 1; i < m; i++) {\nfor (int col = m - 1; col >= 0; col--) {\nbp[col] /= lu[col][col];\nfinal double bpCol = bp[col];\nfor (int i = 0; i < col; i++) {\nreturn new ArrayRealVector(bp, false);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:computeJacobian([D)[[D",
            "method_body": "protected double[][] computeJacobian(final double[] params) {\nreturn jacobian.value(params);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (target.length != weightMatrix.getColumnDimension()) {\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian:getModelFunctionJacobian()Lorg/apache/commons/math3/analysis/MultivariateMatrixFunction;",
            "method_body": "public MultivariateMatrixFunction getModelFunctionJacobian() {\nreturn jacobian;\n}",
            "method_id": 49
        }
    ]
}