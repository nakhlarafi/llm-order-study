{
    "bug_id": 6,
    "test_id": 19,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest.testTrivial",
    "test_body": "public void testTrivial() {\nLinearProblem problem\n= new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\nNonLinearConjugateGradientOptimizer optimizer\n= new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\nnew SimpleValueChecker(1e-6, 1e-6));\nPointValuePair optimum\n= optimizer.optimize(new MaxEval(100),\nproblem.getObjectiveFunction(),\nproblem.getObjectiveFunctionGradient(),\nGoalType.MINIMIZE,\nnew InitialGuess(new double[] { 0 }));\nAssert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\nAssert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n140: // Check that the number of iterations is updated (MATH-949).\nAssert.assertTrue(optimizer.getIterations() > 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest.testTrivial(NonLinearConjugateGradientOptimizerTest.java:141)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>(II)V",
            "method_body": "public BlockRealMatrix(final int rows, final int columns)\nsuper(rows, columns);\nthis.rows = rows;\nthis.columns = columns;\nblockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblocks = createBlocksLayout(rows, columns);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nfinal double[] point = getStartPoint();\nfinal GoalType goal = getGoalType();\nfinal int n = point.length;\ndouble[] r = computeObjectiveGradient(point);\nif (goal == GoalType.MINIMIZE) {\nfor (int i = 0; i < n; i++) {\nr[i] = -r[i];\ndouble[] steepestDescent = preconditioner.precondition(point, r);\ndouble[] searchDirection = steepestDescent.clone();\ndouble delta = 0;\nfor (int i = 0; i < n; ++i) {\ndelta += r[i] * searchDirection[i];\nPointValuePair current = null;\nint iter = 0;\nint maxEval = getMaxEvaluations();\n++iter;\nfinal double objective = computeObjectiveValue(point);\nPointValuePair previous = current;\ncurrent = new PointValuePair(point, objective);\nif (previous != null) {\nif (checker.converged(iter, previous, current)) {\nreturn current;\nfinal UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\nfinal double uB = findUpperBound(lsf, 0, initialStep);\nfinal double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\nmaxEval -= solver.getEvaluations(); // Subtract used up evaluations.\nfor (int i = 0; i < point.length; ++i) {\npoint[i] += step * searchDirection[i];\nr = computeObjectiveGradient(point);\nif (goal == GoalType.MINIMIZE) {\nfor (int i = 0; i < n; ++i) {\nr[i] = -r[i];\nfinal double deltaOld = delta;\nfinal double[] newSteepestDescent = preconditioner.precondition(point, r);\ndelta = 0;\nfor (int i = 0; i < n; ++i) {\ndelta += r[i] * newSteepestDescent[i];\nswitch (updateFormula) {\ndouble deltaMid = 0;\nfor (int i = 0; i < r.length; ++i) {\ndeltaMid += r[i] * steepestDescent[i];\nbeta = (delta - deltaMid) / deltaOld;\nbreak;\nsteepestDescent = newSteepestDescent;\nif (iter % n == 0 ||\nsearchDirection = steepestDescent.clone();\n}\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\nsuper.parseOptimizationData(optData);\nfor (OptimizationData data : optData) {\nif  (data instanceof ObjectiveFunctionGradient) {\ngradient = ((ObjectiveFunctionGradient) data).getObjectiveFunctionGradient();\nbreak;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:<init>(D)V",
            "method_body": "protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\nthis(DEFAULT_RELATIVE_ACCURACY,\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getAbsoluteAccuracy()D",
            "method_body": "public double getAbsoluteAccuracy() {\nreturn absoluteAccuracy;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>(II[[DZ)V",
            "method_body": "public BlockRealMatrix(final int rows, final int columns,\nsuper(rows, columns);\nthis.rows = rows;\nthis.columns = columns;\nblockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\nif (copyArray) {\nblocks = blockData;\nint index = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int iHeight = blockHeight(iBlock);\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\nif (blockData[index].length != iHeight * blockWidth(jBlock)) {\nif (copyArray) {\n}",
            "method_id": 59
        }
    ]
}