{
    "bug_id": 6,
    "test_id": 3,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSphere",
    "test_body": "public void testSphere() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = null;\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new Sphere(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testSphere(CMAESOptimizerTest.java:258)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.linear.TriDiagonalTransformer:transform()V",
            "method_body": "private void transform() {\nfinal int m = householderVectors.length;\nfinal double[] z = new double[m];\nfor (int k = 0; k < m - 1; k++) {\nfinal double[] hK = householderVectors[k];\nmain[k] = hK[k];\ndouble xNormSqr = 0;\nfor (int j = k + 1; j < m; ++j) {\nfinal double c = hK[j];\nxNormSqr += c * c;\nfinal double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\nsecondary[k] = a;\nif (a != 0.0) {\nhK[k + 1] -= a;\nfinal double beta = -1 / (a * hK[k + 1]);\nArrays.fill(z, k + 1, m, 0);\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfinal double hKI = hK[i];\ndouble zI = hI[i] * hKI;\nfor (int j = i + 1; j < m; ++j) {\nfinal double hIJ = hI[j];\nzI   += hIJ * hK[j];\nz[j] += hIJ * hKI;\nz[i] = beta * (z[i] + zI);\ndouble gamma = 0;\nfor (int i = k + 1; i < m; ++i) {\ngamma += z[i] * hK[i];\ngamma *= beta / 2;\nfor (int i = k + 1; i < m; ++i) {\nz[i] -= gamma * hK[i];\nfor (int i = k + 1; i < m; ++i) {\nfinal double[] hI = householderVectors[i];\nfor (int j = i; j < m; ++j) {\nhI[j] -= hK[i] * z[j] + z[i] * hK[j];\nmain[m - 1] = householderVectors[m - 1][m - 1];\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nif (upperBound != null) {\nif (upperBound.length != dim) {\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\nout.setEntry(row, col, sum);\nreturn out;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nif (left.getColumnDimension() != right.getRowDimension()) {\n}",
            "method_id": 79
        }
    ]
}