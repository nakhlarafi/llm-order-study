{
    "bug_id": 6,
    "test_id": 17,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigarWithBoundaries",
    "test_body": "public void testCigarWithBoundaries() {\ndouble[] startPoint = point(DIM,1.0);\ndouble[] insigma = point(DIM,0.1);\ndouble[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\nPointValuePair expected =\nnew PointValuePair(point(DIM,0.0),0.0);\ndoTest(new Cigar(), startPoint, insigma, boundaries,\nGoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest(CMAESOptimizerTest.java:514)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testCigarWithBoundaries(CMAESOptimizerTest.java:213)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer:sortedIndices([D)[I",
            "method_body": "private int[] sortedIndices(final double[] doubles) {\nfinal DoubleIndex[] dis = new DoubleIndex[doubles.length];\nfor (int i = 0; i < doubles.length; i++) {\ndis[i] = new DoubleIndex(doubles[i], i);\nArrays.sort(dis);\nfinal int[] indices = new int[doubles.length];\nfor (int i = 0; i < doubles.length; i++) {\nindices[i] = dis[i].index;\nreturn indices;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([II)[I",
            "method_body": "public static int[] copyOf(int[] source, int len) {\nfinal int[] output = new int[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\ndouble xa = x;\nif (x < 0) {\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\ndouble xb = 0;\nif (xa > 3294198.0) {\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\nswitch (quadrant) {\nreturn cosQ(xa, xb);\nreturn -sinQ(xa, xb);\nreturn -cosQ(xa, xb);\nreturn sinQ(xa, xb);\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\nreturn super.optimize(optData);\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$Sigma:getSigma()[D",
            "method_body": "public double[] getSigma() {\nreturn sigma.clone();\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\ndouble x2 = x*x;\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\np = p * x2 * x;\nreturn p;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\nreturn visitor.end();\n}",
            "method_id": 149
        }
    ]
}