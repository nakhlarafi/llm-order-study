{
    "bug_id": 21,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest.testFullRank",
    "test_body": "public void testFullRank() {\n53: RealMatrix base = MatrixUtils.createRealMatrix(new double[][] {\n{ 0.1159548705,      0.,           0.,           0.      },\n{ 0.0896442724, 0.1223540781,      0.,           0.      },\n{ 0.0852155322, 4.558668e-3,  0.1083577299,      0.      },\n{ 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 }\n});\n60: RealMatrix m = base.multiply(base.transpose());\n62: RectangularCholeskyDecomposition d =\nnew RectangularCholeskyDecomposition(m, 1.0e-10);\n65: RealMatrix root = d.getRootMatrix();\nRealMatrix rebuiltM = root.multiply(root.transpose());\nAssert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);\n69: // the pivoted Cholesky decomposition is *not* unique. Here, the root is\n// not equal to the original trianbular base matrix\nAssert.assertTrue(root.subtract(base).getNorm() > 0.3);\n73: }\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest.testFullRank(RectangularCholeskyDecompositionTest.java:71)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor:end()D",
            "method_body": "public double end() {\nreturn 0;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nif (o == null) {\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$1:start(IIIIII)V",
            "method_body": "public double getNorm() {\nreturn walkInColumnOrder(new RealMatrixPreservingVisitor() {\nthis.endRow = endRow;\ncolumnSum   = 0;\nmaxColSum   = 0;\n}\ncolumnSum += FastMath.abs(value);\nif (row == endRow) {\nmaxColSum = FastMath.max(maxColSum, columnSum);\ncolumnSum = 0;\n}\nreturn maxColSum;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\nif (rowDimension < 1) {\nif (columnDimension < 1) {\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.linear.RectangularCholeskyDecomposition:<init>(Lorg/apache/commons/math3/linear/RealMatrix;D)V",
            "method_body": "public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\nthrows NonPositiveDefiniteMatrixException {\nfinal int order = matrix.getRowDimension();\nfinal double[][] c = matrix.getData();\nfinal double[][] b = new double[order][order];\nint[] swap  = new int[order];\nint[] index = new int[order];\nfor (int i = 0; i < order; ++i) {\nindex[i] = i;\nint r = 0;\nfor (boolean loop = true; loop;) {\nswap[r] = r;\nfor (int i = r + 1; i < order; ++i) {\nint ii  = index[i];\nint isi = index[swap[i]];\nif (c[ii][ii] > c[isi][isi]) {\nswap[r] = i;\nif (swap[r] != r) {\nint tmp = index[r];\nindex[r] = index[swap[r]];\nindex[swap[r]] = tmp;\nint ir = index[r];\nif (c[ir][ir] < small) {\nif (r == 0) {\nfor (int i = r; i < order; ++i) {\nif (c[index[i]][index[i]] < -small) {\n++r;\nloop = false;\nfinal double sqrt = FastMath.sqrt(c[ir][ir]);\nb[r][r] = sqrt;\nfinal double inverse  = 1 / sqrt;\nfor (int i = r + 1; i < order; ++i) {\nfinal int ii = index[i];\nfinal double e = inverse * c[ii][ir];\nb[i][r] = e;\nc[ii][ii] -= e * e;\nfor (int j = r + 1; j < i; ++j) {\nfinal int ij = index[j];\nfinal double f = c[ii][ij] - e * b[j][r];\nc[ii][ij] = f;\nc[ij][ii] = f;\nloop = ++r < order;\n}\nrank = r;\nroot = MatrixUtils.createRealMatrix(order, r);\nfor (int i = 0; i < order; ++i) {\nfor (int j = 0; j < r; ++j) {\nroot.setEntry(index[i], j, b[i][j]);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.linear.RectangularCholeskyDecomposition:getRootMatrix()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getRootMatrix() {\nreturn root;\n}",
            "method_id": 9
        }
    ]
}