{
    "bug_id": 22,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.FDistributionTest.testIsSupportLowerBoundInclusive",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError: expected:<false> but was:<true>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.math3.distribution.RealDistributionAbstractTest.testIsSupportLowerBoundInclusive(RealDistributionAbstractTest.java:351)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.special.Beta:logBeta(DDDI)D",
            "method_body": "public static double logBeta(double a, double b,\nif (Double.isNaN(a) ||\nret = Gamma.logGamma(a) + Gamma.logGamma(b) -\nreturn ret;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.random.RandomDataImpl:<init>()V",
            "method_body": "public RandomDataImpl() {\ndelegate = new RandomDataGenerator();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getSupportLowerBound()D",
            "method_body": "public double getSupportLowerBound() {\nreturn 0;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:logGamma(D)D",
            "method_body": "public static double logGamma(double x) {\nif (Double.isNaN(x) || (x <= 0.0)) {\n} else if (x < 0.5) {\n} else if (x <= 2.5) {\nreturn logGamma1p((x - 0.5) - 0.5);\n} else if (x <= 8.0) {\nfinal int n = (int) FastMath.floor(x - 1.5);\ndouble prod = 1.0;\nfor (int i = 1; i <= n; i++) {\nprod *= x - i;\nreturn logGamma1p(x - (n + 1)) + FastMath.log(prod);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:logBeta(DD)D",
            "method_body": "public static double logBeta(double a, double b) {\nreturn logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:isSupportLowerBoundInclusive()Z",
            "method_body": "public boolean isSupportLowerBoundInclusive() {\nreturn true;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:<init>(IIII[I)V",
            "method_body": "protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\nfinal int w = 32;\nfinal int r = (k + w - 1) / w;\nthis.v      = new int[r];\nthis.index  = 0;\niRm1 = new int[r];\niRm2 = new int[r];\ni1   = new int[r];\ni2   = new int[r];\ni3   = new int[r];\nfor (int j = 0; j < r; ++j) {\niRm1[j] = (j + r - 1) % r;\niRm2[j] = (j + r - 2) % r;\ni1[j]   = (j + m1)    % r;\ni2[j]   = (j + m2)    % r;\ni3[j]   = (j + m3)    % r;\nsetSeed(seed);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(DDD)V",
            "method_body": "public FDistribution(double numeratorDegreesOfFreedom,\nthis(new Well19937c(), numeratorDegreesOfFreedom,\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:logGamma1p(D)D",
            "method_body": "public static double logGamma1p(final double x)\nif (x < -0.5) {\nif (x > 1.5) {\nreturn -FastMath.log1p(invGamma1pm1(x));\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nreturn Double.NEGATIVE_INFINITY;\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x == Double.POSITIVE_INFINITY) {\nint exp = (int)(bits >> 52)-1023;\nif ((bits & 0x7ff0000000000000L) == 0) {\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\nif (hiPrec != null) {\ndouble tmp = epsilon * HEX_40000000;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\nfinal double numer = bits & 0x3ffffffffffL;\nfinal double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\nfinal double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\nfinal double[] lnCoef_i = LN_HI_PREC_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\nreturn a + b;\n}",
            "method_id": 9
        }
    ]
}