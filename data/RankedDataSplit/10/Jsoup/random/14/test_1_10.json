{
    "bug_id": 14,
    "test_id": 1,
    "test_name": "org.jsoup.parser.ParserTest.handlesUnclosedTitle",
    "test_body": "554: @Test public void handlesUnclosedTitle() {\n555: Document one = Jsoup.parse(\"<title>One <b>Two <b>Three</TITLE><p>Test</p>\"); // has title, so <b> is plain text\n556: assertEquals(\"One <b>Two <b>Three\", one.title());\n557: assertEquals(\"Test\", one.select(\"p\").first().text());\n558: 559: Document two = Jsoup.parse(\"<title>One<b>Two <p>Test</p>\"); // no title, so <b> causes </title> breakout\n560: assertEquals(\"One\", two.title());\n561: assertEquals(\"<b>Two <p>Test</p></b>\", two.body().html());\n562: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:originalState()Lorg/jsoup/parser/TreeBuilderState;",
            "method_body": "TreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.select.Evaluator$Tag:<init>(Ljava/lang/String;)V",
            "method_body": "public abstract boolean matches(Element root, Element element);\npublic Tag(String tagName) {\nthis.tagName = tagName;\n}\nreturn (element.tagName().equals(tagName));\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:normaliseWhitespace(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public static String normaliseWhitespace(String string) {\nStringBuilder sb = new StringBuilder(string.length());\nboolean lastWasWhite = false;\nboolean modified = false;\nint l = string.length();\nfor (int i = 0; i < l; i++) {\nint c = string.codePointAt(i);\nif (Character.isWhitespace(c)) {\nsb.appendCodePoint(c);\nlastWasWhite = false;\nreturn modified ? sb.toString() : string;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCharacter()Z",
            "method_body": "boolean isCharacter() {\nreturn type == TokenType.Character;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn isEmpty() ? EOF : input.charAt(pos);\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\nemitPending = token;\nisEmitPending = true;\nif (token.type == Token.TokenType.StartTag) {\nToken.StartTag startTag = (Token.StartTag) token;\nlastStartTag = startTag;\nif (startTag.selfClosing)\n} else if (token.type == Token.TokenType.EndTag) {\nToken.EndTag endTag = (Token.EndTag) token;\nif (endTag.attributes.size() > 0)\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.nodes.Node:addChildren([Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void addChildren(Node... children) {\nfor (Node child: children) {\nreparentChild(child);\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size()-1);\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.nodes.Element:preserveWhitespace()Z",
            "method_body": "boolean preserveWhitespace() {\nreturn tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n}",
            "method_id": 109
        }
    ]
}