{
    "bug_id": 17,
    "test_id": 0,
    "test_name": "org.jsoup.parser.ParserTest.handles0CharacterAsText",
    "test_body": "607: @Test public void handles0CharacterAsText() {\n608: Document doc = Jsoup.parse(\"0<p>0</p>\");\n609: assertEquals(\"0\\n<p>0</p>\", doc.body().html());\n610: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(String str) {\ncharBuffer.append(str);\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.nodes.Element:outerHtmlHead(Ljava/lang/StringBuilder;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\nif (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\naccum\nattributes.html(accum, out);\nif (childNodes.isEmpty() && tag.isSelfClosing())\naccum.append(\">\");\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.Token:isComment()Z",
            "method_body": "boolean isComment() {\nreturn type == TokenType.Comment;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$6:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\n} else if (t.isComment()) {\n} else if (t.isDoctype()) {\n} else if (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"html\")) {\n} else if (name.equals(\"body\")) {\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InBody);\n} else if (t.isEndTag()) {\nanythingElse(t, tb);\nreturn true;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:error(Lorg/jsoup/parser/TreeBuilderState;)V",
            "method_body": "void error(TreeBuilderState state) {\nif (trackErrors)\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$6:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, TreeBuilder tb) {\ntb.process(new Token.StartTag(\"body\"));\ntb.framesetOk(true);\nreturn tb.process(t);\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.nodes.Document:body()Lorg/jsoup/nodes/Element;",
            "method_body": "public Element body() {\nreturn findFirstElementByTagName(\"body\", this);\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$24:<clinit>()V",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\nswitch (t.type) {\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\nreturn anythingElse(t, tb);\nreturn true;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.helper.DescendableLinkedList$DescendingIterator:hasNext()Z",
            "method_body": "public boolean hasNext() {\nreturn iter.hasPrevious();\n}",
            "method_id": 119
        }
    ]
}