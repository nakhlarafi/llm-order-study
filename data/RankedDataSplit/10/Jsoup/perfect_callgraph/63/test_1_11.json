{
    "bug_id": 63,
    "test_id": 1,
    "test_name": "org.jsoup.parser.HtmlParserTest.tracksErrorsWhenRequested",
    "test_body": "689: @Test public void tracksErrorsWhenRequested() {\n690: String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n691: Parser parser = Parser.htmlParser().setTrackErrors(500);\n692: Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n693: 694: List<ParseError> errors = parser.getErrors();\n695: assertEquals(5, errors.size());\n696: assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n697: assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n698: assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n699: assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());\n700: assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n701: }\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;I)V",
            "method_body": "public CharacterReader(Reader input, int sz) {\nValidate.notNull(input);\nValidate.isTrue(input.markSupported());\nreader = input;\ncharBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\nbufferUp();\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public CharacterReader(Reader input) {\nthis(input, maxBufferLen);\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:bufferUp()V",
            "method_body": "private void bufferUp() {\nif (bufPos < bufSplitPoint)\nreturn;\nreaderPos += bufPos;\nreader.skip(bufPos);\nreader.mark(maxBufferLen);\nbufLength = reader.read(charBuf);\nreader.reset();\nbufPos = 0;\nbufMark = 0;\nbufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n}\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:pos()I",
            "method_body": "public int pos() {\nreturn readerPos + bufPos;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn bufPos >= bufLength;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "public char current() {\nbufferUp();\nreturn isEmpty() ? EOF : charBuf[bufPos];\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nbufferUp();\nchar val = isEmpty() ? EOF : charBuf[bufPos];\nbufPos++;\nreturn val;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "public void advance() {\nbufPos++;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:nextIndexOf(C)I",
            "method_body": "int nextIndexOf(char c) {\nbufferUp();\nfor (int i = bufPos; i < bufLength; i++) {\nif (c == charBuf[i])\nreturn i - bufPos;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTo(C)Ljava/lang/String;",
            "method_body": "public String consumeTo(char c) {\nint offset = nextIndexOf(c);\nif (offset != -1) {\nString consumed = cacheString(charBuf, stringCache, bufPos, offset);\nbufPos += offset;\nreturn consumed;\n}",
            "method_id": 119
        }
    ]
}