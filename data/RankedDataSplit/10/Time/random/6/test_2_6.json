{
    "bug_id": 6,
    "test_id": 2,
    "test_name": "org.joda.time.chrono.TestGJDate.test_plusWeekyears_positiveToZero_crossCutover",
    "test_body": "public void test_plusWeekyears_positiveToZero_crossCutover() {\nLocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\nLocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\nassertEquals(expected, date.weekyear().addToCopy(-2003));\n}\n",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 0 for year is not supported\nat org.joda.time.field.SkipDateTimeField.set(SkipDateTimeField.java:92)\nat org.joda.time.chrono.GJChronology.convertByWeekyear(GJChronology.java:96)\nat org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(GJChronology.java:596)\nat org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(GJChronology.java:922)\nat org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(GJChronology.java:979)\nat org.joda.time.LocalDate$Property.addToCopy(LocalDate.java:1965)\nat org.joda.time.chrono.TestGJDate.test_plusWeekyears_positiveToZero_crossCutover(TestGJDate.java:118)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\nif (instant >= iCutover) {\ninstant = iJulianField.roundFloor(instant);\nreturn instant;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMaximumValue(J)I",
            "method_body": "public int getMaximumValue(long instant) {\nreturn getMaximumValue();\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nif ((base = getBase()) != null) {\nreturn DateTimeZone.UTC;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInYearMonth(II)I",
            "method_body": "int getDaysInYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\nreturn MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.joda.time.chrono.JulianChronology:getMaxYear()I",
            "method_body": "int getMaxYear() {\nreturn MAX_YEAR;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getMaximumValueForSet(JI)I",
            "method_body": "protected int getMaximumValueForSet(long instant, int value) {\nreturn getMaximumValue(instant);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:gregorianToJulianByWeekyear(J)J",
            "method_body": "long gregorianToJulianByWeekyear(long instant) {\nreturn convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.joda.time.LocalDate:withWeekOfWeekyear(I)Lorg/joda/time/LocalDate;",
            "method_body": "public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\nreturn withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:gregorianToJulian(J)J",
            "method_body": "protected long gregorianToJulian(long instant) {\nif (iConvertByWeekyear) {\nreturn gregorianToJulianByWeekyear(instant);\nreturn gregorianToJulianByYear(instant);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\ni2 = i2 - unitMillis + 1;\nint year = (int) (i2 / unitMillis);\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\nif (diff < 0) {\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\nreturn year;\n}",
            "method_id": 69
        }
    ]
}