{
    "bug_id": 14,
    "test_id": 6,
    "test_name": "org.joda.time.TestMonthDay_Basics.testPlusDays_int_fromLeap",
    "test_body": "public void testPlusDays_int_fromLeap() {\nMonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\nMonthDay result = test.plusDays(1);\nMonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:218)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(BasicMonthOfYearDateTimeField.java:213)\nat org.joda.time.field.BaseDateTimeField.add(BaseDateTimeField.java:324)\nat org.joda.time.MonthDay.withFieldAdded(MonthDay.java:519)\nat org.joda.time.MonthDay.plusDays(MonthDay.java:612)\nat org.joda.time.TestMonthDay_Basics.testPlusDays_int_fromLeap(TestMonthDay_Basics.java:509)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:monthOfYear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField monthOfYear() {\nreturn iMonthOfYear;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:add(Lorg/joda/time/ReadablePartial;I[II)[I",
            "method_body": "public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\nif (valueToAdd == 0) {\nDateTimeField nextField = null;\nwhile (valueToAdd > 0) {\nint max = getMaximumValue(instant, values);\nlong proposed = values[fieldIndex] + valueToAdd;\nif (proposed <= max) {\nif (nextField == null) {\nif (fieldIndex == 0) {\nnextField = instant.getField(fieldIndex - 1);\nif (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\nvalueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\nvalues = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\nvalues[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n}\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInMonthMax(I)I",
            "method_body": "int getDaysInMonthMax(int month) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMinimumValue(Lorg/joda/time/ReadablePartial;[I)I",
            "method_body": "public int getMinimumValue(ReadablePartial instant, int[] values) {\nreturn getMinimumValue(instant);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getTotalMillisByYearMonth(II)J",
            "method_body": "long getTotalMillisByYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.MonthDay:plusDays(I)Lorg/joda/time/MonthDay;",
            "method_body": "public MonthDay plusDays(int days) {\nreturn withFieldAdded(DurationFieldType.days(), days);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "protected int indexOf(DurationFieldType type) {\nfor (int i = 0, isize = size(); i < isize; i++) {\nif (getFieldType(i).getDurationType() == type) {\nreturn i;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:getField(I)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(int index) {\nreturn getField(index, getChronology());\n}",
            "method_id": 59
        }
    ]
}