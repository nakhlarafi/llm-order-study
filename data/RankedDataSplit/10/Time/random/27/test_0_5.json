{
    "bug_id": 27,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455",
    "test_body": "public void testBug2495455() {\nPeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n.appendLiteral(\"P\")\n.appendYears()\n.appendSuffix(\"Y\")\n.appendMonths()\n.appendSuffix(\"M\")\n.appendWeeks()\n.appendSuffix(\"W\")\n.appendDays()\n.appendSuffix(\"D\")\n.appendSeparatorIfFieldsAfter(\"T\")\n.appendHours()\n.appendSuffix(\"H\")\n.appendMinutes()\n.appendSuffix(\"M\")\n.appendSecondsWithOptionalMillis()\n.appendSuffix(\"S\")\n.toFormatter();\nPeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n.append(ISOPeriodFormat.standard())\n.toFormatter();\npfmt1.parsePeriod(\"PT1003199059S\");\npfmt2.parsePeriod(\"PT1003199059S\");\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"PT1003199059S\" is malformed at \"1003199059S\"\nat org.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:326)\nat org.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:304)\nat org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455(TestPeriodFormatterBuilder.java:869)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:createComposite(Ljava/util/List;)[Ljava/lang/Object;",
            "method_body": "private static Object[] createComposite(List<Object> elementPairs) {\nswitch (elementPairs.size()) {\nreturn new Object[] {Literal.EMPTY, Literal.EMPTY};\nComposite comp = new Composite(elementPairs);\nreturn new Object[] {comp, comp};\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:<init>(JLorg/joda/time/PeriodType;)V",
            "method_body": "public MutablePeriod(long duration, PeriodType type) {\nsuper(duration, type, null);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendSuffix(String text) {\nif (text == null) {\nreturn appendSuffix(new SimpleAffix(text));\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:getPrinter()Lorg/joda/time/format/PeriodPrinter;",
            "method_body": "public PeriodPrinter getPrinter() {\nreturn iPrinter;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter(Ljava/util/List;ZZ)Lorg/joda/time/format/PeriodFormatter;",
            "method_body": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\nif (notPrinter && notParser) {\nint size = elementPairs.size();\nif (size >= 2 && elementPairs.get(0) instanceof Separator) {\nSeparator sep = (Separator) elementPairs.get(0);\nPeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\nsep = sep.finish(f.getPrinter(), f.getParser());\nreturn new PeriodFormatter(sep, sep);\nObject[] comp = createComposite(elementPairs);\nif (notPrinter) {\n} else if (notParser) {\nreturn new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMinutes()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendMinutes() {\nappendField(MINUTES);\nreturn this;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nint oldPos = position;\nposition = iBeforeParser.parseInto(period, periodStr, position, locale);\nif (position < 0) {\nboolean found = false;\nif (position > oldPos) {\nString[] parsedForms = iParsedForms;\nint length = parsedForms.length;\nfor (int i=0; i < length; i++) {\nString parsedForm = parsedForms[i];\nif ((parsedForm == null || parsedForm.length() == 0) ||\nposition += parsedForm.length();\nfound = true;\nbreak;\noldPos = position;\nposition = iAfterParser.parseInto(period, periodStr, position, locale);\nif (position < 0) {\nif (found && position == oldPos) {\nreturn ~oldPos;\nif (position > oldPos && !found && !iUseBefore) {\nreturn position;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.convert.ConverterSet:select(Ljava/lang/Class;)Lorg/joda/time/convert/Converter;",
            "method_body": "Converter select(Class<?> type) throws IllegalStateException {\nEntry[] entries = iSelectEntries;\nint length = entries.length;\nint index = type == null ? 0 : type.hashCode() & (length - 1);\nwhile ((e = entries[index]) != null) {\nif (e.iType == type) {\nreturn e.iConverter;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:toPeriod()Lorg/joda/time/Period;",
            "method_body": "public Period toPeriod() {\nreturn new Period(this);\n}",
            "method_id": 59
        }
    ]
}