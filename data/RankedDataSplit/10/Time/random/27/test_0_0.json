{
    "bug_id": 27,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455",
    "test_body": "public void testBug2495455() {\nPeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n.appendLiteral(\"P\")\n.appendYears()\n.appendSuffix(\"Y\")\n.appendMonths()\n.appendSuffix(\"M\")\n.appendWeeks()\n.appendSuffix(\"W\")\n.appendDays()\n.appendSuffix(\"D\")\n.appendSeparatorIfFieldsAfter(\"T\")\n.appendHours()\n.appendSuffix(\"H\")\n.appendMinutes()\n.appendSuffix(\"M\")\n.appendSecondsWithOptionalMillis()\n.appendSuffix(\"S\")\n.toFormatter();\nPeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n.append(ISOPeriodFormat.standard())\n.toFormatter();\npfmt1.parsePeriod(\"PT1003199059S\");\npfmt2.parsePeriod(\"PT1003199059S\");\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"PT1003199059S\" is malformed at \"1003199059S\"\nat org.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:326)\nat org.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:304)\nat org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455(TestPeriodFormatterBuilder.java:869)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(I)V",
            "method_body": "private void appendField(int type) {\nappendField(type, iMinPrintedDigits);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMonths()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendMonths() {\nappendField(MONTHS);\nreturn this;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setFieldInto([ILorg/joda/time/DurationFieldType;I)V",
            "method_body": "protected void setFieldInto(int[] values, DurationFieldType field, int value) {\nint index = indexOf(field);\nif (index == -1) {\nvalues[index] = value;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:parseInt(Ljava/lang/String;II)I",
            "method_body": "private int parseInt(String text, int position, int length) {\nif (length >= 10) {\nreturn Integer.parseInt(text.substring(position, position + length));\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.Period:<init>(Ljava/lang/Object;)V",
            "method_body": "public Period(Object period) {\nsuper(period, null, null);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparatorIfFieldsAfter(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\nreturn appendSeparator(text, text, null, false, true);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:setFieldValue(Lorg/joda/time/ReadWritablePeriod;II)V",
            "method_body": "void setFieldValue(ReadWritablePeriod period, int field, int value) {\nswitch (field) {\nperiod.setSeconds(value);\nbreak;\nperiod.setMillis(value);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:<init>(Ljava/lang/Object;Lorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\nsuper();\nPeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\ntype = (type == null ? converter.getPeriodType(period) : type);\ntype = checkPeriodType(type);\niType = type;\nif (this instanceof ReadWritablePeriod) {\niValues = new int[size()];\nchrono = DateTimeUtils.getChronology(chrono);\nconverter.setInto((ReadWritablePeriod) this, period, chrono);\niValues = new MutablePeriod(period, type, chrono).getValues();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nboolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\nif (position >= text.length()) {\nif (iPrefix != null) {\nint suffixPos = -1;\nif (iSuffix != null && !mustParse) {\nsuffixPos = iSuffix.scan(text, position);\nif (suffixPos >= 0) {\nmustParse = true;\nif (!mustParse) {\nreturn ~suffixPos;\nif (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\nif (suffixPos > 0) {\nlimit = Math.min(iMaxParsedDigits, suffixPos - position);\nint length = 0;\nint fractPos = -1;\nboolean hasDigits = false;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\nif (c >= '0' && c <= '9') {\nhasDigits = true;\nlength++;\n}\nif (!hasDigits) {\nif (suffixPos >= 0 && position + length != suffixPos) {\nif (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n} else if (fractPos < 0) {\nsetFieldValue(period, SECONDS, parseInt(text, position, length));\nsetFieldValue(period, MILLIS, 0);\nposition += length;\nif (position >= 0 && iSuffix != null) {\nposition = iSuffix.parse(text, position);\nreturn position;\n}",
            "method_id": 9
        }
    ]
}