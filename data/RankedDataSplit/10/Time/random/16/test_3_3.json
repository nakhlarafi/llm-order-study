{
    "bug_id": 16,
    "test_id": 3,
    "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29",
    "test_body": "public void testParseInto_monthDay_feb29() {\nDateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\nMutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\nassertEquals(4, f.parseInto(result, \"2 29\", 0));\nassertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2004-02-29T12:20:30.000Z> but was:<2000-02-29T12:20:30.000Z>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29(TestDateTimeFormatter.java:905)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfYear(JI)I",
            "method_body": "int getDayOfYear(long instant, int year) {\nlong yearStart = getYearMillis(year);\nreturn (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "protected Chronology checkChronology(Chronology chronology) {\nreturn DateTimeUtils.getChronology(chronology);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:findMatchingRecurrence(J)Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;",
            "method_body": "private Recurrence findMatchingRecurrence(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\nstart = startRecurrence.next\n}\nend = endRecurrence.next\n}\nreturn (start > end) ? startRecurrence : endRecurrence;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nbuf.append(iValue);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
            "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:previousTransition(J)J",
            "method_body": "public long previousTransition(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\ni = ~i;\nif (i < transitions.length) {\nif (iTailZone != null) {\nlong prev = iTailZone.previousTransition(instant);\nif (prev < instant) {\nreturn prev;\nlong prev = transitions[i - 1];\nif (prev > Long.MIN_VALUE) {\nreturn prev - 1;\n}",
            "method_id": 39
        }
    ]
}