{
    "bug_id": 3,
    "test_id": 0,
    "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddWeeks_int_dstOverlapWinter_addZero",
    "test_body": "public void testAddWeeks_int_dstOverlapWinter_addZero() {\nMutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\ntest.addHours(1);\nassertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\ntest.addWeeks(0);\nassertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<...10-30T02:30:00.000+0[1]:00> but was:<...10-30T02:30:00.000+0[2]:00>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat org.joda.time.TestMutableDateTime_Adds.testAddWeeks_int_dstOverlapWinter_addZero(TestMutableDateTime_Adds.java:300)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
            "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:addWeeks(I)V",
            "method_body": "public void addWeeks(final int weeks) {\nsetMillis(getChronology().weeks().add(getMillis(), weeks));\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nreturn zone;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
            "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.base.AbstractDateTime:<init>()V",
            "method_body": "protected AbstractDateTime() {\nsuper();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:<init>()V",
            "method_body": "protected AbstractInstant() {\nsuper();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
            "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
            "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}",
            "method_id": 9
        }
    ]
}