{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek",
    "test_body": "public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\nDateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n.appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\nDateTimeFormatter f = bld.toFormatter();\n260: DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\nassertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\nassertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"\nat org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866)\nat org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nString str = text.substring(position);\nfor (String id : ALL_IDS) {\nif (str.startsWith(id)) {\nbucket.setZone(DateTimeZone.forID(id));\nreturn position + id.length();\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
            "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendPattern(String pattern) {\nDateTimeFormat.appendPatternTo(this, pattern);\nreturn this;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
            "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
            "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}",
            "method_id": 9
        }
    ]
}