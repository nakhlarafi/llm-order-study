{
    "bug_id": 20,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek",
    "test_body": "public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\nDateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n.appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\nDateTimeFormatter f = bld.toFormatter();\n260: DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\nassertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\nassertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"\nat org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866)\nat org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
            "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}",
            "method_id": 180
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}",
            "method_id": 181
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}",
            "method_id": 182
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getWrappedField()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField getWrappedField() {\nreturn iField;\n}",
            "method_id": 183
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:readFrom(Ljava/io/DataInput;)Lorg/joda/time/tz/DateTimeZoneBuilder$OfYear;",
            "method_body": "static OfYear readFrom(DataInput in) throws IOException {\nreturn new OfYear((char)in.readUnsignedByte(),\n}",
            "method_id": 184
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn 1;\n}",
            "method_id": 185
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfMonth(instant);\n}",
            "method_id": 186
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minutes()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField minutes() {\nreturn iMinutes;\n}",
            "method_id": 187
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}",
            "method_id": 188
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:isSupported(Lorg/joda/time/DateTimeField;)Z",
            "method_body": "private static boolean isSupported(DateTimeField field) {\nreturn field == null ? false : field.isSupported();\n}",
            "method_id": 189
        }
    ]
}