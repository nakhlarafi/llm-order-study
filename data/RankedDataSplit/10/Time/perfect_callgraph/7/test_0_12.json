{
    "bug_id": 7,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_endOfYear",
    "test_body": "public void testParseInto_monthDay_feb29_tokyo_endOfYear() {\nDateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\nMutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO);\nassertEquals(4, f.parseInto(result, \"2 29\", 0));\nassertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result);",
    "stack_trace": "org.joda.time.IllegalFieldValueException: Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]\nat org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\nat org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\nat org.joda.time.format.DateTimeParserBucket$SavedField.set(DateTimeParserBucket.java:483)\nat org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:366)\nat org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:359)\nat org.joda.time.format.DateTimeFormatter.parseInto(DateTimeFormatter.java:715)\nat org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_endOfYear(TestDateTimeFormatter.java:960)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.field.ImpreciseDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField getDurationField() {\nreturn iDurationField;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = Math.min(iMaxParsedDigits, text.length() - position);\nboolean negative = false;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (length == 0 && (c == '-' || c == '+') && iSigned) {\nif (c < '0' || c > '9') {\nlength++;\n}\nif (length == 0) {\nif (length >= 9) {\nint i = position;\nif (negative) {\nvalue = text.charAt(i++) - '0';\n}\nposition += length;\nwhile (i < position) {\nvalue = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\nif (negative) {\nbucket.saveField(iFieldType, value);\nreturn position;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth(I)I",
            "method_body": "abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\nreturn getMaxMonth();\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 1;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDaysInMonthMax(J)I",
            "method_body": "int getDaysInMonthMax(long instant) {\nint thisYear = getYear(instant);\nint thisMonth = getMonthOfYear(instant, thisYear);\nreturn getDaysInYearMonth(thisYear, thisMonth);\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nthisDom = maxDom;\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeParser[] elements = iParsers;\nif (elements == null) {\nint len = elements.length;\nfor (int i=0; i<len && position >= 0; i++) {\nposition = elements[i].parseInto(bucket, text, position);\nreturn position;\n}",
            "method_id": 129
        }
    ]
}