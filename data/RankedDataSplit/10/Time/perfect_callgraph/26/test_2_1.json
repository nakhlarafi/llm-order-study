{
    "bug_id": 26,
    "test_id": 2,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_Paris_summer",
    "test_body": "public void testWithMillisOfSecondInDstChange_Paris_summer() {\nDateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\nassertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\nDateTime test = dateTime.withMillisOfSecond(0);\nassertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.000+0[2]:00> but was:<...10-31T02:30:10.000+0[1]:00>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat org.joda.time.TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_Paris_summer(TestDateTimeZoneCutover.java:1108)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfDay() {\nreturn iHourOfDay;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\nint year = (int) (i2 / unitMillis);\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\nif (diff < 0) {\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\nreturn year;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTimeParser()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateTimeParser() {\nif (dtp == null) {\nreturn dtp;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:getFractionData(JLorg/joda/time/DateTimeField;)[J",
            "method_body": "private long[] getFractionData(long fraction, DateTimeField field) {\nlong rangeMillis = field.getDurationField().getUnitMillis();\nint maxDigits = iMaxDigits;\nswitch (maxDigits) {\ncase 9:  scalar = 1000000000L; break;\nif (((rangeMillis * scalar) / scalar) == rangeMillis) {\nbreak;\nreturn new long[] {fraction * scalar / rangeMillis, maxDigits};\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeField field = iFieldType.getField(bucket.getChronology());\nint limit = Math.min(iMaxDigits, text.length() - position);\nlong value = 0;\nlong n = field.getDurationField().getUnitMillis() * 10;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (c < '0' || c > '9') {\nlength++;\nlong nn = n / 10;\nvalue += (c - '0') * nn;\nn = nn;\n}\nvalue /= 10;\nif (length == 0) {\nif (value > Integer.MAX_VALUE) {\nDateTimeField parseField = new PreciseDateTimeField(\nbucket.saveField(parseField, (int) value);\nreturn position + length;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:year()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField year() {\nreturn iYear;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn 1;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
            "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedState:restoreState(Lorg/joda/time/format/DateTimeParserBucket;)Z",
            "method_body": "boolean restoreState(DateTimeParserBucket enclosing) {\nif (enclosing != DateTimeParserBucket.this) {\nenclosing.iZone = this.iZone;\nenclosing.iOffset = this.iOffset;\nenclosing.iSavedFields = this.iSavedFields;\nif (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\nenclosing.iSavedFieldsShared = true;\nenclosing.iSavedFieldsCount = this.iSavedFieldsCount;\nreturn true;\n}",
            "method_id": 19
        }
    ]
}